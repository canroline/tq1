(global["webpackJsonp"] = global["webpackJsonp"] || []).push([["common/vendor"],{

/***/ 0:
/*!*************************!*\
  !*** E:/tq/tq1/main.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createApp) {__webpack_require__(/*! uni-pages */ 4);
var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _App = _interopRequireDefault(__webpack_require__(/*! ./App */ 5));




var _store = _interopRequireDefault(__webpack_require__(/*! ./store */ 11));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};var ownKeys = Object.keys(source);if (typeof Object.getOwnPropertySymbols === 'function') {ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {return Object.getOwnPropertyDescriptor(source, sym).enumerable;}));}ownKeys.forEach(function (key) {_defineProperty(target, key, source[key]);});}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}var pageHead = function pageHead() {return __webpack_require__.e(/*! import() | components/page-head */ "components/page-head").then(__webpack_require__.bind(null, /*! ./components/page-head.vue */ 57));};var pageFoot = function pageFoot() {return __webpack_require__.e(/*! import() | components/page-foot */ "components/page-foot").then(__webpack_require__.bind(null, /*! ./components/page-foot.vue */ 62));};var uLink = function uLink() {return __webpack_require__.e(/*! import() | components/uLink */ "components/uLink").then(__webpack_require__.bind(null, /*! @/components/uLink.vue */ 69));};

_vue.default.config.productionTip = false;

_vue.default.prototype.$store = _store.default;
_vue.default.prototype.$backgroundAudioData = {
  playing: false,
  playTime: 0,
  formatedPlayTime: '00:00:00' };


_vue.default.component('page-head', pageHead);
_vue.default.component('page-foot', pageFoot);
_vue.default.component('uLink', uLink);

// import { ModelObj } from 'vue-3d-model';
// Vue.components('ModelObj', ModelObj)

_App.default.mpType = 'app';

var app = new _vue.default(_objectSpread({
  store: _store.default },
_App.default));

createApp(app).$mount();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createApp"]))

/***/ }),

/***/ 1:
/*!************************************************************!*\
  !*** ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });exports.createApp = createApp;exports.createPage = createPage;exports.createComponent = createComponent;exports.default = void 0;var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _slicedToArray(arr, i) {return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();}function _nonIterableRest() {throw new TypeError("Invalid attempt to destructure non-iterable instance");}function _iterableToArrayLimit(arr, i) {var _arr = [];var _n = true;var _d = false;var _e = undefined;try {for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {_arr.push(_s.value);if (i && _arr.length === i) break;}} catch (err) {_d = true;_e = err;} finally {try {if (!_n && _i["return"] != null) _i["return"]();} finally {if (_d) throw _e;}}return _arr;}function _arrayWithHoles(arr) {if (Array.isArray(arr)) return arr;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance");}function _iterableToArray(iter) {if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {arr2[i] = arr[i];}return arr2;}}

var _toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function isFn(fn) {
  return typeof fn === 'function';
}

function isStr(str) {
  return typeof str === 'string';
}

function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

function noop() {}

/**
                    * Create a cached version of a pure function.
                    */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
   * Camelize a hyphen-delimited string.
   */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : '';});
});

var HOOKS = [
'invoke',
'success',
'fail',
'complete',
'returnValue'];


var globalInterceptors = {};
var scopedInterceptors = {};

function mergeHook(parentVal, childVal) {
  var res = childVal ?
  parentVal ?
  parentVal.concat(childVal) :
  Array.isArray(childVal) ?
  childVal : [childVal] :
  parentVal;
  return res ?
  dedupeHooks(res) :
  res;
}

function dedupeHooks(hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}

function removeHook(hooks, hook) {
  var index = hooks.indexOf(hook);
  if (index !== -1) {
    hooks.splice(index, 1);
  }
}

function mergeInterceptorHook(interceptor, option) {
  Object.keys(option).forEach(function (hook) {
    if (HOOKS.indexOf(hook) !== -1 && isFn(option[hook])) {
      interceptor[hook] = mergeHook(interceptor[hook], option[hook]);
    }
  });
}

function removeInterceptorHook(interceptor, option) {
  if (!interceptor || !option) {
    return;
  }
  Object.keys(option).forEach(function (hook) {
    if (HOOKS.indexOf(hook) !== -1 && isFn(option[hook])) {
      removeHook(interceptor[hook], option[hook]);
    }
  });
}

function addInterceptor(method, option) {
  if (typeof method === 'string' && isPlainObject(option)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), option);
  } else if (isPlainObject(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}

function removeInterceptor(method, option) {
  if (typeof method === 'string') {
    if (isPlainObject(option)) {
      removeInterceptorHook(scopedInterceptors[method], option);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}

function wrapperHook(hook) {
  return function (data) {
    return hook(data) || data;
  };
}

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

function queue(hooks, data) {
  var promise = false;
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    if (promise) {
      promise = Promise.then(wrapperHook(hook));
    } else {
      var res = hook(data);
      if (isPromise(res)) {
        promise = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then: function then() {} };

      }
    }
  }
  return promise || {
    then: function then(callback) {
      return callback(data);
    } };

}

function wrapperOptions(interceptor) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  ['success', 'fail', 'complete'].forEach(function (name) {
    if (Array.isArray(interceptor[name])) {
      var oldCallback = options[name];
      options[name] = function callbackInterceptor(res) {
        queue(interceptor[name], res).then(function (res) {
          /* eslint-disable no-mixed-operators */
          return isFn(oldCallback) && oldCallback(res) || res;
        });
      };
    }
  });
  return options;
}

function wrapperReturnValue(method, returnValue) {
  var returnValueHooks = [];
  if (Array.isArray(globalInterceptors.returnValue)) {
    returnValueHooks.push.apply(returnValueHooks, _toConsumableArray(globalInterceptors.returnValue));
  }
  var interceptor = scopedInterceptors[method];
  if (interceptor && Array.isArray(interceptor.returnValue)) {
    returnValueHooks.push.apply(returnValueHooks, _toConsumableArray(interceptor.returnValue));
  }
  returnValueHooks.forEach(function (hook) {
    returnValue = hook(returnValue) || returnValue;
  });
  return returnValue;
}

function getApiInterceptorHooks(method) {
  var interceptor = Object.create(null);
  Object.keys(globalInterceptors).forEach(function (hook) {
    if (hook !== 'returnValue') {
      interceptor[hook] = globalInterceptors[hook].slice();
    }
  });
  var scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach(function (hook) {
      if (hook !== 'returnValue') {
        interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);
      }
    });
  }
  return interceptor;
}

function invokeApi(method, api, options) {for (var _len = arguments.length, params = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {params[_key - 3] = arguments[_key];}
  var interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (Array.isArray(interceptor.invoke)) {
      var res = queue(interceptor.invoke, options);
      return res.then(function (options) {
        return api.apply(void 0, [wrapperOptions(interceptor, options)].concat(params));
      });
    } else {
      return api.apply(void 0, [wrapperOptions(interceptor, options)].concat(params));
    }
  }
  return api.apply(void 0, [options].concat(params));
}

var promiseInterceptor = {
  returnValue: function returnValue(res) {
    if (!isPromise(res)) {
      return res;
    }
    return res.then(function (res) {
      return res[1];
    }).catch(function (res) {
      return res[0];
    });
  } };


var SYNC_API_RE =
/^\$|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64/;

var CONTEXT_API_RE = /^create|Manager$/;

var CALLBACK_API_RE = /^on/;

function isContextApi(name) {
  return CONTEXT_API_RE.test(name);
}
function isSyncApi(name) {
  return SYNC_API_RE.test(name);
}

function isCallbackApi(name) {
  return CALLBACK_API_RE.test(name);
}

function handlePromise(promise) {
  return promise.then(function (data) {
    return [null, data];
  }).
  catch(function (err) {return [err];});
}

function shouldPromise(name) {
  if (
  isContextApi(name) ||
  isSyncApi(name) ||
  isCallbackApi(name))
  {
    return false;
  }
  return true;
}

function promisify(name, api) {
  if (!shouldPromise(name)) {
    return api;
  }
  return function promiseApi() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {params[_key2 - 1] = arguments[_key2];}
    if (isFn(options.success) || isFn(options.fail) || isFn(options.complete)) {
      return wrapperReturnValue(name, invokeApi.apply(void 0, [name, api, options].concat(params)));
    }
    return wrapperReturnValue(name, handlePromise(new Promise(function (resolve, reject) {
      invokeApi.apply(void 0, [name, api, Object.assign({}, options, {
        success: resolve,
        fail: reject })].concat(
      params));
      /* eslint-disable no-extend-native */
      if (!Promise.prototype.finally) {
        Promise.prototype.finally = function (callback) {
          var promise = this.constructor;
          return this.then(
          function (value) {return promise.resolve(callback()).then(function () {return value;});},
          function (reason) {return promise.resolve(callback()).then(function () {
              throw reason;
            });});

        };
      }
    })));
  };
}

var EPS = 1e-4;
var BASE_DEVICE_WIDTH = 750;
var isIOS = false;
var deviceWidth = 0;
var deviceDPR = 0;

function checkDeviceWidth() {var _wx$getSystemInfoSync =




  wx.getSystemInfoSync(),platform = _wx$getSystemInfoSync.platform,pixelRatio = _wx$getSystemInfoSync.pixelRatio,windowWidth = _wx$getSystemInfoSync.windowWidth; // uni=>wx runtime 编译目标是 uni 对象，内部不允许直接使用 uni

  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform === 'ios';
}

function upx2px(number, newDeviceWidth) {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }

  number = Number(number);
  if (number === 0) {
    return 0;
  }
  var result = number / BASE_DEVICE_WIDTH * (newDeviceWidth || deviceWidth);
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      return 1;
    } else {
      return 0.5;
    }
  }
  return number < 0 ? -result : result;
}

var interceptors = {
  promiseInterceptor: promiseInterceptor };




var baseApi = /*#__PURE__*/Object.freeze({
  upx2px: upx2px,
  interceptors: interceptors,
  addInterceptor: addInterceptor,
  removeInterceptor: removeInterceptor });


var previewImage = {
  args: function args(fromArgs) {
    var currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    var urls = fromArgs.urls;
    if (!Array.isArray(urls)) {
      return;
    }
    var len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      fromArgs.current = urls[currentIndex];
      fromArgs.urls = urls.filter(
      function (item, index) {return index < currentIndex ? item !== urls[currentIndex] : true;});

    } else {
      fromArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false };

  } };


var protocols = {
  previewImage: previewImage };

var todos = [];
var canIUses = [];

var CALLBACKS = ['success', 'fail', 'cancel', 'complete'];

function processCallback(methodName, method, returnValue) {
  return function (res) {
    return method(processReturnValue(methodName, res, returnValue));
  };
}

function processArgs(methodName, fromArgs) {var argsOption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var returnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};var keepFromArgs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (isPlainObject(fromArgs)) {// 一般 api 的参数解析
    var toArgs = keepFromArgs === true ? fromArgs : {}; // returnValue 为 false 时，说明是格式化返回值，直接在返回值对象上修改赋值
    if (isFn(argsOption)) {
      argsOption = argsOption(fromArgs, toArgs) || {};
    }
    for (var key in fromArgs) {
      if (hasOwn(argsOption, key)) {
        var keyOption = argsOption[key];
        if (isFn(keyOption)) {
          keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
        }
        if (!keyOption) {// 不支持的参数
          console.warn("\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F ".concat(methodName, "\u6682\u4E0D\u652F\u6301").concat(key));
        } else if (isStr(keyOption)) {// 重写参数 key
          toArgs[keyOption] = fromArgs[key];
        } else if (isPlainObject(keyOption)) {// {name:newName,value:value}可重新指定参数 key:value
          toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
        }
      } else if (CALLBACKS.indexOf(key) !== -1) {
        toArgs[key] = processCallback(methodName, fromArgs[key], returnValue);
      } else {
        if (!keepFromArgs) {
          toArgs[key] = fromArgs[key];
        }
      }
    }
    return toArgs;
  } else if (isFn(fromArgs)) {
    fromArgs = processCallback(methodName, fromArgs, returnValue);
  }
  return fromArgs;
}

function processReturnValue(methodName, res, returnValue) {var keepReturnValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  if (isFn(protocols.returnValue)) {// 处理通用 returnValue
    res = protocols.returnValue(methodName, res);
  }
  return processArgs(methodName, res, returnValue, {}, keepReturnValue);
}

function wrapper(methodName, method) {
  if (hasOwn(protocols, methodName)) {
    var protocol = protocols[methodName];
    if (!protocol) {// 暂不支持的 api
      return function () {
        console.error("\u5FAE\u4FE1\u5C0F\u7A0B\u5E8F \u6682\u4E0D\u652F\u6301".concat(methodName));
      };
    }
    return function (arg1, arg2) {// 目前 api 最多两个参数
      var options = protocol;
      if (isFn(protocol)) {
        options = protocol(arg1);
      }

      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);

      var args = [arg1];
      if (typeof arg2 !== 'undefined') {
        args.push(arg2);
      }
      var returnValue = wx[options.name || methodName].apply(wx, args);
      if (isSyncApi(methodName)) {// 同步 api
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  }
  return method;
}

var todoApis = Object.create(null);

var TODOS = [
'subscribePush',
'unsubscribePush',
'onPush',
'offPush',
'share'];


function createTodoApi(name) {
  return function todoApi(_ref)


  {var fail = _ref.fail,complete = _ref.complete;
    var res = {
      errMsg: "".concat(name, ":fail:\u6682\u4E0D\u652F\u6301 ").concat(name, " \u65B9\u6CD5") };

    isFn(fail) && fail(res);
    isFn(complete) && complete(res);
  };
}

TODOS.forEach(function (name) {
  todoApis[name] = createTodoApi(name);
});

var providers = {
  oauth: ['weixin'],
  share: ['weixin'],
  payment: ['wxpay'],
  push: ['weixin'] };


function getProvider(_ref2)




{var service = _ref2.service,success = _ref2.success,fail = _ref2.fail,complete = _ref2.complete;
  var res = false;
  if (providers[service]) {
    res = {
      errMsg: 'getProvider:ok',
      service: service,
      provider: providers[service] };

    isFn(success) && success(res);
  } else {
    res = {
      errMsg: 'getProvider:fail:服务[' + service + ']不存在' };

    isFn(fail) && fail(res);
  }
  isFn(complete) && complete(res);
}

var extraApi = /*#__PURE__*/Object.freeze({
  getProvider: getProvider });


var getEmitter = function () {
  if (typeof getUniEmitter === 'function') {
    /* eslint-disable no-undef */
    return getUniEmitter;
  }
  var Emitter;
  return function getUniEmitter() {
    if (!Emitter) {
      Emitter = new _vue.default();
    }
    return Emitter;
  };
}();

function apply(ctx, method, args) {
  return ctx[method].apply(ctx, args);
}

function $on() {
  return apply(getEmitter(), '$on', Array.prototype.slice.call(arguments));
}
function $off() {
  return apply(getEmitter(), '$off', Array.prototype.slice.call(arguments));
}
function $once() {
  return apply(getEmitter(), '$once', Array.prototype.slice.call(arguments));
}
function $emit() {
  return apply(getEmitter(), '$emit', Array.prototype.slice.call(arguments));
}



var eventApi = /*#__PURE__*/Object.freeze({
  $on: $on,
  $off: $off,
  $once: $once,
  $emit: $emit });




var api = /*#__PURE__*/Object.freeze({});



var MPPage = Page;
var MPComponent = Component;

var customizeRE = /:/g;

var customize = cached(function (str) {
  return camelize(str.replace(customizeRE, '-'));
});

function initTriggerEvent(mpInstance) {
  {
    if (!wx.canIUse('nextTick')) {
      return;
    }
  }
  var oldTriggerEvent = mpInstance.triggerEvent;
  mpInstance.triggerEvent = function (event) {for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {args[_key3 - 1] = arguments[_key3];}
    return oldTriggerEvent.apply(mpInstance, [customize(event)].concat(args));
  };
}

function initHook(name, options) {
  var oldHook = options[name];
  if (!oldHook) {
    options[name] = function () {
      initTriggerEvent(this);
    };
  } else {
    options[name] = function () {
      initTriggerEvent(this);for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {args[_key4] = arguments[_key4];}
      return oldHook.apply(this, args);
    };
  }
}

Page = function Page() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  initHook('onLoad', options);
  return MPPage(options);
};

Component = function Component() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  initHook('created', options);
  return MPComponent(options);
};

var PAGE_EVENT_HOOKS = [
'onPullDownRefresh',
'onReachBottom',
'onShareAppMessage',
'onPageScroll',
'onResize',
'onTabItemTap'];


function initMocks(vm, mocks) {
  var mpInstance = vm.$mp[vm.mpType];
  mocks.forEach(function (mock) {
    if (hasOwn(mpInstance, mock)) {
      vm[mock] = mpInstance[mock];
    }
  });
}

function hasHook(hook, vueOptions) {
  if (!vueOptions) {
    return true;
  }

  if (_vue.default.options && Array.isArray(_vue.default.options[hook])) {
    return true;
  }

  vueOptions = vueOptions.default || vueOptions;

  if (isFn(vueOptions)) {
    if (isFn(vueOptions.extendOptions[hook])) {
      return true;
    }
    if (vueOptions.super &&
    vueOptions.super.options &&
    Array.isArray(vueOptions.super.options[hook])) {
      return true;
    }
    return false;
  }

  if (isFn(vueOptions[hook])) {
    return true;
  }
  var mixins = vueOptions.mixins;
  if (Array.isArray(mixins)) {
    return !!mixins.find(function (mixin) {return hasHook(hook, mixin);});
  }
}

function initHooks(mpOptions, hooks, vueOptions) {
  hooks.forEach(function (hook) {
    if (hasHook(hook, vueOptions)) {
      mpOptions[hook] = function (args) {
        return this.$vm && this.$vm.__call_hook(hook, args);
      };
    }
  });
}

function initVueComponent(Vue$$1, vueOptions) {
  vueOptions = vueOptions.default || vueOptions;
  var VueComponent;
  if (isFn(vueOptions)) {
    VueComponent = vueOptions;
    vueOptions = VueComponent.extendOptions;
  } else {
    VueComponent = Vue$$1.extend(vueOptions);
  }
  return [VueComponent, vueOptions];
}

function initSlots(vm, vueSlots) {
  if (Array.isArray(vueSlots) && vueSlots.length) {
    var $slots = Object.create(null);
    vueSlots.forEach(function (slotName) {
      $slots[slotName] = true;
    });
    vm.$scopedSlots = vm.$slots = $slots;
  }
}

function initVueIds(vueIds, mpInstance) {
  vueIds = (vueIds || '').split(',');
  var len = vueIds.length;

  if (len === 1) {
    mpInstance._$vueId = vueIds[0];
  } else if (len === 2) {
    mpInstance._$vueId = vueIds[0];
    mpInstance._$vuePid = vueIds[1];
  }
}

function initData(vueOptions, context) {
  var data = vueOptions.data || {};
  var methods = vueOptions.methods || {};

  if (typeof data === 'function') {
    try {
      data = data.call(context); // 支持 Vue.prototype 上挂的数据
    } catch (e) {
      if (Object({"NODE_ENV":"development","VUE_APP_PLATFORM":"mp-weixin","BASE_URL":"/"}).VUE_APP_DEBUG) {
        console.warn('根据 Vue 的 data 函数初始化小程序 data 失败，请尽量确保 data 函数中不访问 vm 对象，否则可能影响首次数据渲染速度。', data);
      }
    }
  } else {
    try {
      // 对 data 格式化
      data = JSON.parse(JSON.stringify(data));
    } catch (e) {}
  }

  if (!isPlainObject(data)) {
    data = {};
  }

  Object.keys(methods).forEach(function (methodName) {
    if (context.__lifecycle_hooks__.indexOf(methodName) === -1 && !hasOwn(data, methodName)) {
      data[methodName] = methods[methodName];
    }
  });

  return data;
}

var PROP_TYPES = [String, Number, Boolean, Object, Array, null];

function createObserver(name) {
  return function observer(newVal, oldVal) {
    if (this.$vm) {
      this.$vm[name] = newVal; // 为了触发其他非 render watcher
    }
  };
}

function initBehaviors(vueOptions, initBehavior) {
  var vueBehaviors = vueOptions['behaviors'];
  var vueExtends = vueOptions['extends'];
  var vueMixins = vueOptions['mixins'];

  var vueProps = vueOptions['props'];

  if (!vueProps) {
    vueOptions['props'] = vueProps = [];
  }

  var behaviors = [];
  if (Array.isArray(vueBehaviors)) {
    vueBehaviors.forEach(function (behavior) {
      behaviors.push(behavior.replace('uni://', "wx".concat("://")));
      if (behavior === 'uni://form-field') {
        if (Array.isArray(vueProps)) {
          vueProps.push('name');
          vueProps.push('value');
        } else {
          vueProps['name'] = {
            type: String,
            default: '' };

          vueProps['value'] = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: '' };

        }
      }
    });
  }
  if (isPlainObject(vueExtends) && vueExtends.props) {
    behaviors.push(
    initBehavior({
      properties: initProperties(vueExtends.props, true) }));


  }
  if (Array.isArray(vueMixins)) {
    vueMixins.forEach(function (vueMixin) {
      if (isPlainObject(vueMixin) && vueMixin.props) {
        behaviors.push(
        initBehavior({
          properties: initProperties(vueMixin.props, true) }));


      }
    });
  }
  return behaviors;
}

function parsePropType(key, type, defaultValue, file) {
  // [String]=>String
  if (Array.isArray(type) && type.length === 1) {
    return type[0];
  }
  return type;
}

function initProperties(props) {var isBehavior = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var file = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  var properties = {};
  if (!isBehavior) {
    properties.vueId = {
      type: String,
      value: '' };

    properties.vueSlots = { // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots
      type: null,
      value: [],
      observer: function observer(newVal, oldVal) {
        var $slots = Object.create(null);
        newVal.forEach(function (slotName) {
          $slots[slotName] = true;
        });
        this.setData({
          $slots: $slots });

      } };

  }
  if (Array.isArray(props)) {// ['title']
    props.forEach(function (key) {
      properties[key] = {
        type: null,
        observer: createObserver(key) };

    });
  } else if (isPlainObject(props)) {// {title:{type:String,default:''},content:String}
    Object.keys(props).forEach(function (key) {
      var opts = props[key];
      if (isPlainObject(opts)) {// title:{type:String,default:''}
        var value = opts['default'];
        if (isFn(value)) {
          value = value();
        }

        opts.type = parsePropType(key, opts.type, value, file);

        properties[key] = {
          type: PROP_TYPES.indexOf(opts.type) !== -1 ? opts.type : null,
          value: value,
          observer: createObserver(key) };

      } else {// content:String
        var type = parsePropType(key, opts, null, file);
        properties[key] = {
          type: PROP_TYPES.indexOf(type) !== -1 ? type : null,
          observer: createObserver(key) };

      }
    });
  }
  return properties;
}

function wrapper$1(event) {
  // TODO 又得兼容 mpvue 的 mp 对象
  try {
    event.mp = JSON.parse(JSON.stringify(event));
  } catch (e) {}

  event.stopPropagation = noop;
  event.preventDefault = noop;

  event.target = event.target || {};

  if (!hasOwn(event, 'detail')) {
    event.detail = {};
  }

  if (isPlainObject(event.detail)) {
    event.target = Object.assign({}, event.target, event.detail);
  }

  return event;
}

function getExtraValue(vm, dataPathsArray) {
  var context = vm;
  dataPathsArray.forEach(function (dataPathArray) {
    var dataPath = dataPathArray[0];
    var value = dataPathArray[2];
    if (dataPath || typeof value !== 'undefined') {// ['','',index,'disable']
      var propPath = dataPathArray[1];
      var valuePath = dataPathArray[3];

      var vFor = dataPath ? vm.__get_value(dataPath, context) : context;

      if (Number.isInteger(vFor)) {
        context = value;
      } else if (!propPath) {
        context = vFor[value];
      } else {
        if (Array.isArray(vFor)) {
          context = vFor.find(function (vForItem) {
            return vm.__get_value(propPath, vForItem) === value;
          });
        } else if (isPlainObject(vFor)) {
          context = Object.keys(vFor).find(function (vForKey) {
            return vm.__get_value(propPath, vFor[vForKey]) === value;
          });
        } else {
          console.error('v-for 暂不支持循环数据：', vFor);
        }
      }

      if (valuePath) {
        context = vm.__get_value(valuePath, context);
      }
    }
  });
  return context;
}

function processEventExtra(vm, extra, event) {
  var extraObj = {};

  if (Array.isArray(extra) && extra.length) {
    /**
                                                  *[
                                                  *    ['data.items', 'data.id', item.data.id],
                                                  *    ['metas', 'id', meta.id]
                                                  *],
                                                  *[
                                                  *    ['data.items', 'data.id', item.data.id],
                                                  *    ['metas', 'id', meta.id]
                                                  *],
                                                  *'test'
                                                  */
    extra.forEach(function (dataPath, index) {
      if (typeof dataPath === 'string') {
        if (!dataPath) {// model,prop.sync
          extraObj['$' + index] = vm;
        } else {
          if (dataPath === '$event') {// $event
            extraObj['$' + index] = event;
          } else if (dataPath.indexOf('$event.') === 0) {// $event.target.value
            extraObj['$' + index] = vm.__get_value(dataPath.replace('$event.', ''), event);
          } else {
            extraObj['$' + index] = vm.__get_value(dataPath);
          }
        }
      } else {
        extraObj['$' + index] = getExtraValue(vm, dataPath);
      }
    });
  }

  return extraObj;
}

function getObjByArray(arr) {
  var obj = {};
  for (var i = 1; i < arr.length; i++) {
    var element = arr[i];
    obj[element[0]] = element[1];
  }
  return obj;
}

function processEventArgs(vm, event) {var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];var isCustom = arguments.length > 4 ? arguments[4] : undefined;var methodName = arguments.length > 5 ? arguments[5] : undefined;
  var isCustomMPEvent = false; // wxcomponent 组件，传递原始 event 对象
  if (isCustom) {// 自定义事件
    isCustomMPEvent = event.currentTarget &&
    event.currentTarget.dataset &&
    event.currentTarget.dataset.comType === 'wx';
    if (!args.length) {// 无参数，直接传入 event 或 detail 数组
      if (isCustomMPEvent) {
        return [event];
      }
      return event.detail.__args__ || event.detail;
    }
  }

  var extraObj = processEventExtra(vm, extra, event);

  var ret = [];
  args.forEach(function (arg) {
    if (arg === '$event') {
      if (methodName === '__set_model' && !isCustom) {// input v-model value
        ret.push(event.target.value);
      } else {
        if (isCustom && !isCustomMPEvent) {
          ret.push(event.detail.__args__[0]);
        } else {// wxcomponent 组件或内置组件
          ret.push(event);
        }
      }
    } else {
      if (Array.isArray(arg) && arg[0] === 'o') {
        ret.push(getObjByArray(arg));
      } else if (typeof arg === 'string' && hasOwn(extraObj, arg)) {
        ret.push(extraObj[arg]);
      } else {
        ret.push(arg);
      }
    }
  });

  return ret;
}

var ONCE = '~';
var CUSTOM = '^';

function isMatchEventType(eventType, optType) {
  return eventType === optType ||

  optType === 'regionchange' && (

  eventType === 'begin' ||
  eventType === 'end');


}

function handleEvent(event) {var _this = this;
  event = wrapper$1(event);

  // [['tap',[['handle',[1,2,a]],['handle1',[1,2,a]]]]]
  var dataset = (event.currentTarget || event.target).dataset;
  if (!dataset) {
    return console.warn("\u4E8B\u4EF6\u4FE1\u606F\u4E0D\u5B58\u5728");
  }
  var eventOpts = dataset.eventOpts || dataset['event-opts']; // 支付宝 web-view 组件 dataset 非驼峰
  if (!eventOpts) {
    return console.warn("\u4E8B\u4EF6\u4FE1\u606F\u4E0D\u5B58\u5728");
  }

  // [['handle',[1,2,a]],['handle1',[1,2,a]]]
  var eventType = event.type;
  eventOpts.forEach(function (eventOpt) {
    var type = eventOpt[0];
    var eventsArray = eventOpt[1];

    var isCustom = type.charAt(0) === CUSTOM;
    type = isCustom ? type.slice(1) : type;
    var isOnce = type.charAt(0) === ONCE;
    type = isOnce ? type.slice(1) : type;

    if (eventsArray && isMatchEventType(eventType, type)) {
      eventsArray.forEach(function (eventArray) {
        var methodName = eventArray[0];
        if (methodName) {
          var handlerCtx = _this.$vm;
          if (
          handlerCtx.$options.generic &&
          handlerCtx.$parent &&
          handlerCtx.$parent.$parent)
          {// mp-weixin,mp-toutiao 抽象节点模拟 scoped slots
            handlerCtx = handlerCtx.$parent.$parent;
          }
          var handler = handlerCtx[methodName];
          if (!isFn(handler)) {
            throw new Error(" _vm.".concat(methodName, " is not a function"));
          }
          if (isOnce) {
            if (handler.once) {
              return;
            }
            handler.once = true;
          }
          handler.apply(handlerCtx, processEventArgs(
          _this.$vm,
          event,
          eventArray[1],
          eventArray[2],
          isCustom,
          methodName));

        }
      });
    }
  });
}

var hooks = [
'onShow',
'onHide',
'onError',
'onPageNotFound'];


function parseBaseApp(vm, _ref3)


{var mocks = _ref3.mocks,initRefs = _ref3.initRefs;
  _vue.default.prototype.mpHost = "mp-weixin";

  _vue.default.mixin({
    beforeCreate: function beforeCreate() {
      if (!this.$options.mpType) {
        return;
      }

      this.mpType = this.$options.mpType;

      this.$mp = _defineProperty({
        data: {} },
      this.mpType, this.$options.mpInstance);


      this.$scope = this.$options.mpInstance;

      delete this.$options.mpType;
      delete this.$options.mpInstance;

      if (this.mpType !== 'app') {
        initRefs(this);
        initMocks(this, mocks);
      }
    } });


  var appOptions = {
    onLaunch: function onLaunch(args) {
      if (this.$vm) {// 已经初始化过了，主要是为了百度，百度 onShow 在 onLaunch 之前
        return;
      }
      {
        if (!wx.canIUse('nextTick')) {// 事实 上2.2.3 即可，简单使用 2.3.0 的 nextTick 判断
          console.error('当前微信基础库版本过低，请将 微信开发者工具-详情-项目设置-调试基础库版本 更换为`2.3.0`以上');
        }
      }

      this.$vm = vm;

      this.$vm.$mp = {
        app: this };


      this.$vm.$scope = this;

      this.$vm._isMounted = true;
      this.$vm.__call_hook('mounted', args);

      this.$vm.__call_hook('onLaunch', args);
    } };


  // 兼容旧版本 globalData
  appOptions.globalData = vm.$options.globalData || {};

  initHooks(appOptions, hooks);

  return appOptions;
}

var mocks = ['__route__', '__wxExparserNodeId__', '__wxWebviewId__'];

function findVmByVueId(vm, vuePid) {
  var $children = vm.$children;
  // 优先查找直属
  var parentVm = $children.find(function (childVm) {return childVm.$scope._$vueId === vuePid;});
  if (parentVm) {
    return parentVm;
  }
  // 反向递归查找
  for (var i = $children.length - 1; i >= 0; i--) {
    parentVm = findVmByVueId($children[i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}

function initBehavior(options) {
  return Behavior(options);
}

function isPage() {
  return !!this.route;
}

function initRelation(detail) {
  this.triggerEvent('__l', detail);
}

function initRefs(vm) {
  var mpInstance = vm.$scope;
  Object.defineProperty(vm, '$refs', {
    get: function get() {
      var $refs = {};
      var components = mpInstance.selectAllComponents('.vue-ref');
      components.forEach(function (component) {
        var ref = component.dataset.ref;
        $refs[ref] = component.$vm || component;
      });
      var forComponents = mpInstance.selectAllComponents('.vue-ref-in-for');
      forComponents.forEach(function (component) {
        var ref = component.dataset.ref;
        if (!$refs[ref]) {
          $refs[ref] = [];
        }
        $refs[ref].push(component.$vm || component);
      });
      return $refs;
    } });

}

function handleLink(event) {var _ref4 =



  event.detail || event.value,vuePid = _ref4.vuePid,vueOptions = _ref4.vueOptions; // detail 是微信,value 是百度(dipatch)

  var parentVm;

  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }

  if (!parentVm) {
    parentVm = this.$vm;
  }

  vueOptions.parent = parentVm;
}

function parseApp(vm) {
  return parseBaseApp(vm, {
    mocks: mocks,
    initRefs: initRefs });

}

function createApp(vm) {
  App(parseApp(vm));
  return vm;
}

function parseBaseComponent(vueComponentOptions)


{var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},isPage$$1 = _ref5.isPage,initRelation$$1 = _ref5.initRelation;var _initVueComponent =
  initVueComponent(_vue.default, vueComponentOptions),_initVueComponent2 = _slicedToArray(_initVueComponent, 2),VueComponent = _initVueComponent2[0],vueOptions = _initVueComponent2[1];

  var componentOptions = {
    options: {
      multipleSlots: true,
      addGlobalClass: true },

    data: initData(vueOptions, _vue.default.prototype),
    behaviors: initBehaviors(vueOptions, initBehavior),
    properties: initProperties(vueOptions.props, false, vueOptions.__file),
    lifetimes: {
      attached: function attached() {
        var properties = this.properties;

        var options = {
          mpType: isPage$$1.call(this) ? 'page' : 'component',
          mpInstance: this,
          propsData: properties };


        initVueIds(properties.vueId, this);

        // 处理父子关系
        initRelation$$1.call(this, {
          vuePid: this._$vuePid,
          vueOptions: options });


        // 初始化 vue 实例
        this.$vm = new VueComponent(options);

        // 处理$slots,$scopedSlots（暂不支持动态变化$slots）
        initSlots(this.$vm, properties.vueSlots);

        // 触发首次 setData
        this.$vm.$mount();
      },
      ready: function ready() {
        // 当组件 props 默认值为 true，初始化时传入 false 会导致 created,ready 触发, 但 attached 不触发
        // https://developers.weixin.qq.com/community/develop/doc/00066ae2844cc0f8eb883e2a557800
        if (this.$vm) {
          this.$vm._isMounted = true;
          this.$vm.__call_hook('mounted');
          this.$vm.__call_hook('onReady');
        }
      },
      detached: function detached() {
        this.$vm.$destroy();
      } },

    pageLifetimes: {
      show: function show(args) {
        this.$vm && this.$vm.__call_hook('onPageShow', args);
      },
      hide: function hide() {
        this.$vm && this.$vm.__call_hook('onPageHide');
      },
      resize: function resize(size) {
        this.$vm && this.$vm.__call_hook('onPageResize', size);
      } },

    methods: {
      __l: handleLink,
      __e: handleEvent } };



  if (isPage$$1) {
    return componentOptions;
  }
  return [componentOptions, VueComponent];
}

function parseComponent(vueComponentOptions) {
  return parseBaseComponent(vueComponentOptions, {
    isPage: isPage,
    initRelation: initRelation });

}

var hooks$1 = [
'onShow',
'onHide',
'onUnload'];


hooks$1.push.apply(hooks$1, PAGE_EVENT_HOOKS);

function parseBasePage(vuePageOptions, _ref6)


{var isPage = _ref6.isPage,initRelation = _ref6.initRelation;
  var pageOptions = parseComponent(vuePageOptions, {
    isPage: isPage,
    initRelation: initRelation });


  initHooks(pageOptions.methods, hooks$1, vuePageOptions);

  pageOptions.methods.onLoad = function (args) {
    this.$vm.$mp.query = args; // 兼容 mpvue
    this.$vm.__call_hook('onLoad', args);
  };

  return pageOptions;
}

function parsePage(vuePageOptions) {
  return parseBasePage(vuePageOptions, {
    isPage: isPage,
    initRelation: initRelation });

}

function createPage(vuePageOptions) {
  {
    return Component(parsePage(vuePageOptions));
  }
}

function createComponent(vueOptions) {
  {
    return Component(parseComponent(vueOptions));
  }
}

todos.forEach(function (todoApi) {
  protocols[todoApi] = false;
});

canIUses.forEach(function (canIUseApi) {
  var apiName = protocols[canIUseApi] && protocols[canIUseApi].name ? protocols[canIUseApi].name :
  canIUseApi;
  if (!wx.canIUse(apiName)) {
    protocols[canIUseApi] = false;
  }
});

var uni = {};

if (typeof Proxy !== 'undefined' && "mp-weixin" !== 'app-plus') {
  uni = new Proxy({}, {
    get: function get(target, name) {
      if (baseApi[name]) {
        return baseApi[name];
      }
      if (api[name]) {
        return promisify(name, api[name]);
      }
      {
        if (extraApi[name]) {
          return promisify(name, extraApi[name]);
        }
        if (todoApis[name]) {
          return promisify(name, todoApis[name]);
        }
      }
      if (eventApi[name]) {
        return eventApi[name];
      }
      if (!hasOwn(wx, name) && !hasOwn(protocols, name)) {
        return;
      }
      return promisify(name, wrapper(name, wx[name]));
    } });

} else {
  Object.keys(baseApi).forEach(function (name) {
    uni[name] = baseApi[name];
  });

  {
    Object.keys(todoApis).forEach(function (name) {
      uni[name] = promisify(name, todoApis[name]);
    });
    Object.keys(extraApi).forEach(function (name) {
      uni[name] = promisify(name, todoApis[name]);
    });
  }

  Object.keys(eventApi).forEach(function (name) {
    uni[name] = eventApi[name];
  });

  Object.keys(api).forEach(function (name) {
    uni[name] = promisify(name, api[name]);
  });

  Object.keys(wx).forEach(function (name) {
    if (hasOwn(wx, name) || hasOwn(protocols, name)) {
      uni[name] = promisify(name, wrapper(name, wx[name]));
    }
  });
}

wx.createApp = createApp;
wx.createPage = createPage;
wx.createComponent = createComponent;

var uni$1 = uni;var _default =

uni$1;exports.default = _default;

/***/ }),

/***/ 10:
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 109:
/*!********************************************************************!*\
  !*** E:/tq/tq1/node_modules/vue-3d-model/dist/vue-3d-model.umd.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
(function webpackUniversalModuleDefinition(root,factory){
if(true)
module.exports=factory(__webpack_require__(/*! vue */ 2));else
{}
})(typeof self!=='undefined'?self:void 0,function(__WEBPACK_EXTERNAL_MODULE__8bbf__){
return(/******/function(modules){// webpackBootstrap
/******/ // The module cache
/******/var installedModules={};
/******/
/******/ // The require function
/******/function __webpack_require__(moduleId){
/******/
/******/ // Check if module is in cache
/******/if(installedModules[moduleId]){
/******/return installedModules[moduleId].exports;
/******/}
/******/ // Create a new module (and put it into the cache)
/******/var module=installedModules[moduleId]={
/******/i:moduleId,
/******/l:false,
/******/exports:{}
/******/};
/******/
/******/ // Execute the module function
/******/modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);
/******/
/******/ // Flag the module as loaded
/******/module.l=true;
/******/
/******/ // Return the exports of the module
/******/return module.exports;
/******/}
/******/
/******/
/******/ // expose the modules object (__webpack_modules__)
/******/__webpack_require__.m=modules;
/******/
/******/ // expose the module cache
/******/__webpack_require__.c=installedModules;
/******/
/******/ // define getter function for harmony exports
/******/__webpack_require__.d=function(exports,name,getter){
/******/if(!__webpack_require__.o(exports,name)){
/******/Object.defineProperty(exports,name,{enumerable:true,get:getter});
/******/}
/******/};
/******/
/******/ // define __esModule on exports
/******/__webpack_require__.r=function(exports){
/******/if(typeof Symbol!=='undefined'&&Symbol.toStringTag){
/******/Object.defineProperty(exports,Symbol.toStringTag,{value:'Module'});
/******/}
/******/Object.defineProperty(exports,'__esModule',{value:true});
/******/};
/******/
/******/ // create a fake namespace object
/******/ // mode & 1: value is a module id, require it
/******/ // mode & 2: merge all properties of value into the ns
/******/ // mode & 4: return value when already ns object
/******/ // mode & 8|1: behave like require
/******/__webpack_require__.t=function(value,mode){
/******/if(mode&1)value=__webpack_require__(value);
/******/if(mode&8)return value;
/******/if(mode&4&&typeof value==='object'&&value&&value.__esModule)return value;
/******/var ns=Object.create(null);
/******/__webpack_require__.r(ns);
/******/Object.defineProperty(ns,'default',{enumerable:true,value:value});
/******/if(mode&2&&typeof value!='string')for(var key in value){__webpack_require__.d(ns,key,function(key){return value[key];}.bind(null,key));}
/******/return ns;
/******/};
/******/
/******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=function(module){
/******/var getter=module&&module.__esModule?
/******/function getDefault(){return module['default'];}:
/******/function getModuleExports(){return module;};
/******/__webpack_require__.d(getter,'a',getter);
/******/return getter;
/******/};
/******/
/******/ // Object.prototype.hasOwnProperty.call
/******/__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};
/******/
/******/ // __webpack_public_path__
/******/__webpack_require__.p="";
/******/
/******/
/******/ // Load entry module and return exports
/******/return __webpack_require__(__webpack_require__.s="c497");
/******/}(
/************************************************************************/
/******/{

/***/"01f5":
/***/function f5(module,exports,__webpack_require__){

// optional / simple context binding
var aFunction=__webpack_require__("648a");
module.exports=function(fn,that,length){
aFunction(fn);
if(that===undefined)return fn;
switch(length){
case 1:return function(a){
return fn.call(that,a);
};
case 2:return function(a,b){
return fn.call(that,a,b);
};
case 3:return function(a,b,c){
return fn.call(that,a,b,c);
};}

return function()/* ...args */{
return fn.apply(that,arguments);
};
};


/***/},

/***/"03b3":
/***/function b3(module,exports){

var hasOwnProperty={}.hasOwnProperty;
module.exports=function(it,key){
return hasOwnProperty.call(it,key);
};


/***/},

/***/"0d5f":
/***/function d5f(module,exports,__webpack_require__){

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject=__webpack_require__("a013");
var aFunction=__webpack_require__("648a");
var SPECIES=__webpack_require__("8b37")('species');
module.exports=function(O,D){
var C=anObject(O).constructor;
var S;
return C===undefined||(S=anObject(C)[SPECIES])==undefined?D:aFunction(S);
};


/***/},

/***/"0e44":
/***/function e44(module,exports,__webpack_require__){

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject=__webpack_require__("88dd");
var anObject=__webpack_require__("a013");
var check=function check(O,proto){
anObject(O);
if(!isObject(proto)&&proto!==null)throw TypeError(proto+": can't set as prototype!");
};
module.exports={
set:Object.setPrototypeOf||('__proto__'in{}?// eslint-disable-line
function(test,buggy,set){
try{
set=__webpack_require__("01f5")(Function.call,__webpack_require__("acb9").f(Object.prototype,'__proto__').set,2);
set(test,[]);
buggy=!(test instanceof Array);
}catch(e){buggy=true;}
return function setPrototypeOf(O,proto){
check(O,proto);
if(buggy)O.__proto__=proto;else
set(O,proto);
return O;
};
}({},false):undefined),
check:check};



/***/},

/***/"14fc":
/***/function fc(module,exports){

module.exports={};


/***/},

/***/"15c2":
/***/function c2(module,exports,__webpack_require__){

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject=__webpack_require__("db4b");
var toAbsoluteIndex=__webpack_require__("5fe5");
var toLength=__webpack_require__("b146");
module.exports=function fill(value/* , start = 0, end = @length */){
var O=toObject(this);
var length=toLength(O.length);
var aLen=arguments.length;
var index=toAbsoluteIndex(aLen>1?arguments[1]:undefined,length);
var end=aLen>2?arguments[2]:undefined;
var endPos=end===undefined?length:toAbsoluteIndex(end,length);
while(endPos>index){O[index++]=value;}
return O;
};


/***/},

/***/"1a9b":
/***/function a9b(module,exports,__webpack_require__){

var classof=__webpack_require__("4819");
var ITERATOR=__webpack_require__("8b37")('iterator');
var Iterators=__webpack_require__("14fc");
module.exports=__webpack_require__("a4cc").getIteratorMethod=function(it){
if(it!=undefined)return it[ITERATOR]||
it['@@iterator']||
Iterators[classof(it)];
};


/***/},

/***/"22f3":
/***/function f3(module,exports,__webpack_require__){

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS=__webpack_require__("dad2");
var getKeys=__webpack_require__("cfc7");
var gOPS=__webpack_require__("f7c1");
var pIE=__webpack_require__("d217");
var toObject=__webpack_require__("db4b");
var IObject=__webpack_require__("6462");
var $assign=Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports=!$assign||__webpack_require__("b6f1")(function(){
var A={};
var B={};
// eslint-disable-next-line no-undef
var S=Symbol();
var K='abcdefghijklmnopqrst';
A[S]=7;
K.split('').forEach(function(k){B[k]=k;});
return $assign({},A)[S]!=7||Object.keys($assign({},B)).join('')!=K;
})?function assign(target,source){// eslint-disable-line no-unused-vars
var T=toObject(target);
var aLen=arguments.length;
var index=1;
var getSymbols=gOPS.f;
var isEnum=pIE.f;
while(aLen>index){
var S=IObject(arguments[index++]);
var keys=getSymbols?getKeys(S).concat(getSymbols(S)):getKeys(S);
var length=keys.length;
var j=0;
var key;
while(length>j){
key=keys[j++];
if(!DESCRIPTORS||isEnum.call(S,key))T[key]=S[key];
}
}return T;
}:$assign;


/***/},

/***/"265a":
/***/function a(module,exports,__webpack_require__){

var document=__webpack_require__("3754").document;
module.exports=document&&document.documentElement;


/***/},

/***/"2d43":
/***/function d43(module,exports,__webpack_require__){

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx=__webpack_require__("01f5");
var IObject=__webpack_require__("6462");
var toObject=__webpack_require__("db4b");
var toLength=__webpack_require__("b146");
var asc=__webpack_require__("5824");
module.exports=function(TYPE,$create){
var IS_MAP=TYPE==1;
var IS_FILTER=TYPE==2;
var IS_SOME=TYPE==3;
var IS_EVERY=TYPE==4;
var IS_FIND_INDEX=TYPE==6;
var NO_HOLES=TYPE==5||IS_FIND_INDEX;
var create=$create||asc;
return function($this,callbackfn,that){
var O=toObject($this);
var self=IObject(O);
var f=ctx(callbackfn,that,3);
var length=toLength(self.length);
var index=0;
var result=IS_MAP?create($this,length):IS_FILTER?create($this,0):undefined;
var val,res;
for(;length>index;index++){if(NO_HOLES||index in self){
val=self[index];
res=f(val,index,O);
if(TYPE){
if(IS_MAP)result[index]=res;// map
else if(res)switch(TYPE){
case 3:return true;// some
case 5:return val;// find
case 6:return index;// findIndex
case 2:result.push(val);// filter
}else if(IS_EVERY)return false;// every
}
}}
return IS_FIND_INDEX?-1:IS_SOME||IS_EVERY?IS_EVERY:result;
};
};


/***/},

/***/"3754":
/***/function _(module,exports){

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global=module.exports=typeof window!='undefined'&&window.Math==Math?
window:typeof self!='undefined'&&self.Math==Math?self
// eslint-disable-next-line no-new-func
:Function('return this')();
if(typeof __g=='number')__g=global;// eslint-disable-line no-undef


/***/},

/***/"3a68":
/***/function a68(module,exports,__webpack_require__){

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject=__webpack_require__("6462");
var defined=__webpack_require__("f01a");
module.exports=function(it){
return IObject(defined(it));
};


/***/},

/***/"4169":
/***/function _(module,exports,__webpack_require__){

"use strict";

var global=__webpack_require__("3754");
var DESCRIPTORS=__webpack_require__("dad2");
var LIBRARY=__webpack_require__("ca2b");
var $typed=__webpack_require__("98ce");
var hide=__webpack_require__("743d");
var redefineAll=__webpack_require__("f216");
var fails=__webpack_require__("b6f1");
var anInstance=__webpack_require__("d74e");
var toInteger=__webpack_require__("c481");
var toLength=__webpack_require__("b146");
var toIndex=__webpack_require__("9241");
var gOPN=__webpack_require__("a891").f;
var dP=__webpack_require__("ddf7").f;
var arrayFill=__webpack_require__("15c2");
var setToStringTag=__webpack_require__("6594");
var ARRAY_BUFFER='ArrayBuffer';
var DATA_VIEW='DataView';
var PROTOTYPE='prototype';
var WRONG_LENGTH='Wrong length!';
var WRONG_INDEX='Wrong index!';
var $ArrayBuffer=global[ARRAY_BUFFER];
var $DataView=global[DATA_VIEW];
var Math=global.Math;
var RangeError=global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity=global.Infinity;
var BaseBuffer=$ArrayBuffer;
var abs=Math.abs;
var pow=Math.pow;
var floor=Math.floor;
var log=Math.log;
var LN2=Math.LN2;
var BUFFER='buffer';
var BYTE_LENGTH='byteLength';
var BYTE_OFFSET='byteOffset';
var $BUFFER=DESCRIPTORS?'_b':BUFFER;
var $LENGTH=DESCRIPTORS?'_l':BYTE_LENGTH;
var $OFFSET=DESCRIPTORS?'_o':BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value,mLen,nBytes){
var buffer=new Array(nBytes);
var eLen=nBytes*8-mLen-1;
var eMax=(1<<eLen)-1;
var eBias=eMax>>1;
var rt=mLen===23?pow(2,-24)-pow(2,-77):0;
var i=0;
var s=value<0||value===0&&1/value<0?1:0;
var e,m,c;
value=abs(value);
// eslint-disable-next-line no-self-compare
if(value!=value||value===Infinity){
// eslint-disable-next-line no-self-compare
m=value!=value?1:0;
e=eMax;
}else{
e=floor(log(value)/LN2);
if(value*(c=pow(2,-e))<1){
e--;
c*=2;
}
if(e+eBias>=1){
value+=rt/c;
}else{
value+=rt*pow(2,1-eBias);
}
if(value*c>=2){
e++;
c/=2;
}
if(e+eBias>=eMax){
m=0;
e=eMax;
}else if(e+eBias>=1){
m=(value*c-1)*pow(2,mLen);
e=e+eBias;
}else{
m=value*pow(2,eBias-1)*pow(2,mLen);
e=0;
}
}
for(;mLen>=8;buffer[i++]=m&255,m/=256,mLen-=8){;}
e=e<<mLen|m;
eLen+=mLen;
for(;eLen>0;buffer[i++]=e&255,e/=256,eLen-=8){;}
buffer[--i]|=s*128;
return buffer;
}
function unpackIEEE754(buffer,mLen,nBytes){
var eLen=nBytes*8-mLen-1;
var eMax=(1<<eLen)-1;
var eBias=eMax>>1;
var nBits=eLen-7;
var i=nBytes-1;
var s=buffer[i--];
var e=s&127;
var m;
s>>=7;
for(;nBits>0;e=e*256+buffer[i],i--,nBits-=8){;}
m=e&(1<<-nBits)-1;
e>>=-nBits;
nBits+=mLen;
for(;nBits>0;m=m*256+buffer[i],i--,nBits-=8){;}
if(e===0){
e=1-eBias;
}else if(e===eMax){
return m?NaN:s?-Infinity:Infinity;
}else{
m=m+pow(2,mLen);
e=e-eBias;
}return(s?-1:1)*m*pow(2,e-mLen);
}

function unpackI32(bytes){
return bytes[3]<<24|bytes[2]<<16|bytes[1]<<8|bytes[0];
}
function packI8(it){
return[it&0xff];
}
function packI16(it){
return[it&0xff,it>>8&0xff];
}
function packI32(it){
return[it&0xff,it>>8&0xff,it>>16&0xff,it>>24&0xff];
}
function packF64(it){
return packIEEE754(it,52,8);
}
function packF32(it){
return packIEEE754(it,23,4);
}

function addGetter(C,key,internal){
dP(C[PROTOTYPE],key,{get:function get(){return this[internal];}});
}

function get(view,bytes,index,isLittleEndian){
var numIndex=+index;
var intIndex=toIndex(numIndex);
if(intIndex+bytes>view[$LENGTH])throw RangeError(WRONG_INDEX);
var store=view[$BUFFER]._b;
var start=intIndex+view[$OFFSET];
var pack=store.slice(start,start+bytes);
return isLittleEndian?pack:pack.reverse();
}
function set(view,bytes,index,conversion,value,isLittleEndian){
var numIndex=+index;
var intIndex=toIndex(numIndex);
if(intIndex+bytes>view[$LENGTH])throw RangeError(WRONG_INDEX);
var store=view[$BUFFER]._b;
var start=intIndex+view[$OFFSET];
var pack=conversion(+value);
for(var i=0;i<bytes;i++){store[start+i]=pack[isLittleEndian?i:bytes-i-1];}
}

if(!$typed.ABV){
$ArrayBuffer=function ArrayBuffer(length){
anInstance(this,$ArrayBuffer,ARRAY_BUFFER);
var byteLength=toIndex(length);
this._b=arrayFill.call(new Array(byteLength),0);
this[$LENGTH]=byteLength;
};

$DataView=function DataView(buffer,byteOffset,byteLength){
anInstance(this,$DataView,DATA_VIEW);
anInstance(buffer,$ArrayBuffer,DATA_VIEW);
var bufferLength=buffer[$LENGTH];
var offset=toInteger(byteOffset);
if(offset<0||offset>bufferLength)throw RangeError('Wrong offset!');
byteLength=byteLength===undefined?bufferLength-offset:toLength(byteLength);
if(offset+byteLength>bufferLength)throw RangeError(WRONG_LENGTH);
this[$BUFFER]=buffer;
this[$OFFSET]=offset;
this[$LENGTH]=byteLength;
};

if(DESCRIPTORS){
addGetter($ArrayBuffer,BYTE_LENGTH,'_l');
addGetter($DataView,BUFFER,'_b');
addGetter($DataView,BYTE_LENGTH,'_l');
addGetter($DataView,BYTE_OFFSET,'_o');
}

redefineAll($DataView[PROTOTYPE],{
getInt8:function getInt8(byteOffset){
return get(this,1,byteOffset)[0]<<24>>24;
},
getUint8:function getUint8(byteOffset){
return get(this,1,byteOffset)[0];
},
getInt16:function getInt16(byteOffset/* , littleEndian */){
var bytes=get(this,2,byteOffset,arguments[1]);
return(bytes[1]<<8|bytes[0])<<16>>16;
},
getUint16:function getUint16(byteOffset/* , littleEndian */){
var bytes=get(this,2,byteOffset,arguments[1]);
return bytes[1]<<8|bytes[0];
},
getInt32:function getInt32(byteOffset/* , littleEndian */){
return unpackI32(get(this,4,byteOffset,arguments[1]));
},
getUint32:function getUint32(byteOffset/* , littleEndian */){
return unpackI32(get(this,4,byteOffset,arguments[1]))>>>0;
},
getFloat32:function getFloat32(byteOffset/* , littleEndian */){
return unpackIEEE754(get(this,4,byteOffset,arguments[1]),23,4);
},
getFloat64:function getFloat64(byteOffset/* , littleEndian */){
return unpackIEEE754(get(this,8,byteOffset,arguments[1]),52,8);
},
setInt8:function setInt8(byteOffset,value){
set(this,1,byteOffset,packI8,value);
},
setUint8:function setUint8(byteOffset,value){
set(this,1,byteOffset,packI8,value);
},
setInt16:function setInt16(byteOffset,value/* , littleEndian */){
set(this,2,byteOffset,packI16,value,arguments[2]);
},
setUint16:function setUint16(byteOffset,value/* , littleEndian */){
set(this,2,byteOffset,packI16,value,arguments[2]);
},
setInt32:function setInt32(byteOffset,value/* , littleEndian */){
set(this,4,byteOffset,packI32,value,arguments[2]);
},
setUint32:function setUint32(byteOffset,value/* , littleEndian */){
set(this,4,byteOffset,packI32,value,arguments[2]);
},
setFloat32:function setFloat32(byteOffset,value/* , littleEndian */){
set(this,4,byteOffset,packF32,value,arguments[2]);
},
setFloat64:function setFloat64(byteOffset,value/* , littleEndian */){
set(this,8,byteOffset,packF64,value,arguments[2]);
}});

}else{
if(!fails(function(){
$ArrayBuffer(1);
})||!fails(function(){
new $ArrayBuffer(-1);// eslint-disable-line no-new
})||fails(function(){
new $ArrayBuffer();// eslint-disable-line no-new
new $ArrayBuffer(1.5);// eslint-disable-line no-new
new $ArrayBuffer(NaN);// eslint-disable-line no-new
return $ArrayBuffer.name!=ARRAY_BUFFER;
})){
$ArrayBuffer=function ArrayBuffer(length){
anInstance(this,$ArrayBuffer);
return new BaseBuffer(toIndex(length));
};
var ArrayBufferProto=$ArrayBuffer[PROTOTYPE]=BaseBuffer[PROTOTYPE];
for(var keys=gOPN(BaseBuffer),j=0,key;keys.length>j;){
if(!((key=keys[j++])in $ArrayBuffer))hide($ArrayBuffer,key,BaseBuffer[key]);
}
if(!LIBRARY)ArrayBufferProto.constructor=$ArrayBuffer;
}
// iOS Safari 7.x bug
var view=new $DataView(new $ArrayBuffer(2));
var $setInt8=$DataView[PROTOTYPE].setInt8;
view.setInt8(0,2147483648);
view.setInt8(1,2147483649);
if(view.getInt8(0)||!view.getInt8(1))redefineAll($DataView[PROTOTYPE],{
setInt8:function setInt8(byteOffset,value){
$setInt8.call(this,byteOffset,value<<24>>24);
},
setUint8:function setUint8(byteOffset,value){
$setInt8.call(this,byteOffset,value<<24>>24);
}},
true);
}
setToStringTag($ArrayBuffer,ARRAY_BUFFER);
setToStringTag($DataView,DATA_VIEW);
hide($DataView[PROTOTYPE],$typed.VIEW,true);
exports[ARRAY_BUFFER]=$ArrayBuffer;
exports[DATA_VIEW]=$DataView;


/***/},

/***/"44de":
/***/function de(module,exports,__webpack_require__){

var isObject=__webpack_require__("88dd");
var setPrototypeOf=__webpack_require__("0e44").set;
module.exports=function(that,target,C){
var S=target.constructor;
var P;
if(S!==C&&typeof S=='function'&&(P=S.prototype)!==C.prototype&&isObject(P)&&setPrototypeOf){
setPrototypeOf(that,P);
}return that;
};


/***/},

/***/"4713":
/***/function _(module,exports,__webpack_require__){

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has=__webpack_require__("03b3");
var toObject=__webpack_require__("db4b");
var IE_PROTO=__webpack_require__("dfab")('IE_PROTO');
var ObjectProto=Object.prototype;

module.exports=Object.getPrototypeOf||function(O){
O=toObject(O);
if(has(O,IE_PROTO))return O[IE_PROTO];
if(typeof O.constructor=='function'&&O instanceof O.constructor){
return O.constructor.prototype;
}return O instanceof Object?ObjectProto:null;
};


/***/},

/***/"4819":
/***/function _(module,exports,__webpack_require__){

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof=__webpack_require__("94ac");
var TAG=__webpack_require__("8b37")('toStringTag');
// ES3 wrong here
var ARG=cof(function(){return arguments;}())=='Arguments';

// fallback for IE11 Script Access Denied error
var tryGet=function tryGet(it,key){
try{
return it[key];
}catch(e){/* empty */}
};

module.exports=function(it){
var O,T,B;
return it===undefined?'Undefined':it===null?'Null'
// @@toStringTag case
:typeof(T=tryGet(O=Object(it),TAG))=='string'?T
// builtinTag case
:ARG?cof(O)
// ES3 arguments fallback
:(B=cof(O))=='Object'&&typeof O.callee=='function'?'Arguments':B;
};


/***/},

/***/"5325":
/***/function _(module,exports,__webpack_require__){

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject=__webpack_require__("88dd");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports=function(it,S){
if(!isObject(it))return it;
var fn,val;
if(S&&typeof(fn=it.toString)=='function'&&!isObject(val=fn.call(it)))return val;
if(typeof(fn=it.valueOf)=='function'&&!isObject(val=fn.call(it)))return val;
if(!S&&typeof(fn=it.toString)=='function'&&!isObject(val=fn.call(it)))return val;
throw TypeError("Can't convert object to primitive value");
};


/***/},

/***/"539d":
/***/function d(module,exports,__webpack_require__){

var $export=__webpack_require__("b2f5");
var defined=__webpack_require__("f01a");
var fails=__webpack_require__("b6f1");
var spaces=__webpack_require__("c9ea");
var space='['+spaces+']';
var non="\u200B\x85";
var ltrim=RegExp('^'+space+space+'*');
var rtrim=RegExp(space+space+'*$');

var exporter=function exporter(KEY,exec,ALIAS){
var exp={};
var FORCE=fails(function(){
return!!spaces[KEY]()||non[KEY]()!=non;
});
var fn=exp[KEY]=FORCE?exec(trim):spaces[KEY];
if(ALIAS)exp[ALIAS]=fn;
$export($export.P+$export.F*FORCE,'String',exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim=exporter.trim=function(string,TYPE){
string=String(defined(string));
if(TYPE&1)string=string.replace(ltrim,'');
if(TYPE&2)string=string.replace(rtrim,'');
return string;
};

module.exports=exporter;


/***/},

/***/"54c8":
/***/function c8(module,exports,__webpack_require__){

__webpack_require__("9253")('Float32',4,function(init){
return function Float32Array(data,byteOffset,length){
return init(this,data,byteOffset,length);
};
});


/***/},

/***/"568a":
/***/function a(module,exports,__webpack_require__){

module.exports=!__webpack_require__("dad2")&&!__webpack_require__("b6f1")(function(){
return Object.defineProperty(__webpack_require__("e3e0")('div'),'a',{get:function get(){return 7;}}).a!=7;
});


/***/},

/***/"5824":
/***/function _(module,exports,__webpack_require__){

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor=__webpack_require__("f691");

module.exports=function(original,length){
return new(speciesConstructor(original))(length);
};


/***/},

/***/"5b55":
/***/function b55(module,exports,__webpack_require__){

var ITERATOR=__webpack_require__("8b37")('iterator');
var SAFE_CLOSING=false;

try{
var riter=[7][ITERATOR]();
riter['return']=function(){SAFE_CLOSING=true;};
// eslint-disable-next-line no-throw-literal
Array.from(riter,function(){throw 2;});
}catch(e){/* empty */}

module.exports=function(exec,skipClosing){
if(!skipClosing&&!SAFE_CLOSING)return false;
var safe=false;
try{
var arr=[7];
var iter=arr[ITERATOR]();
iter.next=function(){return{done:safe=true};};
arr[ITERATOR]=function(){return iter;};
exec(arr);
}catch(e){/* empty */}
return safe;
};


/***/},

/***/"5fe5":
/***/function fe5(module,exports,__webpack_require__){

var toInteger=__webpack_require__("c481");
var max=Math.max;
var min=Math.min;
module.exports=function(index,length){
index=toInteger(index);
return index<0?max(index+length,0):min(index,length);
};


/***/},

/***/"644a":
/***/function a(module,exports,__webpack_require__){

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES=__webpack_require__("8b37")('unscopables');
var ArrayProto=Array.prototype;
if(ArrayProto[UNSCOPABLES]==undefined)__webpack_require__("743d")(ArrayProto,UNSCOPABLES,{});
module.exports=function(key){
ArrayProto[UNSCOPABLES][key]=true;
};


/***/},

/***/"6462":
/***/function _(module,exports,__webpack_require__){

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof=__webpack_require__("94ac");
// eslint-disable-next-line no-prototype-builtins
module.exports=Object('z').propertyIsEnumerable(0)?Object:function(it){
return cof(it)=='String'?it.split(''):Object(it);
};


/***/},

/***/"648a":
/***/function a(module,exports){

module.exports=function(it){
if(typeof it!='function')throw TypeError(it+' is not a function!');
return it;
};


/***/},

/***/"6594":
/***/function _(module,exports,__webpack_require__){

var def=__webpack_require__("ddf7").f;
var has=__webpack_require__("03b3");
var TAG=__webpack_require__("8b37")('toStringTag');

module.exports=function(it,tag,stat){
if(it&&!has(it=stat?it:it.prototype,TAG))def(it,TAG,{configurable:true,value:tag});
};


/***/},

/***/"7266":
/***/function _(module,exports,__webpack_require__){

"use strict";

var create=__webpack_require__("a7b8");
var descriptor=__webpack_require__("7dea");
var setToStringTag=__webpack_require__("6594");
var IteratorPrototype={};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__("743d")(IteratorPrototype,__webpack_require__("8b37")('iterator'),function(){return this;});

module.exports=function(Constructor,NAME,next){
Constructor.prototype=create(IteratorPrototype,{next:descriptor(1,next)});
setToStringTag(Constructor,NAME+' Iterator');
};


/***/},

/***/"7364":
/***/function _(module,exports,__webpack_require__){

var dP=__webpack_require__("ddf7").f;
var FProto=Function.prototype;
var nameRE=/^\s*function ([^ (]*)/;
var NAME='name';

// 19.2.4.2 name
NAME in FProto||__webpack_require__("dad2")&&dP(FProto,NAME,{
configurable:true,
get:function get(){
try{
return(''+this).match(nameRE)[1];
}catch(e){
return'';
}
}});



/***/},

/***/"743d":
/***/function d(module,exports,__webpack_require__){

var dP=__webpack_require__("ddf7");
var createDesc=__webpack_require__("7dea");
module.exports=__webpack_require__("dad2")?function(object,key,value){
return dP.f(object,key,createDesc(1,value));
}:function(object,key,value){
object[key]=value;
return object;
};


/***/},

/***/"7656":
/***/function _(module,exports,__webpack_require__){

"use strict";

var LIBRARY=__webpack_require__("ca2b");
var $export=__webpack_require__("b2f5");
var redefine=__webpack_require__("e5ef");
var hide=__webpack_require__("743d");
var Iterators=__webpack_require__("14fc");
var $iterCreate=__webpack_require__("7266");
var setToStringTag=__webpack_require__("6594");
var getPrototypeOf=__webpack_require__("4713");
var ITERATOR=__webpack_require__("8b37")('iterator');
var BUGGY=!([].keys&&'next'in[].keys());// Safari has buggy iterators w/o `next`
var FF_ITERATOR='@@iterator';
var KEYS='keys';
var VALUES='values';

var returnThis=function returnThis(){return this;};

module.exports=function(Base,NAME,Constructor,next,DEFAULT,IS_SET,FORCED){
$iterCreate(Constructor,NAME,next);
var getMethod=function getMethod(kind){
if(!BUGGY&&kind in proto)return proto[kind];
switch(kind){
case KEYS:return function keys(){return new Constructor(this,kind);};
case VALUES:return function values(){return new Constructor(this,kind);};}
return function entries(){return new Constructor(this,kind);};
};
var TAG=NAME+' Iterator';
var DEF_VALUES=DEFAULT==VALUES;
var VALUES_BUG=false;
var proto=Base.prototype;
var $native=proto[ITERATOR]||proto[FF_ITERATOR]||DEFAULT&&proto[DEFAULT];
var $default=$native||getMethod(DEFAULT);
var $entries=DEFAULT?!DEF_VALUES?$default:getMethod('entries'):undefined;
var $anyNative=NAME=='Array'?proto.entries||$native:$native;
var methods,key,IteratorPrototype;
// Fix native
if($anyNative){
IteratorPrototype=getPrototypeOf($anyNative.call(new Base()));
if(IteratorPrototype!==Object.prototype&&IteratorPrototype.next){
// Set @@toStringTag to native iterators
setToStringTag(IteratorPrototype,TAG,true);
// fix for some old engines
if(!LIBRARY&&typeof IteratorPrototype[ITERATOR]!='function')hide(IteratorPrototype,ITERATOR,returnThis);
}
}
// fix Array#{values, @@iterator}.name in V8 / FF
if(DEF_VALUES&&$native&&$native.name!==VALUES){
VALUES_BUG=true;
$default=function values(){return $native.call(this);};
}
// Define iterator
if((!LIBRARY||FORCED)&&(BUGGY||VALUES_BUG||!proto[ITERATOR])){
hide(proto,ITERATOR,$default);
}
// Plug for library
Iterators[NAME]=$default;
Iterators[TAG]=returnThis;
if(DEFAULT){
methods={
values:DEF_VALUES?$default:getMethod(VALUES),
keys:IS_SET?$default:getMethod(KEYS),
entries:$entries};

if(FORCED)for(key in methods){
if(!(key in proto))redefine(proto,key,methods[key]);
}else $export($export.P+$export.F*(BUGGY||VALUES_BUG),NAME,methods);
}
return methods;
};


/***/},

/***/"7d30":
/***/function d30(module,exports,__webpack_require__){

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject=__webpack_require__("db4b");
var toAbsoluteIndex=__webpack_require__("5fe5");
var toLength=__webpack_require__("b146");

module.exports=[].copyWithin||function copyWithin(target/* = 0 */,start/* = 0, end = @length */){
var O=toObject(this);
var len=toLength(O.length);
var to=toAbsoluteIndex(target,len);
var from=toAbsoluteIndex(start,len);
var end=arguments.length>2?arguments[2]:undefined;
var count=Math.min((end===undefined?len:toAbsoluteIndex(end,len))-from,len-to);
var inc=1;
if(from<to&&to<from+count){
inc=-1;
from+=count-1;
to+=count-1;
}
while(count-->0){
if(from in O)O[to]=O[from];else
delete O[to];
to+=inc;
from+=inc;
}return O;
};


/***/},

/***/"7dea":
/***/function dea(module,exports){

module.exports=function(bitmap,value){
return{
enumerable:!(bitmap&1),
configurable:!(bitmap&2),
writable:!(bitmap&4),
value:value};

};


/***/},

/***/"88dd":
/***/function dd(module,exports){

module.exports=function(it){
return typeof it==='object'?it!==null:typeof it==='function';
};


/***/},

/***/"8b37":
/***/function b37(module,exports,__webpack_require__){

var store=__webpack_require__("adbd")('wks');
var uid=__webpack_require__("9d01");
var Symbol=__webpack_require__("3754").Symbol;
var USE_SYMBOL=typeof Symbol=='function';

var $exports=module.exports=function(name){
return store[name]||(store[name]=
USE_SYMBOL&&Symbol[name]||(USE_SYMBOL?Symbol:uid)('Symbol.'+name));
};

$exports.store=store;


/***/},

/***/"8bbf":
/***/function bbf(module,exports){

module.exports=__WEBPACK_EXTERNAL_MODULE__8bbf__;

/***/},

/***/"9241":
/***/function _(module,exports,__webpack_require__){

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger=__webpack_require__("c481");
var toLength=__webpack_require__("b146");
module.exports=function(it){
if(it===undefined)return 0;
var number=toInteger(it);
var length=toLength(number);
if(number!==length)throw RangeError('Wrong length!');
return length;
};


/***/},

/***/"9253":
/***/function _(module,exports,__webpack_require__){

"use strict";

if(__webpack_require__("dad2")){
var LIBRARY=__webpack_require__("ca2b");
var global=__webpack_require__("3754");
var fails=__webpack_require__("b6f1");
var $export=__webpack_require__("b2f5");
var $typed=__webpack_require__("98ce");
var $buffer=__webpack_require__("4169");
var ctx=__webpack_require__("01f5");
var anInstance=__webpack_require__("d74e");
var propertyDesc=__webpack_require__("7dea");
var hide=__webpack_require__("743d");
var redefineAll=__webpack_require__("f216");
var toInteger=__webpack_require__("c481");
var toLength=__webpack_require__("b146");
var toIndex=__webpack_require__("9241");
var toAbsoluteIndex=__webpack_require__("5fe5");
var toPrimitive=__webpack_require__("5325");
var has=__webpack_require__("03b3");
var classof=__webpack_require__("4819");
var isObject=__webpack_require__("88dd");
var toObject=__webpack_require__("db4b");
var isArrayIter=__webpack_require__("c847");
var create=__webpack_require__("a7b8");
var getPrototypeOf=__webpack_require__("4713");
var gOPN=__webpack_require__("a891").f;
var getIterFn=__webpack_require__("1a9b");
var uid=__webpack_require__("9d01");
var wks=__webpack_require__("8b37");
var createArrayMethod=__webpack_require__("2d43");
var createArrayIncludes=__webpack_require__("9f58");
var speciesConstructor=__webpack_require__("0d5f");
var ArrayIterators=__webpack_require__("dac5");
var Iterators=__webpack_require__("14fc");
var $iterDetect=__webpack_require__("5b55");
var setSpecies=__webpack_require__("c650");
var arrayFill=__webpack_require__("15c2");
var arrayCopyWithin=__webpack_require__("7d30");
var $DP=__webpack_require__("ddf7");
var $GOPD=__webpack_require__("acb9");
var dP=$DP.f;
var gOPD=$GOPD.f;
var RangeError=global.RangeError;
var TypeError=global.TypeError;
var Uint8Array=global.Uint8Array;
var ARRAY_BUFFER='ArrayBuffer';
var SHARED_BUFFER='Shared'+ARRAY_BUFFER;
var BYTES_PER_ELEMENT='BYTES_PER_ELEMENT';
var PROTOTYPE='prototype';
var ArrayProto=Array[PROTOTYPE];
var $ArrayBuffer=$buffer.ArrayBuffer;
var $DataView=$buffer.DataView;
var arrayForEach=createArrayMethod(0);
var arrayFilter=createArrayMethod(2);
var arraySome=createArrayMethod(3);
var arrayEvery=createArrayMethod(4);
var arrayFind=createArrayMethod(5);
var arrayFindIndex=createArrayMethod(6);
var arrayIncludes=createArrayIncludes(true);
var arrayIndexOf=createArrayIncludes(false);
var arrayValues=ArrayIterators.values;
var arrayKeys=ArrayIterators.keys;
var arrayEntries=ArrayIterators.entries;
var arrayLastIndexOf=ArrayProto.lastIndexOf;
var arrayReduce=ArrayProto.reduce;
var arrayReduceRight=ArrayProto.reduceRight;
var arrayJoin=ArrayProto.join;
var arraySort=ArrayProto.sort;
var arraySlice=ArrayProto.slice;
var arrayToString=ArrayProto.toString;
var arrayToLocaleString=ArrayProto.toLocaleString;
var ITERATOR=wks('iterator');
var TAG=wks('toStringTag');
var TYPED_CONSTRUCTOR=uid('typed_constructor');
var DEF_CONSTRUCTOR=uid('def_constructor');
var ALL_CONSTRUCTORS=$typed.CONSTR;
var TYPED_ARRAY=$typed.TYPED;
var VIEW=$typed.VIEW;
var WRONG_LENGTH='Wrong length!';

var $map=createArrayMethod(1,function(O,length){
return allocate(speciesConstructor(O,O[DEF_CONSTRUCTOR]),length);
});

var LITTLE_ENDIAN=fails(function(){
// eslint-disable-next-line no-undef
return new Uint8Array(new Uint16Array([1]).buffer)[0]===1;
});

var FORCED_SET=!!Uint8Array&&!!Uint8Array[PROTOTYPE].set&&fails(function(){
new Uint8Array(1).set({});
});

var toOffset=function toOffset(it,BYTES){
var offset=toInteger(it);
if(offset<0||offset%BYTES)throw RangeError('Wrong offset!');
return offset;
};

var validate=function validate(it){
if(isObject(it)&&TYPED_ARRAY in it)return it;
throw TypeError(it+' is not a typed array!');
};

var allocate=function allocate(C,length){
if(!(isObject(C)&&TYPED_CONSTRUCTOR in C)){
throw TypeError('It is not a typed array constructor!');
}return new C(length);
};

var speciesFromList=function speciesFromList(O,list){
return fromList(speciesConstructor(O,O[DEF_CONSTRUCTOR]),list);
};

var fromList=function fromList(C,list){
var index=0;
var length=list.length;
var result=allocate(C,length);
while(length>index){result[index]=list[index++];}
return result;
};

var addGetter=function addGetter(it,key,internal){
dP(it,key,{get:function get(){return this._d[internal];}});
};

var $from=function from(source/* , mapfn, thisArg */){
var O=toObject(source);
var aLen=arguments.length;
var mapfn=aLen>1?arguments[1]:undefined;
var mapping=mapfn!==undefined;
var iterFn=getIterFn(O);
var i,length,values,result,step,iterator;
if(iterFn!=undefined&&!isArrayIter(iterFn)){
for(iterator=iterFn.call(O),values=[],i=0;!(step=iterator.next()).done;i++){
values.push(step.value);
}O=values;
}
if(mapping&&aLen>2)mapfn=ctx(mapfn,arguments[2],2);
for(i=0,length=toLength(O.length),result=allocate(this,length);length>i;i++){
result[i]=mapping?mapfn(O[i],i):O[i];
}
return result;
};

var $of=function of()/* ...items */{
var index=0;
var length=arguments.length;
var result=allocate(this,length);
while(length>index){result[index]=arguments[index++];}
return result;
};

// iOS Safari 6.x fails here
var TO_LOCALE_BUG=!!Uint8Array&&fails(function(){arrayToLocaleString.call(new Uint8Array(1));});

var $toLocaleString=function toLocaleString(){
return arrayToLocaleString.apply(TO_LOCALE_BUG?arraySlice.call(validate(this)):validate(this),arguments);
};

var proto={
copyWithin:function copyWithin(target,start/* , end */){
return arrayCopyWithin.call(validate(this),target,start,arguments.length>2?arguments[2]:undefined);
},
every:function every(callbackfn/* , thisArg */){
return arrayEvery(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);
},
fill:function fill(value/* , start, end */){// eslint-disable-line no-unused-vars
return arrayFill.apply(validate(this),arguments);
},
filter:function filter(callbackfn/* , thisArg */){
return speciesFromList(this,arrayFilter(validate(this),callbackfn,
arguments.length>1?arguments[1]:undefined));
},
find:function find(predicate/* , thisArg */){
return arrayFind(validate(this),predicate,arguments.length>1?arguments[1]:undefined);
},
findIndex:function findIndex(predicate/* , thisArg */){
return arrayFindIndex(validate(this),predicate,arguments.length>1?arguments[1]:undefined);
},
forEach:function forEach(callbackfn/* , thisArg */){
arrayForEach(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);
},
indexOf:function indexOf(searchElement/* , fromIndex */){
return arrayIndexOf(validate(this),searchElement,arguments.length>1?arguments[1]:undefined);
},
includes:function includes(searchElement/* , fromIndex */){
return arrayIncludes(validate(this),searchElement,arguments.length>1?arguments[1]:undefined);
},
join:function join(separator){// eslint-disable-line no-unused-vars
return arrayJoin.apply(validate(this),arguments);
},
lastIndexOf:function lastIndexOf(searchElement/* , fromIndex */){// eslint-disable-line no-unused-vars
return arrayLastIndexOf.apply(validate(this),arguments);
},
map:function map(mapfn/* , thisArg */){
return $map(validate(this),mapfn,arguments.length>1?arguments[1]:undefined);
},
reduce:function reduce(callbackfn/* , initialValue */){// eslint-disable-line no-unused-vars
return arrayReduce.apply(validate(this),arguments);
},
reduceRight:function reduceRight(callbackfn/* , initialValue */){// eslint-disable-line no-unused-vars
return arrayReduceRight.apply(validate(this),arguments);
},
reverse:function reverse(){
var that=this;
var length=validate(that).length;
var middle=Math.floor(length/2);
var index=0;
var value;
while(index<middle){
value=that[index];
that[index++]=that[--length];
that[length]=value;
}return that;
},
some:function some(callbackfn/* , thisArg */){
return arraySome(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);
},
sort:function sort(comparefn){
return arraySort.call(validate(this),comparefn);
},
subarray:function subarray(begin,end){
var O=validate(this);
var length=O.length;
var $begin=toAbsoluteIndex(begin,length);
return new(speciesConstructor(O,O[DEF_CONSTRUCTOR]))(
O.buffer,
O.byteOffset+$begin*O.BYTES_PER_ELEMENT,
toLength((end===undefined?length:toAbsoluteIndex(end,length))-$begin));

}};


var $slice=function slice(start,end){
return speciesFromList(this,arraySlice.call(validate(this),start,end));
};

var $set=function set(arrayLike/* , offset */){
validate(this);
var offset=toOffset(arguments[1],1);
var length=this.length;
var src=toObject(arrayLike);
var len=toLength(src.length);
var index=0;
if(len+offset>length)throw RangeError(WRONG_LENGTH);
while(index<len){this[offset+index]=src[index++];}
};

var $iterators={
entries:function entries(){
return arrayEntries.call(validate(this));
},
keys:function keys(){
return arrayKeys.call(validate(this));
},
values:function values(){
return arrayValues.call(validate(this));
}};


var isTAIndex=function isTAIndex(target,key){
return isObject(target)&&
target[TYPED_ARRAY]&&
typeof key!='symbol'&&
key in target&&
String(+key)==String(key);
};
var $getDesc=function getOwnPropertyDescriptor(target,key){
return isTAIndex(target,key=toPrimitive(key,true))?
propertyDesc(2,target[key]):
gOPD(target,key);
};
var $setDesc=function defineProperty(target,key,desc){
if(isTAIndex(target,key=toPrimitive(key,true))&&
isObject(desc)&&
has(desc,'value')&&
!has(desc,'get')&&
!has(desc,'set')
// TODO: add validation descriptor w/o calling accessors
&&!desc.configurable&&(
!has(desc,'writable')||desc.writable)&&(
!has(desc,'enumerable')||desc.enumerable))
{
target[key]=desc.value;
return target;
}return dP(target,key,desc);
};

if(!ALL_CONSTRUCTORS){
$GOPD.f=$getDesc;
$DP.f=$setDesc;
}

$export($export.S+$export.F*!ALL_CONSTRUCTORS,'Object',{
getOwnPropertyDescriptor:$getDesc,
defineProperty:$setDesc});


if(fails(function(){arrayToString.call({});})){
arrayToString=arrayToLocaleString=function toString(){
return arrayJoin.call(this);
};
}

var $TypedArrayPrototype$=redefineAll({},proto);
redefineAll($TypedArrayPrototype$,$iterators);
hide($TypedArrayPrototype$,ITERATOR,$iterators.values);
redefineAll($TypedArrayPrototype$,{
slice:$slice,
set:$set,
constructor:function constructor(){/* noop */},
toString:arrayToString,
toLocaleString:$toLocaleString});

addGetter($TypedArrayPrototype$,'buffer','b');
addGetter($TypedArrayPrototype$,'byteOffset','o');
addGetter($TypedArrayPrototype$,'byteLength','l');
addGetter($TypedArrayPrototype$,'length','e');
dP($TypedArrayPrototype$,TAG,{
get:function get(){return this[TYPED_ARRAY];}});


// eslint-disable-next-line max-statements
module.exports=function(KEY,BYTES,wrapper,CLAMPED){
CLAMPED=!!CLAMPED;
var NAME=KEY+(CLAMPED?'Clamped':'')+'Array';
var GETTER='get'+KEY;
var SETTER='set'+KEY;
var TypedArray=global[NAME];
var Base=TypedArray||{};
var TAC=TypedArray&&getPrototypeOf(TypedArray);
var FORCED=!TypedArray||!$typed.ABV;
var O={};
var TypedArrayPrototype=TypedArray&&TypedArray[PROTOTYPE];
var getter=function getter(that,index){
var data=that._d;
return data.v[GETTER](index*BYTES+data.o,LITTLE_ENDIAN);
};
var setter=function setter(that,index,value){
var data=that._d;
if(CLAMPED)value=(value=Math.round(value))<0?0:value>0xff?0xff:value&0xff;
data.v[SETTER](index*BYTES+data.o,value,LITTLE_ENDIAN);
};
var addElement=function addElement(that,index){
dP(that,index,{
get:function get(){
return getter(this,index);
},
set:function set(value){
return setter(this,index,value);
},
enumerable:true});

};
if(FORCED){
TypedArray=wrapper(function(that,data,$offset,$length){
anInstance(that,TypedArray,NAME,'_d');
var index=0;
var offset=0;
var buffer,byteLength,length,klass;
if(!isObject(data)){
length=toIndex(data);
byteLength=length*BYTES;
buffer=new $ArrayBuffer(byteLength);
}else if(data instanceof $ArrayBuffer||(klass=classof(data))==ARRAY_BUFFER||klass==SHARED_BUFFER){
buffer=data;
offset=toOffset($offset,BYTES);
var $len=data.byteLength;
if($length===undefined){
if($len%BYTES)throw RangeError(WRONG_LENGTH);
byteLength=$len-offset;
if(byteLength<0)throw RangeError(WRONG_LENGTH);
}else{
byteLength=toLength($length)*BYTES;
if(byteLength+offset>$len)throw RangeError(WRONG_LENGTH);
}
length=byteLength/BYTES;
}else if(TYPED_ARRAY in data){
return fromList(TypedArray,data);
}else{
return $from.call(TypedArray,data);
}
hide(that,'_d',{
b:buffer,
o:offset,
l:byteLength,
e:length,
v:new $DataView(buffer)});

while(index<length){addElement(that,index++);}
});
TypedArrayPrototype=TypedArray[PROTOTYPE]=create($TypedArrayPrototype$);
hide(TypedArrayPrototype,'constructor',TypedArray);
}else if(!fails(function(){
TypedArray(1);
})||!fails(function(){
new TypedArray(-1);// eslint-disable-line no-new
})||!$iterDetect(function(iter){
new TypedArray();// eslint-disable-line no-new
new TypedArray(null);// eslint-disable-line no-new
new TypedArray(1.5);// eslint-disable-line no-new
new TypedArray(iter);// eslint-disable-line no-new
},true)){
TypedArray=wrapper(function(that,data,$offset,$length){
anInstance(that,TypedArray,NAME);
var klass;
// `ws` module bug, temporarily remove validation length for Uint8Array
// https://github.com/websockets/ws/pull/645
if(!isObject(data))return new Base(toIndex(data));
if(data instanceof $ArrayBuffer||(klass=classof(data))==ARRAY_BUFFER||klass==SHARED_BUFFER){
return $length!==undefined?
new Base(data,toOffset($offset,BYTES),$length):
$offset!==undefined?
new Base(data,toOffset($offset,BYTES)):
new Base(data);
}
if(TYPED_ARRAY in data)return fromList(TypedArray,data);
return $from.call(TypedArray,data);
});
arrayForEach(TAC!==Function.prototype?gOPN(Base).concat(gOPN(TAC)):gOPN(Base),function(key){
if(!(key in TypedArray))hide(TypedArray,key,Base[key]);
});
TypedArray[PROTOTYPE]=TypedArrayPrototype;
if(!LIBRARY)TypedArrayPrototype.constructor=TypedArray;
}
var $nativeIterator=TypedArrayPrototype[ITERATOR];
var CORRECT_ITER_NAME=!!$nativeIterator&&(
$nativeIterator.name=='values'||$nativeIterator.name==undefined);
var $iterator=$iterators.values;
hide(TypedArray,TYPED_CONSTRUCTOR,true);
hide(TypedArrayPrototype,TYPED_ARRAY,NAME);
hide(TypedArrayPrototype,VIEW,true);
hide(TypedArrayPrototype,DEF_CONSTRUCTOR,TypedArray);

if(CLAMPED?new TypedArray(1)[TAG]!=NAME:!(TAG in TypedArrayPrototype)){
dP(TypedArrayPrototype,TAG,{
get:function get(){return NAME;}});

}

O[NAME]=TypedArray;

$export($export.G+$export.W+$export.F*(TypedArray!=Base),O);

$export($export.S,NAME,{
BYTES_PER_ELEMENT:BYTES});


$export($export.S+$export.F*fails(function(){Base.of.call(TypedArray,1);}),NAME,{
from:$from,
of:$of});


if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype,BYTES_PER_ELEMENT,BYTES);

$export($export.P,NAME,proto);

setSpecies(NAME);

$export($export.P+$export.F*FORCED_SET,NAME,{set:$set});

$export($export.P+$export.F*!CORRECT_ITER_NAME,NAME,$iterators);

if(!LIBRARY&&TypedArrayPrototype.toString!=arrayToString)TypedArrayPrototype.toString=arrayToString;

$export($export.P+$export.F*fails(function(){
new TypedArray(1).slice();
}),NAME,{slice:$slice});

$export($export.P+$export.F*(fails(function(){
return[1,2].toLocaleString()!=new TypedArray([1,2]).toLocaleString();
})||!fails(function(){
TypedArrayPrototype.toLocaleString.call([1,2]);
})),NAME,{toLocaleString:$toLocaleString});

Iterators[NAME]=CORRECT_ITER_NAME?$nativeIterator:$iterator;
if(!LIBRARY&&!CORRECT_ITER_NAME)hide(TypedArrayPrototype,ITERATOR,$iterator);
};
}else module.exports=function(){/* empty */};


/***/},

/***/"94ac":
/***/function ac(module,exports){

var toString={}.toString;

module.exports=function(it){
return toString.call(it).slice(8,-1);
};


/***/},

/***/"9604":
/***/function _(module,exports,__webpack_require__){

// 19.1.3.1 Object.assign(target, source)
var $export=__webpack_require__("b2f5");

$export($export.S+$export.F,'Object',{assign:__webpack_require__("22f3")});


/***/},

/***/"98ce":
/***/function ce(module,exports,__webpack_require__){

var global=__webpack_require__("3754");
var hide=__webpack_require__("743d");
var uid=__webpack_require__("9d01");
var TYPED=uid('typed_array');
var VIEW=uid('view');
var ABV=!!(global.ArrayBuffer&&global.DataView);
var CONSTR=ABV;
var i=0;
var l=9;
var Typed;

var TypedArrayConstructors=
'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.
split(',');

while(i<l){
if(Typed=global[TypedArrayConstructors[i++]]){
hide(Typed.prototype,TYPED,true);
hide(Typed.prototype,VIEW,true);
}else CONSTR=false;
}

module.exports={
ABV:ABV,
CONSTR:CONSTR,
TYPED:TYPED,
VIEW:VIEW};



/***/},

/***/"9d01":
/***/function d01(module,exports){

var id=0;
var px=Math.random();
module.exports=function(key){
return'Symbol('.concat(key===undefined?'':key,')_',(++id+px).toString(36));
};


/***/},

/***/"9f58":
/***/function f58(module,exports,__webpack_require__){

// false -> Array#indexOf
// true  -> Array#includes
var toIObject=__webpack_require__("3a68");
var toLength=__webpack_require__("b146");
var toAbsoluteIndex=__webpack_require__("5fe5");
module.exports=function(IS_INCLUDES){
return function($this,el,fromIndex){
var O=toIObject($this);
var length=toLength(O.length);
var index=toAbsoluteIndex(fromIndex,length);
var value;
// Array#includes uses SameValueZero equality algorithm
// eslint-disable-next-line no-self-compare
if(IS_INCLUDES&&el!=el)while(length>index){
value=O[index++];
// eslint-disable-next-line no-self-compare
if(value!=value)return true;
// Array#indexOf ignores holes, Array#includes - not
}else for(;length>index;index++){if(IS_INCLUDES||index in O){
if(O[index]===el)return IS_INCLUDES||index||0;
}}return!IS_INCLUDES&&-1;
};
};


/***/},

/***/"a013":
/***/function a013(module,exports,__webpack_require__){

var isObject=__webpack_require__("88dd");
module.exports=function(it){
if(!isObject(it))throw TypeError(it+' is not an object!');
return it;
};


/***/},

/***/"a4cc":
/***/function a4cc(module,exports){

var core=module.exports={version:'2.6.9'};
if(typeof __e=='number')__e=core;// eslint-disable-line no-undef


/***/},

/***/"a7b8":
/***/function a7b8(module,exports,__webpack_require__){

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject=__webpack_require__("a013");
var dPs=__webpack_require__("bf29");
var enumBugKeys=__webpack_require__("b4e0");
var IE_PROTO=__webpack_require__("dfab")('IE_PROTO');
var Empty=function Empty(){/* empty */};
var PROTOTYPE='prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict=function createDict(){
// Thrash, waste and sodomy: IE GC bug
var iframe=__webpack_require__("e3e0")('iframe');
var i=enumBugKeys.length;
var lt='<';
var gt='>';
var iframeDocument;
iframe.style.display='none';
__webpack_require__("265a").appendChild(iframe);
iframe.src='javascript:';// eslint-disable-line no-script-url
// createDict = iframe.contentWindow.Object;
// html.removeChild(iframe);
iframeDocument=iframe.contentWindow.document;
iframeDocument.open();
iframeDocument.write(lt+'script'+gt+'document.F=Object'+lt+'/script'+gt);
iframeDocument.close();
_createDict=iframeDocument.F;
while(i--){delete _createDict[PROTOTYPE][enumBugKeys[i]];}
return _createDict();
};

module.exports=Object.create||function create(O,Properties){
var result;
if(O!==null){
Empty[PROTOTYPE]=anObject(O);
result=new Empty();
Empty[PROTOTYPE]=null;
// add "__proto__" for Object.getPrototypeOf polyfill
result[IE_PROTO]=O;
}else result=_createDict();
return Properties===undefined?result:dPs(result,Properties);
};


/***/},

/***/"a891":
/***/function a891(module,exports,__webpack_require__){

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys=__webpack_require__("fb6d");
var hiddenKeys=__webpack_require__("b4e0").concat('length','prototype');

exports.f=Object.getOwnPropertyNames||function getOwnPropertyNames(O){
return $keys(O,hiddenKeys);
};


/***/},

/***/"acb9":
/***/function acb9(module,exports,__webpack_require__){

var pIE=__webpack_require__("d217");
var createDesc=__webpack_require__("7dea");
var toIObject=__webpack_require__("3a68");
var toPrimitive=__webpack_require__("5325");
var has=__webpack_require__("03b3");
var IE8_DOM_DEFINE=__webpack_require__("568a");
var gOPD=Object.getOwnPropertyDescriptor;

exports.f=__webpack_require__("dad2")?gOPD:function getOwnPropertyDescriptor(O,P){
O=toIObject(O);
P=toPrimitive(P,true);
if(IE8_DOM_DEFINE)try{
return gOPD(O,P);
}catch(e){/* empty */}
if(has(O,P))return createDesc(!pIE.f.call(O,P),O[P]);
};


/***/},

/***/"adbd":
/***/function adbd(module,exports,__webpack_require__){

var core=__webpack_require__("a4cc");
var global=__webpack_require__("3754");
var SHARED='__core-js_shared__';
var store=global[SHARED]||(global[SHARED]={});

(module.exports=function(key,value){
return store[key]||(store[key]=value!==undefined?value:{});
})('versions',[]).push({
version:core.version,
mode:__webpack_require__("ca2b")?'pure':'global',
copyright:'© 2019 Denis Pushkarev (zloirock.ru)'});



/***/},

/***/"b146":
/***/function b146(module,exports,__webpack_require__){

// 7.1.15 ToLength
var toInteger=__webpack_require__("c481");
var min=Math.min;
module.exports=function(it){
return it>0?min(toInteger(it),0x1fffffffffffff):0;// pow(2, 53) - 1 == 9007199254740991
};


/***/},

/***/"b2f5":
/***/function b2f5(module,exports,__webpack_require__){

var global=__webpack_require__("3754");
var core=__webpack_require__("a4cc");
var hide=__webpack_require__("743d");
var redefine=__webpack_require__("e5ef");
var ctx=__webpack_require__("01f5");
var PROTOTYPE='prototype';

var $export=function $export(type,name,source){
var IS_FORCED=type&$export.F;
var IS_GLOBAL=type&$export.G;
var IS_STATIC=type&$export.S;
var IS_PROTO=type&$export.P;
var IS_BIND=type&$export.B;
var target=IS_GLOBAL?global:IS_STATIC?global[name]||(global[name]={}):(global[name]||{})[PROTOTYPE];
var exports=IS_GLOBAL?core:core[name]||(core[name]={});
var expProto=exports[PROTOTYPE]||(exports[PROTOTYPE]={});
var key,own,out,exp;
if(IS_GLOBAL)source=name;
for(key in source){
// contains in native
own=!IS_FORCED&&target&&target[key]!==undefined;
// export native or passed
out=(own?target:source)[key];
// bind timers to global for call from export context
exp=IS_BIND&&own?ctx(out,global):IS_PROTO&&typeof out=='function'?ctx(Function.call,out):out;
// extend global
if(target)redefine(target,key,out,type&$export.U);
// export
if(exports[key]!=out)hide(exports,key,exp);
if(IS_PROTO&&expProto[key]!=out)expProto[key]=out;
}
};
global.core=core;
// type bitmap
$export.F=1;// forced
$export.G=2;// global
$export.S=4;// static
$export.P=8;// proto
$export.B=16;// bind
$export.W=32;// wrap
$export.U=64;// safe
$export.R=128;// real proto method for `library`
module.exports=$export;


/***/},

/***/"b4e0":
/***/function b4e0(module,exports){

// IE 8- don't enum bug keys
module.exports=
'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.
split(',');


/***/},

/***/"b5b8":
/***/function b5b8(module,exports,__webpack_require__){

// 7.2.2 IsArray(argument)
var cof=__webpack_require__("94ac");
module.exports=Array.isArray||function isArray(arg){
return cof(arg)=='Array';
};


/***/},

/***/"b6f1":
/***/function b6f1(module,exports){

module.exports=function(exec){
try{
return!!exec();
}catch(e){
return true;
}
};


/***/},

/***/"bf29":
/***/function bf29(module,exports,__webpack_require__){

var dP=__webpack_require__("ddf7");
var anObject=__webpack_require__("a013");
var getKeys=__webpack_require__("cfc7");

module.exports=__webpack_require__("dad2")?Object.defineProperties:function defineProperties(O,Properties){
anObject(O);
var keys=getKeys(Properties);
var length=keys.length;
var i=0;
var P;
while(length>i){dP.f(O,P=keys[i++],Properties[P]);}
return O;
};


/***/},

/***/"c481":
/***/function c481(module,exports){

// 7.1.4 ToInteger
var ceil=Math.ceil;
var floor=Math.floor;
module.exports=function(it){
return isNaN(it=+it)?0:(it>0?floor:ceil)(it);
};


/***/},

/***/"c497":
/***/function c497(module,__webpack_exports__,__webpack_require__){

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/_@vue_cli-service@3.8.4@@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if(typeof window!=='undefined'){
if(true){
__webpack_require__("e67d");
}

var setPublicPath_i;
if((setPublicPath_i=window.document.currentScript)&&(setPublicPath_i=setPublicPath_i.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))){
__webpack_require__.p=setPublicPath_i[1];// eslint-disable-line
}
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */var setPublicPath=null;

// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/es6.function.name.js
var es6_function_name=__webpack_require__("7364");

// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/web.dom.iterable.js
var web_dom_iterable=__webpack_require__("f763");

// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_=__webpack_require__("8bbf");
var external_commonjs_vue_commonjs2_vue_root_Vue_default=/*#__PURE__*/__webpack_require__.n(external_commonjs_vue_commonjs2_vue_root_Vue_);

// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/build/three.module.js
// Polyfills

if(Number.EPSILON===undefined){

Number.EPSILON=Math.pow(2,-52);

}

if(Number.isInteger===undefined){

// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

Number.isInteger=function(value){

return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;

};

}

//

if(Math.sign===undefined){

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

Math.sign=function(x){

return x<0?-1:x>0?1:+x;

};

}

if('name'in Function.prototype===false){

// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

Object.defineProperty(Function.prototype,'name',{

get:function get(){

return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];

}});



}

if(Object.assign===undefined){

// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

(function(){

Object.assign=function(target){

if(target===undefined||target===null){

throw new TypeError('Cannot convert undefined or null to object');

}

var output=Object(target);

for(var index=1;index<arguments.length;index++){

var source=arguments[index];

if(source!==undefined&&source!==null){

for(var nextKey in source){

if(Object.prototype.hasOwnProperty.call(source,nextKey)){

output[nextKey]=source[nextKey];

}

}

}

}

return output;

};

})();

}

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher(){}

Object.assign(EventDispatcher.prototype,{

addEventListener:function addEventListener(type,listener){

if(this._listeners===undefined)this._listeners={};

var listeners=this._listeners;

if(listeners[type]===undefined){

listeners[type]=[];

}

if(listeners[type].indexOf(listener)===-1){

listeners[type].push(listener);

}

},

hasEventListener:function hasEventListener(type,listener){

if(this._listeners===undefined)return false;

var listeners=this._listeners;

return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;

},

removeEventListener:function removeEventListener(type,listener){

if(this._listeners===undefined)return;

var listeners=this._listeners;
var listenerArray=listeners[type];

if(listenerArray!==undefined){

var index=listenerArray.indexOf(listener);

if(index!==-1){

listenerArray.splice(index,1);

}

}

},

dispatchEvent:function dispatchEvent(event){

if(this._listeners===undefined)return;

var listeners=this._listeners;
var listenerArray=listeners[event.type];

if(listenerArray!==undefined){

event.target=this;

var array=listenerArray.slice(0);

for(var i=0,l=array.length;i<l;i++){

array[i].call(this,event);

}

}

}});



var REVISION='105';
var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};
var CullFaceNone=0;
var CullFaceBack=1;
var CullFaceFront=2;
var CullFaceFrontBack=3;
var FrontFaceDirectionCW=0;
var FrontFaceDirectionCCW=1;
var BasicShadowMap=0;
var PCFShadowMap=1;
var PCFSoftShadowMap=2;
var FrontSide=0;
var BackSide=1;
var DoubleSide=2;
var FlatShading=1;
var SmoothShading=2;
var NoColors=0;
var FaceColors=1;
var VertexColors=2;
var NoBlending=0;
var NormalBlending=1;
var AdditiveBlending=2;
var SubtractiveBlending=3;
var MultiplyBlending=4;
var CustomBlending=5;
var AddEquation=100;
var SubtractEquation=101;
var ReverseSubtractEquation=102;
var MinEquation=103;
var MaxEquation=104;
var ZeroFactor=200;
var OneFactor=201;
var SrcColorFactor=202;
var OneMinusSrcColorFactor=203;
var SrcAlphaFactor=204;
var OneMinusSrcAlphaFactor=205;
var DstAlphaFactor=206;
var OneMinusDstAlphaFactor=207;
var DstColorFactor=208;
var OneMinusDstColorFactor=209;
var SrcAlphaSaturateFactor=210;
var NeverDepth=0;
var AlwaysDepth=1;
var LessDepth=2;
var LessEqualDepth=3;
var EqualDepth=4;
var GreaterEqualDepth=5;
var GreaterDepth=6;
var NotEqualDepth=7;
var MultiplyOperation=0;
var MixOperation=1;
var AddOperation=2;
var NoToneMapping=0;
var LinearToneMapping=1;
var ReinhardToneMapping=2;
var Uncharted2ToneMapping=3;
var CineonToneMapping=4;
var ACESFilmicToneMapping=5;

var UVMapping=300;
var CubeReflectionMapping=301;
var CubeRefractionMapping=302;
var EquirectangularReflectionMapping=303;
var EquirectangularRefractionMapping=304;
var SphericalReflectionMapping=305;
var CubeUVReflectionMapping=306;
var CubeUVRefractionMapping=307;
var RepeatWrapping=1000;
var ClampToEdgeWrapping=1001;
var MirroredRepeatWrapping=1002;
var NearestFilter=1003;
var NearestMipMapNearestFilter=1004;
var NearestMipMapLinearFilter=1005;
var LinearFilter=1006;
var LinearMipMapNearestFilter=1007;
var LinearMipMapLinearFilter=1008;
var UnsignedByteType=1009;
var ByteType=1010;
var ShortType=1011;
var UnsignedShortType=1012;
var IntType=1013;
var UnsignedIntType=1014;
var FloatType=1015;
var HalfFloatType=1016;
var UnsignedShort4444Type=1017;
var UnsignedShort5551Type=1018;
var UnsignedShort565Type=1019;
var UnsignedInt248Type=1020;
var AlphaFormat=1021;
var RGBFormat=1022;
var RGBAFormat=1023;
var LuminanceFormat=1024;
var LuminanceAlphaFormat=1025;
var RGBEFormat=RGBAFormat;
var DepthFormat=1026;
var DepthStencilFormat=1027;
var RedFormat=1028;
var RGB_S3TC_DXT1_Format=33776;
var RGBA_S3TC_DXT1_Format=33777;
var RGBA_S3TC_DXT3_Format=33778;
var RGBA_S3TC_DXT5_Format=33779;
var RGB_PVRTC_4BPPV1_Format=35840;
var RGB_PVRTC_2BPPV1_Format=35841;
var RGBA_PVRTC_4BPPV1_Format=35842;
var RGBA_PVRTC_2BPPV1_Format=35843;
var RGB_ETC1_Format=36196;
var RGBA_ASTC_4x4_Format=37808;
var RGBA_ASTC_5x4_Format=37809;
var RGBA_ASTC_5x5_Format=37810;
var RGBA_ASTC_6x5_Format=37811;
var RGBA_ASTC_6x6_Format=37812;
var RGBA_ASTC_8x5_Format=37813;
var RGBA_ASTC_8x6_Format=37814;
var RGBA_ASTC_8x8_Format=37815;
var RGBA_ASTC_10x5_Format=37816;
var RGBA_ASTC_10x6_Format=37817;
var RGBA_ASTC_10x8_Format=37818;
var RGBA_ASTC_10x10_Format=37819;
var RGBA_ASTC_12x10_Format=37820;
var RGBA_ASTC_12x12_Format=37821;
var LoopOnce=2200;
var LoopRepeat=2201;
var LoopPingPong=2202;
var InterpolateDiscrete=2300;
var InterpolateLinear=2301;
var InterpolateSmooth=2302;
var ZeroCurvatureEnding=2400;
var ZeroSlopeEnding=2401;
var WrapAroundEnding=2402;
var TrianglesDrawMode=0;
var TriangleStripDrawMode=1;
var TriangleFanDrawMode=2;
var LinearEncoding=3000;
var sRGBEncoding=3001;
var GammaEncoding=3007;
var RGBEEncoding=3002;
var LogLuvEncoding=3003;
var RGBM7Encoding=3004;
var RGBM16Encoding=3005;
var RGBDEncoding=3006;
var BasicDepthPacking=3200;
var RGBADepthPacking=3201;
var TangentSpaceNormalMap=0;
var ObjectSpaceNormalMap=1;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math={

DEG2RAD:Math.PI/180,
RAD2DEG:180/Math.PI,

generateUUID:function(){

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

var lut=[];

for(var i=0;i<256;i++){

lut[i]=(i<16?'0':'')+i.toString(16);

}

return function generateUUID(){

var d0=Math.random()*0xffffffff|0;
var d1=Math.random()*0xffffffff|0;
var d2=Math.random()*0xffffffff|0;
var d3=Math.random()*0xffffffff|0;
var uuid=lut[d0&0xff]+lut[d0>>8&0xff]+lut[d0>>16&0xff]+lut[d0>>24&0xff]+'-'+
lut[d1&0xff]+lut[d1>>8&0xff]+'-'+lut[d1>>16&0x0f|0x40]+lut[d1>>24&0xff]+'-'+
lut[d2&0x3f|0x80]+lut[d2>>8&0xff]+'-'+lut[d2>>16&0xff]+lut[d2>>24&0xff]+
lut[d3&0xff]+lut[d3>>8&0xff]+lut[d3>>16&0xff]+lut[d3>>24&0xff];

// .toUpperCase() here flattens concatenated strings to save heap memory space.
return uuid.toUpperCase();

};

}(),

clamp:function clamp(value,min,max){

return Math.max(min,Math.min(max,value));

},

// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation

euclideanModulo:function euclideanModulo(n,m){

return(n%m+m)%m;

},

// Linear mapping from range <a1, a2> to range <b1, b2>

mapLinear:function mapLinear(x,a1,a2,b1,b2){

return b1+(x-a1)*(b2-b1)/(a2-a1);

},

// https://en.wikipedia.org/wiki/Linear_interpolation

lerp:function lerp(x,y,t){

return(1-t)*x+t*y;

},

// http://en.wikipedia.org/wiki/Smoothstep

smoothstep:function smoothstep(x,min,max){

if(x<=min)return 0;
if(x>=max)return 1;

x=(x-min)/(max-min);

return x*x*(3-2*x);

},

smootherstep:function smootherstep(x,min,max){

if(x<=min)return 0;
if(x>=max)return 1;

x=(x-min)/(max-min);

return x*x*x*(x*(x*6-15)+10);

},

// Random integer from <low, high> interval

randInt:function randInt(low,high){

return low+Math.floor(Math.random()*(high-low+1));

},

// Random float from <low, high> interval

randFloat:function randFloat(low,high){

return low+Math.random()*(high-low);

},

// Random float from <-range/2, range/2> interval

randFloatSpread:function randFloatSpread(range){

return range*(0.5-Math.random());

},

degToRad:function degToRad(degrees){

return degrees*_Math.DEG2RAD;

},

radToDeg:function radToDeg(radians){

return radians*_Math.RAD2DEG;

},

isPowerOfTwo:function isPowerOfTwo(value){

return(value&value-1)===0&&value!==0;

},

ceilPowerOfTwo:function ceilPowerOfTwo(value){

return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));

},

floorPowerOfTwo:function floorPowerOfTwo(value){

return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));

}};



/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2(x,y){

this.x=x||0;
this.y=y||0;

}

Object.defineProperties(Vector2.prototype,{

"width":{

get:function get(){

return this.x;

},

set:function set(value){

this.x=value;

}},



"height":{

get:function get(){

return this.y;

},

set:function set(value){

this.y=value;

}}});





Object.assign(Vector2.prototype,{

isVector2:true,

set:function set(x,y){

this.x=x;
this.y=y;

return this;

},

setScalar:function setScalar(scalar){

this.x=scalar;
this.y=scalar;

return this;

},

setX:function setX(x){

this.x=x;

return this;

},

setY:function setY(y){

this.y=y;

return this;

},

setComponent:function setComponent(index,value){

switch(index){

case 0:this.x=value;break;
case 1:this.y=value;break;
default:throw new Error('index is out of range: '+index);}



return this;

},

getComponent:function getComponent(index){

switch(index){

case 0:return this.x;
case 1:return this.y;
default:throw new Error('index is out of range: '+index);}



},

clone:function clone(){

return new this.constructor(this.x,this.y);

},

copy:function copy(v){

this.x=v.x;
this.y=v.y;

return this;

},

add:function add(v,w){

if(w!==undefined){

console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
return this.addVectors(v,w);

}

this.x+=v.x;
this.y+=v.y;

return this;

},

addScalar:function addScalar(s){

this.x+=s;
this.y+=s;

return this;

},

addVectors:function addVectors(a,b){

this.x=a.x+b.x;
this.y=a.y+b.y;

return this;

},

addScaledVector:function addScaledVector(v,s){

this.x+=v.x*s;
this.y+=v.y*s;

return this;

},

sub:function sub(v,w){

if(w!==undefined){

console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
return this.subVectors(v,w);

}

this.x-=v.x;
this.y-=v.y;

return this;

},

subScalar:function subScalar(s){

this.x-=s;
this.y-=s;

return this;

},

subVectors:function subVectors(a,b){

this.x=a.x-b.x;
this.y=a.y-b.y;

return this;

},

multiply:function multiply(v){

this.x*=v.x;
this.y*=v.y;

return this;

},

multiplyScalar:function multiplyScalar(scalar){

this.x*=scalar;
this.y*=scalar;

return this;

},

divide:function divide(v){

this.x/=v.x;
this.y/=v.y;

return this;

},

divideScalar:function divideScalar(scalar){

return this.multiplyScalar(1/scalar);

},

applyMatrix3:function applyMatrix3(m){

var x=this.x,y=this.y;
var e=m.elements;

this.x=e[0]*x+e[3]*y+e[6];
this.y=e[1]*x+e[4]*y+e[7];

return this;

},

min:function min(v){

this.x=Math.min(this.x,v.x);
this.y=Math.min(this.y,v.y);

return this;

},

max:function max(v){

this.x=Math.max(this.x,v.x);
this.y=Math.max(this.y,v.y);

return this;

},

clamp:function clamp(min,max){

// assumes min < max, componentwise

this.x=Math.max(min.x,Math.min(max.x,this.x));
this.y=Math.max(min.y,Math.min(max.y,this.y));

return this;

},

clampScalar:function clampScalar(minVal,maxVal){

this.x=Math.max(minVal,Math.min(maxVal,this.x));
this.y=Math.max(minVal,Math.min(maxVal,this.y));

return this;

},

clampLength:function clampLength(min,max){

var length=this.length();

return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));

},

floor:function floor(){

this.x=Math.floor(this.x);
this.y=Math.floor(this.y);

return this;

},

ceil:function ceil(){

this.x=Math.ceil(this.x);
this.y=Math.ceil(this.y);

return this;

},

round:function round(){

this.x=Math.round(this.x);
this.y=Math.round(this.y);

return this;

},

roundToZero:function roundToZero(){

this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);
this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);

return this;

},

negate:function negate(){

this.x=-this.x;
this.y=-this.y;

return this;

},

dot:function dot(v){

return this.x*v.x+this.y*v.y;

},

cross:function cross(v){

return this.x*v.y-this.y*v.x;

},

lengthSq:function lengthSq(){

return this.x*this.x+this.y*this.y;

},

length:function length(){

return Math.sqrt(this.x*this.x+this.y*this.y);

},

manhattanLength:function manhattanLength(){

return Math.abs(this.x)+Math.abs(this.y);

},

normalize:function normalize(){

return this.divideScalar(this.length()||1);

},

angle:function angle(){

// computes the angle in radians with respect to the positive x-axis

var angle=Math.atan2(this.y,this.x);

if(angle<0)angle+=2*Math.PI;

return angle;

},

distanceTo:function distanceTo(v){

return Math.sqrt(this.distanceToSquared(v));

},

distanceToSquared:function distanceToSquared(v){

var dx=this.x-v.x,dy=this.y-v.y;
return dx*dx+dy*dy;

},

manhattanDistanceTo:function manhattanDistanceTo(v){

return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);

},

setLength:function setLength(length){

return this.normalize().multiplyScalar(length);

},

lerp:function lerp(v,alpha){

this.x+=(v.x-this.x)*alpha;
this.y+=(v.y-this.y)*alpha;

return this;

},

lerpVectors:function lerpVectors(v1,v2,alpha){

return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);

},

equals:function equals(v){

return v.x===this.x&&v.y===this.y;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

this.x=array[offset];
this.y=array[offset+1];

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this.x;
array[offset+1]=this.y;

return array;

},

fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){

if(offset!==undefined){

console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');

}

this.x=attribute.getX(index);
this.y=attribute.getY(index);

return this;

},

rotateAround:function rotateAround(center,angle){

var c=Math.cos(angle),s=Math.sin(angle);

var x=this.x-center.x;
var y=this.y-center.y;

this.x=x*c-y*s+center.x;
this.y=x*s+y*c+center.y;

return this;

}});



/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x,y,z,w){

this._x=x||0;
this._y=y||0;
this._z=z||0;
this._w=w!==undefined?w:1;

}

Object.assign(Quaternion,{

slerp:function slerp(qa,qb,qm,t){

return qm.copy(qa).slerp(qb,t);

},

slerpFlat:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){

// fuzz-free, array-based Quaternion SLERP operation

var x0=src0[srcOffset0+0],
y0=src0[srcOffset0+1],
z0=src0[srcOffset0+2],
w0=src0[srcOffset0+3],

x1=src1[srcOffset1+0],
y1=src1[srcOffset1+1],
z1=src1[srcOffset1+2],
w1=src1[srcOffset1+3];

if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){

var s=1-t,

cos=x0*x1+y0*y1+z0*z1+w0*w1,

dir=cos>=0?1:-1,
sqrSin=1-cos*cos;

// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>Number.EPSILON){

var sin=Math.sqrt(sqrSin),
len=Math.atan2(sin,cos*dir);

s=Math.sin(s*len)/sin;
t=Math.sin(t*len)/sin;

}

var tDir=t*dir;

x0=x0*s+x1*tDir;
y0=y0*s+y1*tDir;
z0=z0*s+z1*tDir;
w0=w0*s+w1*tDir;

// Normalize in case we just did a lerp:
if(s===1-t){

var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);

x0*=f;
y0*=f;
z0*=f;
w0*=f;

}

}

dst[dstOffset]=x0;
dst[dstOffset+1]=y0;
dst[dstOffset+2]=z0;
dst[dstOffset+3]=w0;

}});



Object.defineProperties(Quaternion.prototype,{

x:{

get:function get(){

return this._x;

},

set:function set(value){

this._x=value;
this.onChangeCallback();

}},



y:{

get:function get(){

return this._y;

},

set:function set(value){

this._y=value;
this.onChangeCallback();

}},



z:{

get:function get(){

return this._z;

},

set:function set(value){

this._z=value;
this.onChangeCallback();

}},



w:{

get:function get(){

return this._w;

},

set:function set(value){

this._w=value;
this.onChangeCallback();

}}});





Object.assign(Quaternion.prototype,{

isQuaternion:true,

set:function set(x,y,z,w){

this._x=x;
this._y=y;
this._z=z;
this._w=w;

this.onChangeCallback();

return this;

},

clone:function clone(){

return new this.constructor(this._x,this._y,this._z,this._w);

},

copy:function copy(quaternion){

this._x=quaternion.x;
this._y=quaternion.y;
this._z=quaternion.z;
this._w=quaternion.w;

this.onChangeCallback();

return this;

},

setFromEuler:function setFromEuler(euler,update){

if(!(euler&&euler.isEuler)){

throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');

}

var x=euler._x,y=euler._y,z=euler._z,order=euler.order;

// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m

var cos=Math.cos;
var sin=Math.sin;

var c1=cos(x/2);
var c2=cos(y/2);
var c3=cos(z/2);

var s1=sin(x/2);
var s2=sin(y/2);
var s3=sin(z/2);

if(order==='XYZ'){

this._x=s1*c2*c3+c1*s2*s3;
this._y=c1*s2*c3-s1*c2*s3;
this._z=c1*c2*s3+s1*s2*c3;
this._w=c1*c2*c3-s1*s2*s3;

}else if(order==='YXZ'){

this._x=s1*c2*c3+c1*s2*s3;
this._y=c1*s2*c3-s1*c2*s3;
this._z=c1*c2*s3-s1*s2*c3;
this._w=c1*c2*c3+s1*s2*s3;

}else if(order==='ZXY'){

this._x=s1*c2*c3-c1*s2*s3;
this._y=c1*s2*c3+s1*c2*s3;
this._z=c1*c2*s3+s1*s2*c3;
this._w=c1*c2*c3-s1*s2*s3;

}else if(order==='ZYX'){

this._x=s1*c2*c3-c1*s2*s3;
this._y=c1*s2*c3+s1*c2*s3;
this._z=c1*c2*s3-s1*s2*c3;
this._w=c1*c2*c3+s1*s2*s3;

}else if(order==='YZX'){

this._x=s1*c2*c3+c1*s2*s3;
this._y=c1*s2*c3+s1*c2*s3;
this._z=c1*c2*s3-s1*s2*c3;
this._w=c1*c2*c3-s1*s2*s3;

}else if(order==='XZY'){

this._x=s1*c2*c3-c1*s2*s3;
this._y=c1*s2*c3-s1*c2*s3;
this._z=c1*c2*s3+s1*s2*c3;
this._w=c1*c2*c3+s1*s2*s3;

}

if(update!==false)this.onChangeCallback();

return this;

},

setFromAxisAngle:function setFromAxisAngle(axis,angle){

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

// assumes axis is normalized

var halfAngle=angle/2,s=Math.sin(halfAngle);

this._x=axis.x*s;
this._y=axis.y*s;
this._z=axis.z*s;
this._w=Math.cos(halfAngle);

this.onChangeCallback();

return this;

},

setFromRotationMatrix:function setFromRotationMatrix(m){

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

var te=m.elements,

m11=te[0],m12=te[4],m13=te[8],
m21=te[1],m22=te[5],m23=te[9],
m31=te[2],m32=te[6],m33=te[10],

trace=m11+m22+m33,
s;

if(trace>0){

s=0.5/Math.sqrt(trace+1.0);

this._w=0.25/s;
this._x=(m32-m23)*s;
this._y=(m13-m31)*s;
this._z=(m21-m12)*s;

}else if(m11>m22&&m11>m33){

s=2.0*Math.sqrt(1.0+m11-m22-m33);

this._w=(m32-m23)/s;
this._x=0.25*s;
this._y=(m12+m21)/s;
this._z=(m13+m31)/s;

}else if(m22>m33){

s=2.0*Math.sqrt(1.0+m22-m11-m33);

this._w=(m13-m31)/s;
this._x=(m12+m21)/s;
this._y=0.25*s;
this._z=(m23+m32)/s;

}else{

s=2.0*Math.sqrt(1.0+m33-m11-m22);

this._w=(m21-m12)/s;
this._x=(m13+m31)/s;
this._y=(m23+m32)/s;
this._z=0.25*s;

}

this.onChangeCallback();

return this;

},

setFromUnitVectors:function setFromUnitVectors(vFrom,vTo){

// assumes direction vectors vFrom and vTo are normalized

var EPS=0.000001;

var r=vFrom.dot(vTo)+1;

if(r<EPS){

r=0;

if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){

this._x=-vFrom.y;
this._y=vFrom.x;
this._z=0;
this._w=r;

}else{

this._x=0;
this._y=-vFrom.z;
this._z=vFrom.y;
this._w=r;

}

}else{

// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;
this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;
this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;
this._w=r;

}

return this.normalize();

},

angleTo:function angleTo(q){

return 2*Math.acos(Math.abs(_Math.clamp(this.dot(q),-1,1)));

},

rotateTowards:function rotateTowards(q,step){

var angle=this.angleTo(q);

if(angle===0)return this;

var t=Math.min(1,step/angle);

this.slerp(q,t);

return this;

},

inverse:function inverse(){

// quaternion is assumed to have unit length

return this.conjugate();

},

conjugate:function conjugate(){

this._x*=-1;
this._y*=-1;
this._z*=-1;

this.onChangeCallback();

return this;

},

dot:function dot(v){

return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;

},

lengthSq:function lengthSq(){

return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;

},

length:function length(){

return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);

},

normalize:function normalize(){

var l=this.length();

if(l===0){

this._x=0;
this._y=0;
this._z=0;
this._w=1;

}else{

l=1/l;

this._x=this._x*l;
this._y=this._y*l;
this._z=this._z*l;
this._w=this._w*l;

}

this.onChangeCallback();

return this;

},

multiply:function multiply(q,p){

if(p!==undefined){

console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
return this.multiplyQuaternions(q,p);

}

return this.multiplyQuaternions(this,q);

},

premultiply:function premultiply(q){

return this.multiplyQuaternions(q,this);

},

multiplyQuaternions:function multiplyQuaternions(a,b){

// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;
var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;

this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;
this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;
this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;
this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;

this.onChangeCallback();

return this;

},

slerp:function slerp(qb,t){

if(t===0)return this;
if(t===1)return this.copy(qb);

var x=this._x,y=this._y,z=this._z,w=this._w;

// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;

if(cosHalfTheta<0){

this._w=-qb._w;
this._x=-qb._x;
this._y=-qb._y;
this._z=-qb._z;

cosHalfTheta=-cosHalfTheta;

}else{

this.copy(qb);

}

if(cosHalfTheta>=1.0){

this._w=w;
this._x=x;
this._y=y;
this._z=z;

return this;

}

var sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;

if(sqrSinHalfTheta<=Number.EPSILON){

var s=1-t;
this._w=s*w+t*this._w;
this._x=s*x+t*this._x;
this._y=s*y+t*this._y;
this._z=s*z+t*this._z;

return this.normalize();

}

var sinHalfTheta=Math.sqrt(sqrSinHalfTheta);
var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);
var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,
ratioB=Math.sin(t*halfTheta)/sinHalfTheta;

this._w=w*ratioA+this._w*ratioB;
this._x=x*ratioA+this._x*ratioB;
this._y=y*ratioA+this._y*ratioB;
this._z=z*ratioA+this._z*ratioB;

this.onChangeCallback();

return this;

},

equals:function equals(quaternion){

return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

this._x=array[offset];
this._y=array[offset+1];
this._z=array[offset+2];
this._w=array[offset+3];

this.onChangeCallback();

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this._x;
array[offset+1]=this._y;
array[offset+2]=this._z;
array[offset+3]=this._w;

return array;

},

onChange:function onChange(callback){

this.onChangeCallback=callback;

return this;

},

onChangeCallback:function onChangeCallback(){}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3(x,y,z){

this.x=x||0;
this.y=y||0;
this.z=z||0;

}

Object.assign(Vector3.prototype,{

isVector3:true,

set:function set(x,y,z){

this.x=x;
this.y=y;
this.z=z;

return this;

},

setScalar:function setScalar(scalar){

this.x=scalar;
this.y=scalar;
this.z=scalar;

return this;

},

setX:function setX(x){

this.x=x;

return this;

},

setY:function setY(y){

this.y=y;

return this;

},

setZ:function setZ(z){

this.z=z;

return this;

},

setComponent:function setComponent(index,value){

switch(index){

case 0:this.x=value;break;
case 1:this.y=value;break;
case 2:this.z=value;break;
default:throw new Error('index is out of range: '+index);}



return this;

},

getComponent:function getComponent(index){

switch(index){

case 0:return this.x;
case 1:return this.y;
case 2:return this.z;
default:throw new Error('index is out of range: '+index);}



},

clone:function clone(){

return new this.constructor(this.x,this.y,this.z);

},

copy:function copy(v){

this.x=v.x;
this.y=v.y;
this.z=v.z;

return this;

},

add:function add(v,w){

if(w!==undefined){

console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
return this.addVectors(v,w);

}

this.x+=v.x;
this.y+=v.y;
this.z+=v.z;

return this;

},

addScalar:function addScalar(s){

this.x+=s;
this.y+=s;
this.z+=s;

return this;

},

addVectors:function addVectors(a,b){

this.x=a.x+b.x;
this.y=a.y+b.y;
this.z=a.z+b.z;

return this;

},

addScaledVector:function addScaledVector(v,s){

this.x+=v.x*s;
this.y+=v.y*s;
this.z+=v.z*s;

return this;

},

sub:function sub(v,w){

if(w!==undefined){

console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
return this.subVectors(v,w);

}

this.x-=v.x;
this.y-=v.y;
this.z-=v.z;

return this;

},

subScalar:function subScalar(s){

this.x-=s;
this.y-=s;
this.z-=s;

return this;

},

subVectors:function subVectors(a,b){

this.x=a.x-b.x;
this.y=a.y-b.y;
this.z=a.z-b.z;

return this;

},

multiply:function multiply(v,w){

if(w!==undefined){

console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
return this.multiplyVectors(v,w);

}

this.x*=v.x;
this.y*=v.y;
this.z*=v.z;

return this;

},

multiplyScalar:function multiplyScalar(scalar){

this.x*=scalar;
this.y*=scalar;
this.z*=scalar;

return this;

},

multiplyVectors:function multiplyVectors(a,b){

this.x=a.x*b.x;
this.y=a.y*b.y;
this.z=a.z*b.z;

return this;

},

applyEuler:function(){

var quaternion=new Quaternion();

return function applyEuler(euler){

if(!(euler&&euler.isEuler)){

console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');

}

return this.applyQuaternion(quaternion.setFromEuler(euler));

};

}(),

applyAxisAngle:function(){

var quaternion=new Quaternion();

return function applyAxisAngle(axis,angle){

return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));

};

}(),

applyMatrix3:function applyMatrix3(m){

var x=this.x,y=this.y,z=this.z;
var e=m.elements;

this.x=e[0]*x+e[3]*y+e[6]*z;
this.y=e[1]*x+e[4]*y+e[7]*z;
this.z=e[2]*x+e[5]*y+e[8]*z;

return this;

},

applyMatrix4:function applyMatrix4(m){

var x=this.x,y=this.y,z=this.z;
var e=m.elements;

var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);

this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;
this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;
this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;

return this;

},

applyQuaternion:function applyQuaternion(q){

var x=this.x,y=this.y,z=this.z;
var qx=q.x,qy=q.y,qz=q.z,qw=q.w;

// calculate quat * vector

var ix=qw*x+qy*z-qz*y;
var iy=qw*y+qz*x-qx*z;
var iz=qw*z+qx*y-qy*x;
var iw=-qx*x-qy*y-qz*z;

// calculate result * inverse quat

this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;
this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;
this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;

return this;

},

project:function project(camera){

return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);

},

unproject:function unproject(camera){

return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);

},

transformDirection:function transformDirection(m){

// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction

var x=this.x,y=this.y,z=this.z;
var e=m.elements;

this.x=e[0]*x+e[4]*y+e[8]*z;
this.y=e[1]*x+e[5]*y+e[9]*z;
this.z=e[2]*x+e[6]*y+e[10]*z;

return this.normalize();

},

divide:function divide(v){

this.x/=v.x;
this.y/=v.y;
this.z/=v.z;

return this;

},

divideScalar:function divideScalar(scalar){

return this.multiplyScalar(1/scalar);

},

min:function min(v){

this.x=Math.min(this.x,v.x);
this.y=Math.min(this.y,v.y);
this.z=Math.min(this.z,v.z);

return this;

},

max:function max(v){

this.x=Math.max(this.x,v.x);
this.y=Math.max(this.y,v.y);
this.z=Math.max(this.z,v.z);

return this;

},

clamp:function clamp(min,max){

// assumes min < max, componentwise

this.x=Math.max(min.x,Math.min(max.x,this.x));
this.y=Math.max(min.y,Math.min(max.y,this.y));
this.z=Math.max(min.z,Math.min(max.z,this.z));

return this;

},

clampScalar:function clampScalar(minVal,maxVal){

this.x=Math.max(minVal,Math.min(maxVal,this.x));
this.y=Math.max(minVal,Math.min(maxVal,this.y));
this.z=Math.max(minVal,Math.min(maxVal,this.z));

return this;

},

clampLength:function clampLength(min,max){

var length=this.length();

return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));

},

floor:function floor(){

this.x=Math.floor(this.x);
this.y=Math.floor(this.y);
this.z=Math.floor(this.z);

return this;

},

ceil:function ceil(){

this.x=Math.ceil(this.x);
this.y=Math.ceil(this.y);
this.z=Math.ceil(this.z);

return this;

},

round:function round(){

this.x=Math.round(this.x);
this.y=Math.round(this.y);
this.z=Math.round(this.z);

return this;

},

roundToZero:function roundToZero(){

this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);
this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);
this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);

return this;

},

negate:function negate(){

this.x=-this.x;
this.y=-this.y;
this.z=-this.z;

return this;

},

dot:function dot(v){

return this.x*v.x+this.y*v.y+this.z*v.z;

},

// TODO lengthSquared?

lengthSq:function lengthSq(){

return this.x*this.x+this.y*this.y+this.z*this.z;

},

length:function length(){

return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);

},

manhattanLength:function manhattanLength(){

return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);

},

normalize:function normalize(){

return this.divideScalar(this.length()||1);

},

setLength:function setLength(length){

return this.normalize().multiplyScalar(length);

},

lerp:function lerp(v,alpha){

this.x+=(v.x-this.x)*alpha;
this.y+=(v.y-this.y)*alpha;
this.z+=(v.z-this.z)*alpha;

return this;

},

lerpVectors:function lerpVectors(v1,v2,alpha){

return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);

},

cross:function cross(v,w){

if(w!==undefined){

console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
return this.crossVectors(v,w);

}

return this.crossVectors(this,v);

},

crossVectors:function crossVectors(a,b){

var ax=a.x,ay=a.y,az=a.z;
var bx=b.x,by=b.y,bz=b.z;

this.x=ay*bz-az*by;
this.y=az*bx-ax*bz;
this.z=ax*by-ay*bx;

return this;

},

projectOnVector:function projectOnVector(vector){

var scalar=vector.dot(this)/vector.lengthSq();

return this.copy(vector).multiplyScalar(scalar);

},

projectOnPlane:function(){

var v1=new Vector3();

return function projectOnPlane(planeNormal){

v1.copy(this).projectOnVector(planeNormal);

return this.sub(v1);

};

}(),

reflect:function(){

// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length

var v1=new Vector3();

return function reflect(normal){

return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));

};

}(),

angleTo:function angleTo(v){

var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());

// clamp, to handle numerical problems

return Math.acos(_Math.clamp(theta,-1,1));

},

distanceTo:function distanceTo(v){

return Math.sqrt(this.distanceToSquared(v));

},

distanceToSquared:function distanceToSquared(v){

var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;

return dx*dx+dy*dy+dz*dz;

},

manhattanDistanceTo:function manhattanDistanceTo(v){

return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);

},

setFromSpherical:function setFromSpherical(s){

return this.setFromSphericalCoords(s.radius,s.phi,s.theta);

},

setFromSphericalCoords:function setFromSphericalCoords(radius,phi,theta){

var sinPhiRadius=Math.sin(phi)*radius;

this.x=sinPhiRadius*Math.sin(theta);
this.y=Math.cos(phi)*radius;
this.z=sinPhiRadius*Math.cos(theta);

return this;

},

setFromCylindrical:function setFromCylindrical(c){

return this.setFromCylindricalCoords(c.radius,c.theta,c.y);

},

setFromCylindricalCoords:function setFromCylindricalCoords(radius,theta,y){

this.x=radius*Math.sin(theta);
this.y=y;
this.z=radius*Math.cos(theta);

return this;

},

setFromMatrixPosition:function setFromMatrixPosition(m){

var e=m.elements;

this.x=e[12];
this.y=e[13];
this.z=e[14];

return this;

},

setFromMatrixScale:function setFromMatrixScale(m){

var sx=this.setFromMatrixColumn(m,0).length();
var sy=this.setFromMatrixColumn(m,1).length();
var sz=this.setFromMatrixColumn(m,2).length();

this.x=sx;
this.y=sy;
this.z=sz;

return this;

},

setFromMatrixColumn:function setFromMatrixColumn(m,index){

return this.fromArray(m.elements,index*4);

},

equals:function equals(v){

return v.x===this.x&&v.y===this.y&&v.z===this.z;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

this.x=array[offset];
this.y=array[offset+1];
this.z=array[offset+2];

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this.x;
array[offset+1]=this.y;
array[offset+2]=this.z;

return array;

},

fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){

if(offset!==undefined){

console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');

}

this.x=attribute.getX(index);
this.y=attribute.getY(index);
this.z=attribute.getZ(index);

return this;

}});



/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3(){

this.elements=[

1,0,0,
0,1,0,
0,0,1];



if(arguments.length>0){

console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');

}

}

Object.assign(Matrix3.prototype,{

isMatrix3:true,

set:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){

var te=this.elements;

te[0]=n11;te[1]=n21;te[2]=n31;
te[3]=n12;te[4]=n22;te[5]=n32;
te[6]=n13;te[7]=n23;te[8]=n33;

return this;

},

identity:function identity(){

this.set(

1,0,0,
0,1,0,
0,0,1);



return this;

},

clone:function clone(){

return new this.constructor().fromArray(this.elements);

},

copy:function copy(m){

var te=this.elements;
var me=m.elements;

te[0]=me[0];te[1]=me[1];te[2]=me[2];
te[3]=me[3];te[4]=me[4];te[5]=me[5];
te[6]=me[6];te[7]=me[7];te[8]=me[8];

return this;

},

setFromMatrix4:function setFromMatrix4(m){

var me=m.elements;

this.set(

me[0],me[4],me[8],
me[1],me[5],me[9],
me[2],me[6],me[10]);



return this;

},

applyToBufferAttribute:function(){

var v1=new Vector3();

return function applyToBufferAttribute(attribute){

for(var i=0,l=attribute.count;i<l;i++){

v1.x=attribute.getX(i);
v1.y=attribute.getY(i);
v1.z=attribute.getZ(i);

v1.applyMatrix3(this);

attribute.setXYZ(i,v1.x,v1.y,v1.z);

}

return attribute;

};

}(),

multiply:function multiply(m){

return this.multiplyMatrices(this,m);

},

premultiply:function premultiply(m){

return this.multiplyMatrices(m,this);

},

multiplyMatrices:function multiplyMatrices(a,b){

var ae=a.elements;
var be=b.elements;
var te=this.elements;

var a11=ae[0],a12=ae[3],a13=ae[6];
var a21=ae[1],a22=ae[4],a23=ae[7];
var a31=ae[2],a32=ae[5],a33=ae[8];

var b11=be[0],b12=be[3],b13=be[6];
var b21=be[1],b22=be[4],b23=be[7];
var b31=be[2],b32=be[5],b33=be[8];

te[0]=a11*b11+a12*b21+a13*b31;
te[3]=a11*b12+a12*b22+a13*b32;
te[6]=a11*b13+a12*b23+a13*b33;

te[1]=a21*b11+a22*b21+a23*b31;
te[4]=a21*b12+a22*b22+a23*b32;
te[7]=a21*b13+a22*b23+a23*b33;

te[2]=a31*b11+a32*b21+a33*b31;
te[5]=a31*b12+a32*b22+a33*b32;
te[8]=a31*b13+a32*b23+a33*b33;

return this;

},

multiplyScalar:function multiplyScalar(s){

var te=this.elements;

te[0]*=s;te[3]*=s;te[6]*=s;
te[1]*=s;te[4]*=s;te[7]*=s;
te[2]*=s;te[5]*=s;te[8]*=s;

return this;

},

determinant:function determinant(){

var te=this.elements;

var a=te[0],b=te[1],c=te[2],
d=te[3],e=te[4],f=te[5],
g=te[6],h=te[7],i=te[8];

return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;

},

getInverse:function getInverse(matrix,throwOnDegenerate){

if(matrix&&matrix.isMatrix4){

console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");

}

var me=matrix.elements,
te=this.elements,

n11=me[0],n21=me[1],n31=me[2],
n12=me[3],n22=me[4],n32=me[5],
n13=me[6],n23=me[7],n33=me[8],

t11=n33*n22-n32*n23,
t12=n32*n13-n33*n12,
t13=n23*n12-n22*n13,

det=n11*t11+n21*t12+n31*t13;

if(det===0){

var msg="THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

if(throwOnDegenerate===true){

throw new Error(msg);

}else{

console.warn(msg);

}

return this.identity();

}

var detInv=1/det;

te[0]=t11*detInv;
te[1]=(n31*n23-n33*n21)*detInv;
te[2]=(n32*n21-n31*n22)*detInv;

te[3]=t12*detInv;
te[4]=(n33*n11-n31*n13)*detInv;
te[5]=(n31*n12-n32*n11)*detInv;

te[6]=t13*detInv;
te[7]=(n21*n13-n23*n11)*detInv;
te[8]=(n22*n11-n21*n12)*detInv;

return this;

},

transpose:function transpose(){

var tmp,m=this.elements;

tmp=m[1];m[1]=m[3];m[3]=tmp;
tmp=m[2];m[2]=m[6];m[6]=tmp;
tmp=m[5];m[5]=m[7];m[7]=tmp;

return this;

},

getNormalMatrix:function getNormalMatrix(matrix4){

return this.setFromMatrix4(matrix4).getInverse(this).transpose();

},

transposeIntoArray:function transposeIntoArray(r){

var m=this.elements;

r[0]=m[0];
r[1]=m[3];
r[2]=m[6];
r[3]=m[1];
r[4]=m[4];
r[5]=m[7];
r[6]=m[2];
r[7]=m[5];
r[8]=m[8];

return this;

},

setUvTransform:function setUvTransform(tx,ty,sx,sy,rotation,cx,cy){

var c=Math.cos(rotation);
var s=Math.sin(rotation);

this.set(
sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,
-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,
0,0,1);


},

scale:function scale(sx,sy){

var te=this.elements;

te[0]*=sx;te[3]*=sx;te[6]*=sx;
te[1]*=sy;te[4]*=sy;te[7]*=sy;

return this;

},

rotate:function rotate(theta){

var c=Math.cos(theta);
var s=Math.sin(theta);

var te=this.elements;

var a11=te[0],a12=te[3],a13=te[6];
var a21=te[1],a22=te[4],a23=te[7];

te[0]=c*a11+s*a21;
te[3]=c*a12+s*a22;
te[6]=c*a13+s*a23;

te[1]=-s*a11+c*a21;
te[4]=-s*a12+c*a22;
te[7]=-s*a13+c*a23;

return this;

},

translate:function translate(tx,ty){

var te=this.elements;

te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];
te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];

return this;

},

equals:function equals(matrix){

var te=this.elements;
var me=matrix.elements;

for(var i=0;i<9;i++){

if(te[i]!==me[i])return false;

}

return true;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

for(var i=0;i<9;i++){

this.elements[i]=array[i+offset];

}

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

var te=this.elements;

array[offset]=te[0];
array[offset+1]=te[1];
array[offset+2]=te[2];

array[offset+3]=te[3];
array[offset+4]=te[4];
array[offset+5]=te[5];

array[offset+6]=te[6];
array[offset+7]=te[7];
array[offset+8]=te[8];

return array;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var _canvas;

var ImageUtils={

getDataURL:function getDataURL(image){

var canvas;

if(typeof HTMLCanvasElement=='undefined'){

return image.src;

}else if(image instanceof HTMLCanvasElement){

canvas=image;

}else{

if(_canvas===undefined)_canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');

_canvas.width=image.width;
_canvas.height=image.height;

var context=_canvas.getContext('2d');

if(image instanceof ImageData){

context.putImageData(image,0,0);

}else{

context.drawImage(image,0,0,image.width,image.height);

}

canvas=_canvas;

}

if(canvas.width>2048||canvas.height>2048){

return canvas.toDataURL('image/jpeg',0.6);

}else{

return canvas.toDataURL('image/png');

}

}};



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId=0;

function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){

Object.defineProperty(this,'id',{value:textureId++});

this.uuid=_Math.generateUUID();

this.name='';

this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;
this.mipmaps=[];

this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;

this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;
this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;

this.magFilter=magFilter!==undefined?magFilter:LinearFilter;
this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;

this.anisotropy=anisotropy!==undefined?anisotropy:1;

this.format=format!==undefined?format:RGBAFormat;
this.type=type!==undefined?type:UnsignedByteType;

this.offset=new Vector2(0,0);
this.repeat=new Vector2(1,1);
this.center=new Vector2(0,0);
this.rotation=0;

this.matrixAutoUpdate=true;
this.matrix=new Matrix3();

this.generateMipmaps=true;
this.premultiplyAlpha=false;
this.flipY=true;
this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding!==undefined?encoding:LinearEncoding;

this.version=0;
this.onUpdate=null;

}

Texture.DEFAULT_IMAGE=undefined;
Texture.DEFAULT_MAPPING=UVMapping;

Texture.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:Texture,

isTexture:true,

updateMatrix:function updateMatrix(){

this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(source){

this.name=source.name;

this.image=source.image;
this.mipmaps=source.mipmaps.slice(0);

this.mapping=source.mapping;

this.wrapS=source.wrapS;
this.wrapT=source.wrapT;

this.magFilter=source.magFilter;
this.minFilter=source.minFilter;

this.anisotropy=source.anisotropy;

this.format=source.format;
this.type=source.type;

this.offset.copy(source.offset);
this.repeat.copy(source.repeat);
this.center.copy(source.center);
this.rotation=source.rotation;

this.matrixAutoUpdate=source.matrixAutoUpdate;
this.matrix.copy(source.matrix);

this.generateMipmaps=source.generateMipmaps;
this.premultiplyAlpha=source.premultiplyAlpha;
this.flipY=source.flipY;
this.unpackAlignment=source.unpackAlignment;
this.encoding=source.encoding;

return this;

},

toJSON:function toJSON(meta){

var isRootObject=meta===undefined||typeof meta==='string';

if(!isRootObject&&meta.textures[this.uuid]!==undefined){

return meta.textures[this.uuid];

}

var output={

metadata:{
version:4.5,
type:'Texture',
generator:'Texture.toJSON'},


uuid:this.uuid,
name:this.name,

mapping:this.mapping,

repeat:[this.repeat.x,this.repeat.y],
offset:[this.offset.x,this.offset.y],
center:[this.center.x,this.center.y],
rotation:this.rotation,

wrap:[this.wrapS,this.wrapT],

format:this.format,
type:this.type,
encoding:this.encoding,

minFilter:this.minFilter,
magFilter:this.magFilter,
anisotropy:this.anisotropy,

flipY:this.flipY,

premultiplyAlpha:this.premultiplyAlpha,
unpackAlignment:this.unpackAlignment};



if(this.image!==undefined){

// TODO: Move to THREE.Image

var image=this.image;

if(image.uuid===undefined){

image.uuid=_Math.generateUUID();// UGH

}

if(!isRootObject&&meta.images[image.uuid]===undefined){

var url;

if(Array.isArray(image)){

// process array of images e.g. CubeTexture

url=[];

for(var i=0,l=image.length;i<l;i++){

url.push(ImageUtils.getDataURL(image[i]));

}

}else{

// process single image

url=ImageUtils.getDataURL(image);

}

meta.images[image.uuid]={
uuid:image.uuid,
url:url};


}

output.image=image.uuid;

}

if(!isRootObject){

meta.textures[this.uuid]=output;

}

return output;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

},

transformUv:function transformUv(uv){

if(this.mapping!==UVMapping)return uv;

uv.applyMatrix3(this.matrix);

if(uv.x<0||uv.x>1){

switch(this.wrapS){

case RepeatWrapping:

uv.x=uv.x-Math.floor(uv.x);
break;

case ClampToEdgeWrapping:

uv.x=uv.x<0?0:1;
break;

case MirroredRepeatWrapping:

if(Math.abs(Math.floor(uv.x)%2)===1){

uv.x=Math.ceil(uv.x)-uv.x;

}else{

uv.x=uv.x-Math.floor(uv.x);

}
break;}



}

if(uv.y<0||uv.y>1){

switch(this.wrapT){

case RepeatWrapping:

uv.y=uv.y-Math.floor(uv.y);
break;

case ClampToEdgeWrapping:

uv.y=uv.y<0?0:1;
break;

case MirroredRepeatWrapping:

if(Math.abs(Math.floor(uv.y)%2)===1){

uv.y=Math.ceil(uv.y)-uv.y;

}else{

uv.y=uv.y-Math.floor(uv.y);

}
break;}



}

if(this.flipY){

uv.y=1-uv.y;

}

return uv;

}});



Object.defineProperty(Texture.prototype,"needsUpdate",{

set:function set(value){

if(value===true)this.version++;

}});



/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4(x,y,z,w){

this.x=x||0;
this.y=y||0;
this.z=z||0;
this.w=w!==undefined?w:1;

}

Object.assign(Vector4.prototype,{

isVector4:true,

set:function set(x,y,z,w){

this.x=x;
this.y=y;
this.z=z;
this.w=w;

return this;

},

setScalar:function setScalar(scalar){

this.x=scalar;
this.y=scalar;
this.z=scalar;
this.w=scalar;

return this;

},

setX:function setX(x){

this.x=x;

return this;

},

setY:function setY(y){

this.y=y;

return this;

},

setZ:function setZ(z){

this.z=z;

return this;

},

setW:function setW(w){

this.w=w;

return this;

},

setComponent:function setComponent(index,value){

switch(index){

case 0:this.x=value;break;
case 1:this.y=value;break;
case 2:this.z=value;break;
case 3:this.w=value;break;
default:throw new Error('index is out of range: '+index);}



return this;

},

getComponent:function getComponent(index){

switch(index){

case 0:return this.x;
case 1:return this.y;
case 2:return this.z;
case 3:return this.w;
default:throw new Error('index is out of range: '+index);}



},

clone:function clone(){

return new this.constructor(this.x,this.y,this.z,this.w);

},

copy:function copy(v){

this.x=v.x;
this.y=v.y;
this.z=v.z;
this.w=v.w!==undefined?v.w:1;

return this;

},

add:function add(v,w){

if(w!==undefined){

console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
return this.addVectors(v,w);

}

this.x+=v.x;
this.y+=v.y;
this.z+=v.z;
this.w+=v.w;

return this;

},

addScalar:function addScalar(s){

this.x+=s;
this.y+=s;
this.z+=s;
this.w+=s;

return this;

},

addVectors:function addVectors(a,b){

this.x=a.x+b.x;
this.y=a.y+b.y;
this.z=a.z+b.z;
this.w=a.w+b.w;

return this;

},

addScaledVector:function addScaledVector(v,s){

this.x+=v.x*s;
this.y+=v.y*s;
this.z+=v.z*s;
this.w+=v.w*s;

return this;

},

sub:function sub(v,w){

if(w!==undefined){

console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
return this.subVectors(v,w);

}

this.x-=v.x;
this.y-=v.y;
this.z-=v.z;
this.w-=v.w;

return this;

},

subScalar:function subScalar(s){

this.x-=s;
this.y-=s;
this.z-=s;
this.w-=s;

return this;

},

subVectors:function subVectors(a,b){

this.x=a.x-b.x;
this.y=a.y-b.y;
this.z=a.z-b.z;
this.w=a.w-b.w;

return this;

},

multiplyScalar:function multiplyScalar(scalar){

this.x*=scalar;
this.y*=scalar;
this.z*=scalar;
this.w*=scalar;

return this;

},

applyMatrix4:function applyMatrix4(m){

var x=this.x,y=this.y,z=this.z,w=this.w;
var e=m.elements;

this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;
this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;
this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;
this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;

return this;

},

divideScalar:function divideScalar(scalar){

return this.multiplyScalar(1/scalar);

},

setAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

// q is assumed to be normalized

this.w=2*Math.acos(q.w);

var s=Math.sqrt(1-q.w*q.w);

if(s<0.0001){

this.x=1;
this.y=0;
this.z=0;

}else{

this.x=q.x/s;
this.y=q.y/s;
this.z=q.z/s;

}

return this;

},

setAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){

// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

var angle,x,y,z,// variables for result
epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees

te=m.elements,

m11=te[0],m12=te[4],m13=te[8],
m21=te[1],m22=te[5],m23=te[9],
m31=te[2],m32=te[6],m33=te[10];

if(Math.abs(m12-m21)<epsilon&&
Math.abs(m13-m31)<epsilon&&
Math.abs(m23-m32)<epsilon){

// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms

if(Math.abs(m12+m21)<epsilon2&&
Math.abs(m13+m31)<epsilon2&&
Math.abs(m23+m32)<epsilon2&&
Math.abs(m11+m22+m33-3)<epsilon2){

// this singularity is identity matrix so angle = 0

this.set(1,0,0,0);

return this;// zero angle, arbitrary axis

}

// otherwise this singularity is angle = 180

angle=Math.PI;

var xx=(m11+1)/2;
var yy=(m22+1)/2;
var zz=(m33+1)/2;
var xy=(m12+m21)/4;
var xz=(m13+m31)/4;
var yz=(m23+m32)/4;

if(xx>yy&&xx>zz){

// m11 is the largest diagonal term

if(xx<epsilon){

x=0;
y=0.707106781;
z=0.707106781;

}else{

x=Math.sqrt(xx);
y=xy/x;
z=xz/x;

}

}else if(yy>zz){

// m22 is the largest diagonal term

if(yy<epsilon){

x=0.707106781;
y=0;
z=0.707106781;

}else{

y=Math.sqrt(yy);
x=xy/y;
z=yz/y;

}

}else{

// m33 is the largest diagonal term so base result on this

if(zz<epsilon){

x=0.707106781;
y=0.707106781;
z=0;

}else{

z=Math.sqrt(zz);
x=xz/z;
y=yz/z;

}

}

this.set(x,y,z,angle);

return this;// return 180 deg rotation

}

// as we have reached here there are no singularities so we can handle normally

var s=Math.sqrt((m32-m23)*(m32-m23)+
(m13-m31)*(m13-m31)+
(m21-m12)*(m21-m12));// used to normalize

if(Math.abs(s)<0.001)s=1;

// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case

this.x=(m32-m23)/s;
this.y=(m13-m31)/s;
this.z=(m21-m12)/s;
this.w=Math.acos((m11+m22+m33-1)/2);

return this;

},

min:function min(v){

this.x=Math.min(this.x,v.x);
this.y=Math.min(this.y,v.y);
this.z=Math.min(this.z,v.z);
this.w=Math.min(this.w,v.w);

return this;

},

max:function max(v){

this.x=Math.max(this.x,v.x);
this.y=Math.max(this.y,v.y);
this.z=Math.max(this.z,v.z);
this.w=Math.max(this.w,v.w);

return this;

},

clamp:function clamp(min,max){

// assumes min < max, componentwise

this.x=Math.max(min.x,Math.min(max.x,this.x));
this.y=Math.max(min.y,Math.min(max.y,this.y));
this.z=Math.max(min.z,Math.min(max.z,this.z));
this.w=Math.max(min.w,Math.min(max.w,this.w));

return this;

},

clampScalar:function(){

var min,max;

return function clampScalar(minVal,maxVal){

if(min===undefined){

min=new Vector4();
max=new Vector4();

}

min.set(minVal,minVal,minVal,minVal);
max.set(maxVal,maxVal,maxVal,maxVal);

return this.clamp(min,max);

};

}(),

clampLength:function clampLength(min,max){

var length=this.length();

return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));

},

floor:function floor(){

this.x=Math.floor(this.x);
this.y=Math.floor(this.y);
this.z=Math.floor(this.z);
this.w=Math.floor(this.w);

return this;

},

ceil:function ceil(){

this.x=Math.ceil(this.x);
this.y=Math.ceil(this.y);
this.z=Math.ceil(this.z);
this.w=Math.ceil(this.w);

return this;

},

round:function round(){

this.x=Math.round(this.x);
this.y=Math.round(this.y);
this.z=Math.round(this.z);
this.w=Math.round(this.w);

return this;

},

roundToZero:function roundToZero(){

this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);
this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);
this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);
this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);

return this;

},

negate:function negate(){

this.x=-this.x;
this.y=-this.y;
this.z=-this.z;
this.w=-this.w;

return this;

},

dot:function dot(v){

return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;

},

lengthSq:function lengthSq(){

return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;

},

length:function length(){

return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);

},

manhattanLength:function manhattanLength(){

return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);

},

normalize:function normalize(){

return this.divideScalar(this.length()||1);

},

setLength:function setLength(length){

return this.normalize().multiplyScalar(length);

},

lerp:function lerp(v,alpha){

this.x+=(v.x-this.x)*alpha;
this.y+=(v.y-this.y)*alpha;
this.z+=(v.z-this.z)*alpha;
this.w+=(v.w-this.w)*alpha;

return this;

},

lerpVectors:function lerpVectors(v1,v2,alpha){

return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);

},

equals:function equals(v){

return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

this.x=array[offset];
this.y=array[offset+1];
this.z=array[offset+2];
this.w=array[offset+3];

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this.x;
array[offset+1]=this.y;
array[offset+2]=this.z;
array[offset+3]=this.w;

return array;

},

fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){

if(offset!==undefined){

console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');

}

this.x=attribute.getX(index);
this.y=attribute.getY(index);
this.z=attribute.getZ(index);
this.w=attribute.getW(index);

return this;

}});



/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget(width,height,options){

this.width=width;
this.height=height;

this.scissor=new Vector4(0,0,width,height);
this.scissorTest=false;

this.viewport=new Vector4(0,0,width,height);

options=options||{};

this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);

this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;
this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;

this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;
this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;
this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;

}

WebGLRenderTarget.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:WebGLRenderTarget,

isWebGLRenderTarget:true,

setSize:function setSize(width,height){

if(this.width!==width||this.height!==height){

this.width=width;
this.height=height;

this.dispose();

}

this.viewport.set(0,0,width,height);
this.scissor.set(0,0,width,height);

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(source){

this.width=source.width;
this.height=source.height;

this.viewport.copy(source.viewport);

this.texture=source.texture.clone();

this.depthBuffer=source.depthBuffer;
this.stencilBuffer=source.stencilBuffer;
this.depthTexture=source.depthTexture;

return this;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

}});



/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget(width,height,options){

WebGLRenderTarget.call(this,width,height,options);

this.samples=4;

}

WebGLMultisampleRenderTarget.prototype=Object.assign(Object.create(WebGLRenderTarget.prototype),{

constructor:WebGLMultisampleRenderTarget,

isWebGLMultisampleRenderTarget:true,

copy:function copy(source){

WebGLRenderTarget.prototype.copy.call(this,source);

this.samples=source.samples;

return this;

}});



/**
 * @author alteredq / http://alteredqualia.com
 */

function WebGLRenderTargetCube(width,height,options){

WebGLRenderTarget.call(this,width,height,options);

}

WebGLRenderTargetCube.prototype=Object.create(WebGLRenderTarget.prototype);
WebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;

WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){

Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);

this.image={data:data,width:width,height:height};

this.magFilter=magFilter!==undefined?magFilter:NearestFilter;
this.minFilter=minFilter!==undefined?minFilter:NearestFilter;

this.generateMipmaps=false;
this.flipY=false;
this.unpackAlignment=1;

}

DataTexture.prototype=Object.create(Texture.prototype);
DataTexture.prototype.constructor=DataTexture;

DataTexture.prototype.isDataTexture=true;

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3(min,max){

this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);
this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);

}

Object.assign(Box3.prototype,{

isBox3:true,

set:function set(min,max){

this.min.copy(min);
this.max.copy(max);

return this;

},

setFromArray:function setFromArray(array){

var minX=+Infinity;
var minY=+Infinity;
var minZ=+Infinity;

var maxX=-Infinity;
var maxY=-Infinity;
var maxZ=-Infinity;

for(var i=0,l=array.length;i<l;i+=3){

var x=array[i];
var y=array[i+1];
var z=array[i+2];

if(x<minX)minX=x;
if(y<minY)minY=y;
if(z<minZ)minZ=z;

if(x>maxX)maxX=x;
if(y>maxY)maxY=y;
if(z>maxZ)maxZ=z;

}

this.min.set(minX,minY,minZ);
this.max.set(maxX,maxY,maxZ);

return this;

},

setFromBufferAttribute:function setFromBufferAttribute(attribute){

var minX=+Infinity;
var minY=+Infinity;
var minZ=+Infinity;

var maxX=-Infinity;
var maxY=-Infinity;
var maxZ=-Infinity;

for(var i=0,l=attribute.count;i<l;i++){

var x=attribute.getX(i);
var y=attribute.getY(i);
var z=attribute.getZ(i);

if(x<minX)minX=x;
if(y<minY)minY=y;
if(z<minZ)minZ=z;

if(x>maxX)maxX=x;
if(y>maxY)maxY=y;
if(z>maxZ)maxZ=z;

}

this.min.set(minX,minY,minZ);
this.max.set(maxX,maxY,maxZ);

return this;

},

setFromPoints:function setFromPoints(points){

this.makeEmpty();

for(var i=0,il=points.length;i<il;i++){

this.expandByPoint(points[i]);

}

return this;

},

setFromCenterAndSize:function(){

var v1=new Vector3();

return function setFromCenterAndSize(center,size){

var halfSize=v1.copy(size).multiplyScalar(0.5);

this.min.copy(center).sub(halfSize);
this.max.copy(center).add(halfSize);

return this;

};

}(),

setFromObject:function setFromObject(object){

this.makeEmpty();

return this.expandByObject(object);

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(box){

this.min.copy(box.min);
this.max.copy(box.max);

return this;

},

makeEmpty:function makeEmpty(){

this.min.x=this.min.y=this.min.z=+Infinity;
this.max.x=this.max.y=this.max.z=-Infinity;

return this;

},

isEmpty:function isEmpty(){

// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;

},

getCenter:function getCenter(target){

if(target===undefined){

console.warn('THREE.Box3: .getCenter() target is now required');
target=new Vector3();

}

return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);

},

getSize:function getSize(target){

if(target===undefined){

console.warn('THREE.Box3: .getSize() target is now required');
target=new Vector3();

}

return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);

},

expandByPoint:function expandByPoint(point){

this.min.min(point);
this.max.max(point);

return this;

},

expandByVector:function expandByVector(vector){

this.min.sub(vector);
this.max.add(vector);

return this;

},

expandByScalar:function expandByScalar(scalar){

this.min.addScalar(-scalar);
this.max.addScalar(scalar);

return this;

},

expandByObject:function(){

// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms

var scope,i,l;

var v1=new Vector3();

function traverse(node){

var geometry=node.geometry;

if(geometry!==undefined){

if(geometry.isGeometry){

var vertices=geometry.vertices;

for(i=0,l=vertices.length;i<l;i++){

v1.copy(vertices[i]);
v1.applyMatrix4(node.matrixWorld);

scope.expandByPoint(v1);

}

}else if(geometry.isBufferGeometry){

var attribute=geometry.attributes.position;

if(attribute!==undefined){

for(i=0,l=attribute.count;i<l;i++){

v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);

scope.expandByPoint(v1);

}

}

}

}

}

return function expandByObject(object){

scope=this;

object.updateMatrixWorld(true);

object.traverse(traverse);

return this;

};

}(),

containsPoint:function containsPoint(point){

return point.x<this.min.x||point.x>this.max.x||
point.y<this.min.y||point.y>this.max.y||
point.z<this.min.z||point.z>this.max.z?false:true;

},

containsBox:function containsBox(box){

return this.min.x<=box.min.x&&box.max.x<=this.max.x&&
this.min.y<=box.min.y&&box.max.y<=this.max.y&&
this.min.z<=box.min.z&&box.max.z<=this.max.z;

},

getParameter:function getParameter(point,target){

// This can potentially have a divide by zero if the box
// has a size dimension of 0.

if(target===undefined){

console.warn('THREE.Box3: .getParameter() target is now required');
target=new Vector3();

}

return target.set(
(point.x-this.min.x)/(this.max.x-this.min.x),
(point.y-this.min.y)/(this.max.y-this.min.y),
(point.z-this.min.z)/(this.max.z-this.min.z));


},

intersectsBox:function intersectsBox(box){

// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||
box.max.y<this.min.y||box.min.y>this.max.y||
box.max.z<this.min.z||box.min.z>this.max.z?false:true;

},

intersectsSphere:function(){

var closestPoint=new Vector3();

return function intersectsSphere(sphere){

// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,closestPoint);

// If that point is inside the sphere, the AABB and sphere intersect.
return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;

};

}(),

intersectsPlane:function intersectsPlane(plane){

// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.

var min,max;

if(plane.normal.x>0){

min=plane.normal.x*this.min.x;
max=plane.normal.x*this.max.x;

}else{

min=plane.normal.x*this.max.x;
max=plane.normal.x*this.min.x;

}

if(plane.normal.y>0){

min+=plane.normal.y*this.min.y;
max+=plane.normal.y*this.max.y;

}else{

min+=plane.normal.y*this.max.y;
max+=plane.normal.y*this.min.y;

}

if(plane.normal.z>0){

min+=plane.normal.z*this.min.z;
max+=plane.normal.z*this.max.z;

}else{

min+=plane.normal.z*this.max.z;
max+=plane.normal.z*this.min.z;

}

return min<=-plane.constant&&max>=-plane.constant;

},

intersectsTriangle:function(){

// triangle centered vertices
var v0=new Vector3();
var v1=new Vector3();
var v2=new Vector3();

// triangle edge vectors
var f0=new Vector3();
var f1=new Vector3();
var f2=new Vector3();

var testAxis=new Vector3();

var center=new Vector3();
var extents=new Vector3();

var triangleNormal=new Vector3();

function satForAxes(axes){

var i,j;

for(i=0,j=axes.length-3;i<=j;i+=3){

testAxis.fromArray(axes,i);
// project the aabb onto the seperating axis
var r=extents.x*Math.abs(testAxis.x)+extents.y*Math.abs(testAxis.y)+extents.z*Math.abs(testAxis.z);
// project all 3 vertices of the triangle onto the seperating axis
var p0=v0.dot(testAxis);
var p1=v1.dot(testAxis);
var p2=v2.dot(testAxis);
// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){

// points of the projected triangle are outside the projected half-length of the aabb
// the axis is seperating and we can exit
return false;

}

}

return true;

}

return function intersectsTriangle(triangle){

if(this.isEmpty()){

return false;

}

// compute box center and extents
this.getCenter(center);
extents.subVectors(this.max,center);

// translate triangle to aabb origin
v0.subVectors(triangle.a,center);
v1.subVectors(triangle.b,center);
v2.subVectors(triangle.c,center);

// compute edge vectors for triangle
f0.subVectors(v1,v0);
f1.subVectors(v2,v1);
f2.subVectors(v0,v2);

// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
var axes=[
0,-f0.z,f0.y,0,-f1.z,f1.y,0,-f2.z,f2.y,
f0.z,0,-f0.x,f1.z,0,-f1.x,f2.z,0,-f2.x,
-f0.y,f0.x,0,-f1.y,f1.x,0,-f2.y,f2.x,0];

if(!satForAxes(axes)){

return false;

}

// test 3 face normals from the aabb
axes=[1,0,0,0,1,0,0,0,1];
if(!satForAxes(axes)){

return false;

}

// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
triangleNormal.crossVectors(f0,f1);
axes=[triangleNormal.x,triangleNormal.y,triangleNormal.z];
return satForAxes(axes);

};

}(),

clampPoint:function clampPoint(point,target){

if(target===undefined){

console.warn('THREE.Box3: .clampPoint() target is now required');
target=new Vector3();

}

return target.copy(point).clamp(this.min,this.max);

},

distanceToPoint:function(){

var v1=new Vector3();

return function distanceToPoint(point){

var clampedPoint=v1.copy(point).clamp(this.min,this.max);
return clampedPoint.sub(point).length();

};

}(),

getBoundingSphere:function(){

var v1=new Vector3();

return function getBoundingSphere(target){

if(target===undefined){

console.error('THREE.Box3: .getBoundingSphere() target is now required');
//target = new Sphere(); // removed to avoid cyclic dependency

}

this.getCenter(target.center);

target.radius=this.getSize(v1).length()*0.5;

return target;

};

}(),

intersect:function intersect(box){

this.min.max(box.min);
this.max.min(box.max);

// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();

return this;

},

union:function union(box){

this.min.min(box.min);
this.max.max(box.max);

return this;

},

applyMatrix4:function(){

var points=[
new Vector3(),
new Vector3(),
new Vector3(),
new Vector3(),
new Vector3(),
new Vector3(),
new Vector3(),
new Vector3()];


return function applyMatrix4(matrix){

// transform of empty box is an empty box.
if(this.isEmpty())return this;

// NOTE: I am using a binary pattern to specify all 2^3 combinations below
points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111

this.setFromPoints(points);

return this;

};

}(),

translate:function translate(offset){

this.min.add(offset);
this.max.add(offset);

return this;

},

equals:function equals(box){

return box.min.equals(this.min)&&box.max.equals(this.max);

}});



/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere(center,radius){

this.center=center!==undefined?center:new Vector3();
this.radius=radius!==undefined?radius:0;

}

Object.assign(Sphere.prototype,{

set:function set(center,radius){

this.center.copy(center);
this.radius=radius;

return this;

},

setFromPoints:function(){

var box=new Box3();

return function setFromPoints(points,optionalCenter){

var center=this.center;

if(optionalCenter!==undefined){

center.copy(optionalCenter);

}else{

box.setFromPoints(points).getCenter(center);

}

var maxRadiusSq=0;

for(var i=0,il=points.length;i<il;i++){

maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));

}

this.radius=Math.sqrt(maxRadiusSq);

return this;

};

}(),

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(sphere){

this.center.copy(sphere.center);
this.radius=sphere.radius;

return this;

},

empty:function empty(){

return this.radius<=0;

},

containsPoint:function containsPoint(point){

return point.distanceToSquared(this.center)<=this.radius*this.radius;

},

distanceToPoint:function distanceToPoint(point){

return point.distanceTo(this.center)-this.radius;

},

intersectsSphere:function intersectsSphere(sphere){

var radiusSum=this.radius+sphere.radius;

return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;

},

intersectsBox:function intersectsBox(box){

return box.intersectsSphere(this);

},

intersectsPlane:function intersectsPlane(plane){

return Math.abs(plane.distanceToPoint(this.center))<=this.radius;

},

clampPoint:function clampPoint(point,target){

var deltaLengthSq=this.center.distanceToSquared(point);

if(target===undefined){

console.warn('THREE.Sphere: .clampPoint() target is now required');
target=new Vector3();

}

target.copy(point);

if(deltaLengthSq>this.radius*this.radius){

target.sub(this.center).normalize();
target.multiplyScalar(this.radius).add(this.center);

}

return target;

},

getBoundingBox:function getBoundingBox(target){

if(target===undefined){

console.warn('THREE.Sphere: .getBoundingBox() target is now required');
target=new Box3();

}

target.set(this.center,this.center);
target.expandByScalar(this.radius);

return target;

},

applyMatrix4:function applyMatrix4(matrix){

this.center.applyMatrix4(matrix);
this.radius=this.radius*matrix.getMaxScaleOnAxis();

return this;

},

translate:function translate(offset){

this.center.add(offset);

return this;

},

equals:function equals(sphere){

return sphere.center.equals(this.center)&&sphere.radius===this.radius;

}});



/**
 * @author bhouston / http://clara.io
 */

function Plane(normal,constant){

// normal is assumed to be normalized

this.normal=normal!==undefined?normal:new Vector3(1,0,0);
this.constant=constant!==undefined?constant:0;

}

Object.assign(Plane.prototype,{

set:function set(normal,constant){

this.normal.copy(normal);
this.constant=constant;

return this;

},

setComponents:function setComponents(x,y,z,w){

this.normal.set(x,y,z);
this.constant=w;

return this;

},

setFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){

this.normal.copy(normal);
this.constant=-point.dot(this.normal);

return this;

},

setFromCoplanarPoints:function(){

var v1=new Vector3();
var v2=new Vector3();

return function setFromCoplanarPoints(a,b,c){

var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();

// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

this.setFromNormalAndCoplanarPoint(normal,a);

return this;

};

}(),

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(plane){

this.normal.copy(plane.normal);
this.constant=plane.constant;

return this;

},

normalize:function normalize(){

// Note: will lead to a divide by zero if the plane is invalid.

var inverseNormalLength=1.0/this.normal.length();
this.normal.multiplyScalar(inverseNormalLength);
this.constant*=inverseNormalLength;

return this;

},

negate:function negate(){

this.constant*=-1;
this.normal.negate();

return this;

},

distanceToPoint:function distanceToPoint(point){

return this.normal.dot(point)+this.constant;

},

distanceToSphere:function distanceToSphere(sphere){

return this.distanceToPoint(sphere.center)-sphere.radius;

},

projectPoint:function projectPoint(point,target){

if(target===undefined){

console.warn('THREE.Plane: .projectPoint() target is now required');
target=new Vector3();

}

return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);

},

intersectLine:function(){

var v1=new Vector3();

return function intersectLine(line,target){

if(target===undefined){

console.warn('THREE.Plane: .intersectLine() target is now required');
target=new Vector3();

}

var direction=line.delta(v1);

var denominator=this.normal.dot(direction);

if(denominator===0){

// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){

return target.copy(line.start);

}

// Unsure if this is the correct method to handle this case.
return undefined;

}

var t=-(line.start.dot(this.normal)+this.constant)/denominator;

if(t<0||t>1){

return undefined;

}

return target.copy(direction).multiplyScalar(t).add(line.start);

};

}(),

intersectsLine:function intersectsLine(line){

// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

var startSign=this.distanceToPoint(line.start);
var endSign=this.distanceToPoint(line.end);

return startSign<0&&endSign>0||endSign<0&&startSign>0;

},

intersectsBox:function intersectsBox(box){

return box.intersectsPlane(this);

},

intersectsSphere:function intersectsSphere(sphere){

return sphere.intersectsPlane(this);

},

coplanarPoint:function coplanarPoint(target){

if(target===undefined){

console.warn('THREE.Plane: .coplanarPoint() target is now required');
target=new Vector3();

}

return target.copy(this.normal).multiplyScalar(-this.constant);

},

applyMatrix4:function(){

var v1=new Vector3();
var m1=new Matrix3();

return function applyMatrix4(matrix,optionalNormalMatrix){

var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);

var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);

var normal=this.normal.applyMatrix3(normalMatrix).normalize();

this.constant=-referencePoint.dot(normal);

return this;

};

}(),

translate:function translate(offset){

this.constant-=offset.dot(this.normal);

return this;

},

equals:function equals(plane){

return plane.normal.equals(this.normal)&&plane.constant===this.constant;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum(p0,p1,p2,p3,p4,p5){

this.planes=[

p0!==undefined?p0:new Plane(),
p1!==undefined?p1:new Plane(),
p2!==undefined?p2:new Plane(),
p3!==undefined?p3:new Plane(),
p4!==undefined?p4:new Plane(),
p5!==undefined?p5:new Plane()];



}

Object.assign(Frustum.prototype,{

set:function set(p0,p1,p2,p3,p4,p5){

var planes=this.planes;

planes[0].copy(p0);
planes[1].copy(p1);
planes[2].copy(p2);
planes[3].copy(p3);
planes[4].copy(p4);
planes[5].copy(p5);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(frustum){

var planes=this.planes;

for(var i=0;i<6;i++){

planes[i].copy(frustum.planes[i]);

}

return this;

},

setFromMatrix:function setFromMatrix(m){

var planes=this.planes;
var me=m.elements;
var me0=me[0],me1=me[1],me2=me[2],me3=me[3];
var me4=me[4],me5=me[5],me6=me[6],me7=me[7];
var me8=me[8],me9=me[9],me10=me[10],me11=me[11];
var me12=me[12],me13=me[13],me14=me[14],me15=me[15];

planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();
planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();
planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();
planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();
planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();
planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();

return this;

},

intersectsObject:function(){

var sphere=new Sphere();

return function intersectsObject(object){

var geometry=object.geometry;

if(geometry.boundingSphere===null)
geometry.computeBoundingSphere();

sphere.copy(geometry.boundingSphere).
applyMatrix4(object.matrixWorld);

return this.intersectsSphere(sphere);

};

}(),

intersectsSprite:function(){

var sphere=new Sphere();

return function intersectsSprite(sprite){

sphere.center.set(0,0,0);
sphere.radius=0.7071067811865476;
sphere.applyMatrix4(sprite.matrixWorld);

return this.intersectsSphere(sphere);

};

}(),

intersectsSphere:function intersectsSphere(sphere){

var planes=this.planes;
var center=sphere.center;
var negRadius=-sphere.radius;

for(var i=0;i<6;i++){

var distance=planes[i].distanceToPoint(center);

if(distance<negRadius){

return false;

}

}

return true;

},

intersectsBox:function(){

var p=new Vector3();

return function intersectsBox(box){

var planes=this.planes;

for(var i=0;i<6;i++){

var plane=planes[i];

// corner at max distance

p.x=plane.normal.x>0?box.max.x:box.min.x;
p.y=plane.normal.y>0?box.max.y:box.min.y;
p.z=plane.normal.z>0?box.max.z:box.min.z;

if(plane.distanceToPoint(p)<0){

return false;

}

}

return true;

};

}(),

containsPoint:function containsPoint(point){

var planes=this.planes;

for(var i=0;i<6;i++){

if(planes[i].distanceToPoint(point)<0){

return false;

}

}

return true;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4(){

this.elements=[

1,0,0,0,
0,1,0,0,
0,0,1,0,
0,0,0,1];



if(arguments.length>0){

console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');

}

}

Object.assign(Matrix4.prototype,{

isMatrix4:true,

set:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){

var te=this.elements;

te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;
te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;
te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;
te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;

return this;

},

identity:function identity(){

this.set(

1,0,0,0,
0,1,0,0,
0,0,1,0,
0,0,0,1);



return this;

},

clone:function clone(){

return new Matrix4().fromArray(this.elements);

},

copy:function copy(m){

var te=this.elements;
var me=m.elements;

te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];
te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];
te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];
te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];

return this;

},

copyPosition:function copyPosition(m){

var te=this.elements,me=m.elements;

te[12]=me[12];
te[13]=me[13];
te[14]=me[14];

return this;

},

extractBasis:function extractBasis(xAxis,yAxis,zAxis){

xAxis.setFromMatrixColumn(this,0);
yAxis.setFromMatrixColumn(this,1);
zAxis.setFromMatrixColumn(this,2);

return this;

},

makeBasis:function makeBasis(xAxis,yAxis,zAxis){

this.set(
xAxis.x,yAxis.x,zAxis.x,0,
xAxis.y,yAxis.y,zAxis.y,0,
xAxis.z,yAxis.z,zAxis.z,0,
0,0,0,1);


return this;

},

extractRotation:function(){

var v1=new Vector3();

return function extractRotation(m){

// this method does not support reflection matrices

var te=this.elements;
var me=m.elements;

var scaleX=1/v1.setFromMatrixColumn(m,0).length();
var scaleY=1/v1.setFromMatrixColumn(m,1).length();
var scaleZ=1/v1.setFromMatrixColumn(m,2).length();

te[0]=me[0]*scaleX;
te[1]=me[1]*scaleX;
te[2]=me[2]*scaleX;
te[3]=0;

te[4]=me[4]*scaleY;
te[5]=me[5]*scaleY;
te[6]=me[6]*scaleY;
te[7]=0;

te[8]=me[8]*scaleZ;
te[9]=me[9]*scaleZ;
te[10]=me[10]*scaleZ;
te[11]=0;

te[12]=0;
te[13]=0;
te[14]=0;
te[15]=1;

return this;

};

}(),

makeRotationFromEuler:function makeRotationFromEuler(euler){

if(!(euler&&euler.isEuler)){

console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');

}

var te=this.elements;

var x=euler.x,y=euler.y,z=euler.z;
var a=Math.cos(x),b=Math.sin(x);
var c=Math.cos(y),d=Math.sin(y);
var e=Math.cos(z),f=Math.sin(z);

if(euler.order==='XYZ'){

var ae=a*e,af=a*f,be=b*e,bf=b*f;

te[0]=c*e;
te[4]=-c*f;
te[8]=d;

te[1]=af+be*d;
te[5]=ae-bf*d;
te[9]=-b*c;

te[2]=bf-ae*d;
te[6]=be+af*d;
te[10]=a*c;

}else if(euler.order==='YXZ'){

var ce=c*e,cf=c*f,de=d*e,df=d*f;

te[0]=ce+df*b;
te[4]=de*b-cf;
te[8]=a*d;

te[1]=a*f;
te[5]=a*e;
te[9]=-b;

te[2]=cf*b-de;
te[6]=df+ce*b;
te[10]=a*c;

}else if(euler.order==='ZXY'){

var ce=c*e,cf=c*f,de=d*e,df=d*f;

te[0]=ce-df*b;
te[4]=-a*f;
te[8]=de+cf*b;

te[1]=cf+de*b;
te[5]=a*e;
te[9]=df-ce*b;

te[2]=-a*d;
te[6]=b;
te[10]=a*c;

}else if(euler.order==='ZYX'){

var ae=a*e,af=a*f,be=b*e,bf=b*f;

te[0]=c*e;
te[4]=be*d-af;
te[8]=ae*d+bf;

te[1]=c*f;
te[5]=bf*d+ae;
te[9]=af*d-be;

te[2]=-d;
te[6]=b*c;
te[10]=a*c;

}else if(euler.order==='YZX'){

var ac=a*c,ad=a*d,bc=b*c,bd=b*d;

te[0]=c*e;
te[4]=bd-ac*f;
te[8]=bc*f+ad;

te[1]=f;
te[5]=a*e;
te[9]=-b*e;

te[2]=-d*e;
te[6]=ad*f+bc;
te[10]=ac-bd*f;

}else if(euler.order==='XZY'){

var ac=a*c,ad=a*d,bc=b*c,bd=b*d;

te[0]=c*e;
te[4]=-f;
te[8]=d*e;

te[1]=ac*f+bd;
te[5]=a*e;
te[9]=ad*f-bc;

te[2]=bc*f-ad;
te[6]=b*e;
te[10]=bd*f+ac;

}

// bottom row
te[3]=0;
te[7]=0;
te[11]=0;

// last column
te[12]=0;
te[13]=0;
te[14]=0;
te[15]=1;

return this;

},

makeRotationFromQuaternion:function(){

var zero=new Vector3(0,0,0);
var one=new Vector3(1,1,1);

return function makeRotationFromQuaternion(q){

return this.compose(zero,q,one);

};

}(),

lookAt:function(){

var x=new Vector3();
var y=new Vector3();
var z=new Vector3();

return function lookAt(eye,target,up){

var te=this.elements;

z.subVectors(eye,target);

if(z.lengthSq()===0){

// eye and target are in the same position

z.z=1;

}

z.normalize();
x.crossVectors(up,z);

if(x.lengthSq()===0){

// up and z are parallel

if(Math.abs(up.z)===1){

z.x+=0.0001;

}else{

z.z+=0.0001;

}

z.normalize();
x.crossVectors(up,z);

}

x.normalize();
y.crossVectors(z,x);

te[0]=x.x;te[4]=y.x;te[8]=z.x;
te[1]=x.y;te[5]=y.y;te[9]=z.y;
te[2]=x.z;te[6]=y.z;te[10]=z.z;

return this;

};

}(),

multiply:function multiply(m,n){

if(n!==undefined){

console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
return this.multiplyMatrices(m,n);

}

return this.multiplyMatrices(this,m);

},

premultiply:function premultiply(m){

return this.multiplyMatrices(m,this);

},

multiplyMatrices:function multiplyMatrices(a,b){

var ae=a.elements;
var be=b.elements;
var te=this.elements;

var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];
var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];
var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];
var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];

var b11=be[0],b12=be[4],b13=be[8],b14=be[12];
var b21=be[1],b22=be[5],b23=be[9],b24=be[13];
var b31=be[2],b32=be[6],b33=be[10],b34=be[14];
var b41=be[3],b42=be[7],b43=be[11],b44=be[15];

te[0]=a11*b11+a12*b21+a13*b31+a14*b41;
te[4]=a11*b12+a12*b22+a13*b32+a14*b42;
te[8]=a11*b13+a12*b23+a13*b33+a14*b43;
te[12]=a11*b14+a12*b24+a13*b34+a14*b44;

te[1]=a21*b11+a22*b21+a23*b31+a24*b41;
te[5]=a21*b12+a22*b22+a23*b32+a24*b42;
te[9]=a21*b13+a22*b23+a23*b33+a24*b43;
te[13]=a21*b14+a22*b24+a23*b34+a24*b44;

te[2]=a31*b11+a32*b21+a33*b31+a34*b41;
te[6]=a31*b12+a32*b22+a33*b32+a34*b42;
te[10]=a31*b13+a32*b23+a33*b33+a34*b43;
te[14]=a31*b14+a32*b24+a33*b34+a34*b44;

te[3]=a41*b11+a42*b21+a43*b31+a44*b41;
te[7]=a41*b12+a42*b22+a43*b32+a44*b42;
te[11]=a41*b13+a42*b23+a43*b33+a44*b43;
te[15]=a41*b14+a42*b24+a43*b34+a44*b44;

return this;

},

multiplyScalar:function multiplyScalar(s){

var te=this.elements;

te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;
te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;
te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;
te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;

return this;

},

applyToBufferAttribute:function(){

var v1=new Vector3();

return function applyToBufferAttribute(attribute){

for(var i=0,l=attribute.count;i<l;i++){

v1.x=attribute.getX(i);
v1.y=attribute.getY(i);
v1.z=attribute.getZ(i);

v1.applyMatrix4(this);

attribute.setXYZ(i,v1.x,v1.y,v1.z);

}

return attribute;

};

}(),

determinant:function determinant(){

var te=this.elements;

var n11=te[0],n12=te[4],n13=te[8],n14=te[12];
var n21=te[1],n22=te[5],n23=te[9],n24=te[13];
var n31=te[2],n32=te[6],n33=te[10],n34=te[14];
var n41=te[3],n42=te[7],n43=te[11],n44=te[15];

//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

return(
n41*(
+n14*n23*n32-
n13*n24*n32-
n14*n22*n33+
n12*n24*n33+
n13*n22*n34-
n12*n23*n34)+

n42*(
+n11*n23*n34-
n11*n24*n33+
n14*n21*n33-
n13*n21*n34+
n13*n24*n31-
n14*n23*n31)+

n43*(
+n11*n24*n32-
n11*n22*n34-
n14*n21*n32+
n12*n21*n34+
n14*n22*n31-
n12*n24*n31)+

n44*(
-n13*n22*n31-
n11*n23*n32+
n11*n22*n33+
n13*n21*n32-
n12*n21*n33+
n12*n23*n31));




},

transpose:function transpose(){

var te=this.elements;
var tmp;

tmp=te[1];te[1]=te[4];te[4]=tmp;
tmp=te[2];te[2]=te[8];te[8]=tmp;
tmp=te[6];te[6]=te[9];te[9]=tmp;

tmp=te[3];te[3]=te[12];te[12]=tmp;
tmp=te[7];te[7]=te[13];te[13]=tmp;
tmp=te[11];te[11]=te[14];te[14]=tmp;

return this;

},

setPosition:function setPosition(x,y,z){

var te=this.elements;

if(x.isVector3){

te[12]=x.x;
te[13]=x.y;
te[14]=x.z;

}else{

te[12]=x;
te[13]=y;
te[14]=z;

}

return this;

},

getInverse:function getInverse(m,throwOnDegenerate){

// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
var te=this.elements,
me=m.elements,

n11=me[0],n21=me[1],n31=me[2],n41=me[3],
n12=me[4],n22=me[5],n32=me[6],n42=me[7],
n13=me[8],n23=me[9],n33=me[10],n43=me[11],
n14=me[12],n24=me[13],n34=me[14],n44=me[15],

t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,
t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,
t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,
t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;

var det=n11*t11+n21*t12+n31*t13+n41*t14;

if(det===0){

var msg="THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

if(throwOnDegenerate===true){

throw new Error(msg);

}else{

console.warn(msg);

}

return this.identity();

}

var detInv=1/det;

te[0]=t11*detInv;
te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;
te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;
te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;

te[4]=t12*detInv;
te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;
te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;
te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;

te[8]=t13*detInv;
te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;
te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;
te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;

te[12]=t14*detInv;
te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;
te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;
te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;

return this;

},

scale:function scale(v){

var te=this.elements;
var x=v.x,y=v.y,z=v.z;

te[0]*=x;te[4]*=y;te[8]*=z;
te[1]*=x;te[5]*=y;te[9]*=z;
te[2]*=x;te[6]*=y;te[10]*=z;
te[3]*=x;te[7]*=y;te[11]*=z;

return this;

},

getMaxScaleOnAxis:function getMaxScaleOnAxis(){

var te=this.elements;

var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];
var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];
var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];

return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));

},

makeTranslation:function makeTranslation(x,y,z){

this.set(

1,0,0,x,
0,1,0,y,
0,0,1,z,
0,0,0,1);



return this;

},

makeRotationX:function makeRotationX(theta){

var c=Math.cos(theta),s=Math.sin(theta);

this.set(

1,0,0,0,
0,c,-s,0,
0,s,c,0,
0,0,0,1);



return this;

},

makeRotationY:function makeRotationY(theta){

var c=Math.cos(theta),s=Math.sin(theta);

this.set(

c,0,s,0,
0,1,0,0,
-s,0,c,0,
0,0,0,1);



return this;

},

makeRotationZ:function makeRotationZ(theta){

var c=Math.cos(theta),s=Math.sin(theta);

this.set(

c,-s,0,0,
s,c,0,0,
0,0,1,0,
0,0,0,1);



return this;

},

makeRotationAxis:function makeRotationAxis(axis,angle){

// Based on http://www.gamedev.net/reference/articles/article1199.asp

var c=Math.cos(angle);
var s=Math.sin(angle);
var t=1-c;
var x=axis.x,y=axis.y,z=axis.z;
var tx=t*x,ty=t*y;

this.set(

tx*x+c,tx*y-s*z,tx*z+s*y,0,
tx*y+s*z,ty*y+c,ty*z-s*x,0,
tx*z-s*y,ty*z+s*x,t*z*z+c,0,
0,0,0,1);



return this;

},

makeScale:function makeScale(x,y,z){

this.set(

x,0,0,0,
0,y,0,0,
0,0,z,0,
0,0,0,1);



return this;

},

makeShear:function makeShear(x,y,z){

this.set(

1,y,z,0,
x,1,z,0,
x,y,1,0,
0,0,0,1);



return this;

},

compose:function compose(position,quaternion,scale){

var te=this.elements;

var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;
var x2=x+x,y2=y+y,z2=z+z;
var xx=x*x2,xy=x*y2,xz=x*z2;
var yy=y*y2,yz=y*z2,zz=z*z2;
var wx=w*x2,wy=w*y2,wz=w*z2;

var sx=scale.x,sy=scale.y,sz=scale.z;

te[0]=(1-(yy+zz))*sx;
te[1]=(xy+wz)*sx;
te[2]=(xz-wy)*sx;
te[3]=0;

te[4]=(xy-wz)*sy;
te[5]=(1-(xx+zz))*sy;
te[6]=(yz+wx)*sy;
te[7]=0;

te[8]=(xz+wy)*sz;
te[9]=(yz-wx)*sz;
te[10]=(1-(xx+yy))*sz;
te[11]=0;

te[12]=position.x;
te[13]=position.y;
te[14]=position.z;
te[15]=1;

return this;

},

decompose:function(){

var vector=new Vector3();
var matrix=new Matrix4();

return function decompose(position,quaternion,scale){

var te=this.elements;

var sx=vector.set(te[0],te[1],te[2]).length();
var sy=vector.set(te[4],te[5],te[6]).length();
var sz=vector.set(te[8],te[9],te[10]).length();

// if determine is negative, we need to invert one scale
var det=this.determinant();
if(det<0)sx=-sx;

position.x=te[12];
position.y=te[13];
position.z=te[14];

// scale the rotation part
matrix.copy(this);

var invSX=1/sx;
var invSY=1/sy;
var invSZ=1/sz;

matrix.elements[0]*=invSX;
matrix.elements[1]*=invSX;
matrix.elements[2]*=invSX;

matrix.elements[4]*=invSY;
matrix.elements[5]*=invSY;
matrix.elements[6]*=invSY;

matrix.elements[8]*=invSZ;
matrix.elements[9]*=invSZ;
matrix.elements[10]*=invSZ;

quaternion.setFromRotationMatrix(matrix);

scale.x=sx;
scale.y=sy;
scale.z=sz;

return this;

};

}(),

makePerspective:function makePerspective(left,right,top,bottom,near,far){

if(far===undefined){

console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');

}

var te=this.elements;
var x=2*near/(right-left);
var y=2*near/(top-bottom);

var a=(right+left)/(right-left);
var b=(top+bottom)/(top-bottom);
var c=-(far+near)/(far-near);
var d=-2*far*near/(far-near);

te[0]=x;te[4]=0;te[8]=a;te[12]=0;
te[1]=0;te[5]=y;te[9]=b;te[13]=0;
te[2]=0;te[6]=0;te[10]=c;te[14]=d;
te[3]=0;te[7]=0;te[11]=-1;te[15]=0;

return this;

},

makeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){

var te=this.elements;
var w=1.0/(right-left);
var h=1.0/(top-bottom);
var p=1.0/(far-near);

var x=(right+left)*w;
var y=(top+bottom)*h;
var z=(far+near)*p;

te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;
te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;
te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;
te[3]=0;te[7]=0;te[11]=0;te[15]=1;

return this;

},

equals:function equals(matrix){

var te=this.elements;
var me=matrix.elements;

for(var i=0;i<16;i++){

if(te[i]!==me[i])return false;

}

return true;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

for(var i=0;i<16;i++){

this.elements[i]=array[i+offset];

}

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

var te=this.elements;

array[offset]=te[0];
array[offset+1]=te[1];
array[offset+2]=te[2];
array[offset+3]=te[3];

array[offset+4]=te[4];
array[offset+5]=te[5];
array[offset+6]=te[6];
array[offset+7]=te[7];

array[offset+8]=te[8];
array[offset+9]=te[9];
array[offset+10]=te[10];
array[offset+11]=te[11];

array[offset+12]=te[12];
array[offset+13]=te[13];
array[offset+14]=te[14];
array[offset+15]=te[15];

return array;

}});



var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex="vec3 transformed = vec3( position );";

var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";

var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";

var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";

var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";

var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";

var defaultnormal_vertex="vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex="#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";

var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";

var lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";

var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";

var lights_pars_begin="uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment="#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";

var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";

var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";

var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment="#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";

var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";

var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_maps="#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";

var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";

var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex="vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment="#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment="#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";

var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";

var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment="#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";

var uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";

var background_frag="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";

var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";

var distanceRGBA_frag="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var meshmatcap_vert="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";

var shadow_vert="#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var ShaderChunk={
alphamap_fragment:alphamap_fragment,
alphamap_pars_fragment:alphamap_pars_fragment,
alphatest_fragment:alphatest_fragment,
aomap_fragment:aomap_fragment,
aomap_pars_fragment:aomap_pars_fragment,
begin_vertex:begin_vertex,
beginnormal_vertex:beginnormal_vertex,
bsdfs:bsdfs,
bumpmap_pars_fragment:bumpmap_pars_fragment,
clipping_planes_fragment:clipping_planes_fragment,
clipping_planes_pars_fragment:clipping_planes_pars_fragment,
clipping_planes_pars_vertex:clipping_planes_pars_vertex,
clipping_planes_vertex:clipping_planes_vertex,
color_fragment:color_fragment,
color_pars_fragment:color_pars_fragment,
color_pars_vertex:color_pars_vertex,
color_vertex:color_vertex,
common:common,
cube_uv_reflection_fragment:cube_uv_reflection_fragment,
defaultnormal_vertex:defaultnormal_vertex,
displacementmap_pars_vertex:displacementmap_pars_vertex,
displacementmap_vertex:displacementmap_vertex,
emissivemap_fragment:emissivemap_fragment,
emissivemap_pars_fragment:emissivemap_pars_fragment,
encodings_fragment:encodings_fragment,
encodings_pars_fragment:encodings_pars_fragment,
envmap_fragment:envmap_fragment,
envmap_pars_fragment:envmap_pars_fragment,
envmap_pars_vertex:envmap_pars_vertex,
envmap_physical_pars_fragment:envmap_physical_pars_fragment,
envmap_vertex:envmap_vertex,
fog_vertex:fog_vertex,
fog_pars_vertex:fog_pars_vertex,
fog_fragment:fog_fragment,
fog_pars_fragment:fog_pars_fragment,
gradientmap_pars_fragment:gradientmap_pars_fragment,
lightmap_fragment:lightmap_fragment,
lightmap_pars_fragment:lightmap_pars_fragment,
lights_lambert_vertex:lights_lambert_vertex,
lights_pars_begin:lights_pars_begin,
lights_phong_fragment:lights_phong_fragment,
lights_phong_pars_fragment:lights_phong_pars_fragment,
lights_physical_fragment:lights_physical_fragment,
lights_physical_pars_fragment:lights_physical_pars_fragment,
lights_fragment_begin:lights_fragment_begin,
lights_fragment_maps:lights_fragment_maps,
lights_fragment_end:lights_fragment_end,
logdepthbuf_fragment:logdepthbuf_fragment,
logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,
logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,
logdepthbuf_vertex:logdepthbuf_vertex,
map_fragment:map_fragment,
map_pars_fragment:map_pars_fragment,
map_particle_fragment:map_particle_fragment,
map_particle_pars_fragment:map_particle_pars_fragment,
metalnessmap_fragment:metalnessmap_fragment,
metalnessmap_pars_fragment:metalnessmap_pars_fragment,
morphnormal_vertex:morphnormal_vertex,
morphtarget_pars_vertex:morphtarget_pars_vertex,
morphtarget_vertex:morphtarget_vertex,
normal_fragment_begin:normal_fragment_begin,
normal_fragment_maps:normal_fragment_maps,
normalmap_pars_fragment:normalmap_pars_fragment,
packing:packing,
premultiplied_alpha_fragment:premultiplied_alpha_fragment,
project_vertex:project_vertex,
dithering_fragment:dithering_fragment,
dithering_pars_fragment:dithering_pars_fragment,
roughnessmap_fragment:roughnessmap_fragment,
roughnessmap_pars_fragment:roughnessmap_pars_fragment,
shadowmap_pars_fragment:shadowmap_pars_fragment,
shadowmap_pars_vertex:shadowmap_pars_vertex,
shadowmap_vertex:shadowmap_vertex,
shadowmask_pars_fragment:shadowmask_pars_fragment,
skinbase_vertex:skinbase_vertex,
skinning_pars_vertex:skinning_pars_vertex,
skinning_vertex:skinning_vertex,
skinnormal_vertex:skinnormal_vertex,
specularmap_fragment:specularmap_fragment,
specularmap_pars_fragment:specularmap_pars_fragment,
tonemapping_fragment:tonemapping_fragment,
tonemapping_pars_fragment:tonemapping_pars_fragment,
uv_pars_fragment:uv_pars_fragment,
uv_pars_vertex:uv_pars_vertex,
uv_vertex:uv_vertex,
uv2_pars_fragment:uv2_pars_fragment,
uv2_pars_vertex:uv2_pars_vertex,
uv2_vertex:uv2_vertex,
worldpos_vertex:worldpos_vertex,

background_frag:background_frag,
background_vert:background_vert,
cube_frag:cube_frag,
cube_vert:cube_vert,
depth_frag:depth_frag,
depth_vert:depth_vert,
distanceRGBA_frag:distanceRGBA_frag,
distanceRGBA_vert:distanceRGBA_vert,
equirect_frag:equirect_frag,
equirect_vert:equirect_vert,
linedashed_frag:linedashed_frag,
linedashed_vert:linedashed_vert,
meshbasic_frag:meshbasic_frag,
meshbasic_vert:meshbasic_vert,
meshlambert_frag:meshlambert_frag,
meshlambert_vert:meshlambert_vert,
meshmatcap_frag:meshmatcap_frag,
meshmatcap_vert:meshmatcap_vert,
meshphong_frag:meshphong_frag,
meshphong_vert:meshphong_vert,
meshphysical_frag:meshphysical_frag,
meshphysical_vert:meshphysical_vert,
normal_frag:normal_frag,
normal_vert:normal_vert,
points_frag:points_frag,
points_vert:points_vert,
shadow_frag:shadow_frag,
shadow_vert:shadow_vert,
sprite_frag:sprite_frag,
sprite_vert:sprite_vert};


/**
 * Uniform Utilities
 */

function cloneUniforms(src){

var dst={};

for(var u in src){

dst[u]={};

for(var p in src[u]){

var property=src[u][p];

if(property&&(property.isColor||
property.isMatrix3||property.isMatrix4||
property.isVector2||property.isVector3||property.isVector4||
property.isTexture)){

dst[u][p]=property.clone();

}else if(Array.isArray(property)){

dst[u][p]=property.slice();

}else{

dst[u][p]=property;

}

}

}

return dst;

}

function mergeUniforms(uniforms){

var merged={};

for(var u=0;u<uniforms.length;u++){

var tmp=cloneUniforms(uniforms[u]);

for(var p in tmp){

merged[p]=tmp[p];

}

}

return merged;

}

// Legacy

var UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};

/**
 * @author mrdoob / http://mrdoob.com/
 */

var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,
'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,
'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,
'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,
'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,
'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,
'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,
'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,
'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,
'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,
'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,
'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,
'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,
'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,
'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,
'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,
'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,
'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,
'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,
'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,
'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,
'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,
'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,
'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};

function Color(r,g,b){

if(g===undefined&&b===undefined){

// r is THREE.Color, hex or string
return this.set(r);

}

return this.setRGB(r,g,b);

}

Object.assign(Color.prototype,{

isColor:true,

r:1,g:1,b:1,

set:function set(value){

if(value&&value.isColor){

this.copy(value);

}else if(typeof value==='number'){

this.setHex(value);

}else if(typeof value==='string'){

this.setStyle(value);

}

return this;

},

setScalar:function setScalar(scalar){

this.r=scalar;
this.g=scalar;
this.b=scalar;

return this;

},

setHex:function setHex(hex){

hex=Math.floor(hex);

this.r=(hex>>16&255)/255;
this.g=(hex>>8&255)/255;
this.b=(hex&255)/255;

return this;

},

setRGB:function setRGB(r,g,b){

this.r=r;
this.g=g;
this.b=b;

return this;

},

setHSL:function(){

function hue2rgb(p,q,t){

if(t<0)t+=1;
if(t>1)t-=1;
if(t<1/6)return p+(q-p)*6*t;
if(t<1/2)return q;
if(t<2/3)return p+(q-p)*6*(2/3-t);
return p;

}

return function setHSL(h,s,l){

// h,s,l ranges are in 0.0 - 1.0
h=_Math.euclideanModulo(h,1);
s=_Math.clamp(s,0,1);
l=_Math.clamp(l,0,1);

if(s===0){

this.r=this.g=this.b=l;

}else{

var p=l<=0.5?l*(1+s):l+s-l*s;
var q=2*l-p;

this.r=hue2rgb(q,p,h+1/3);
this.g=hue2rgb(q,p,h);
this.b=hue2rgb(q,p,h-1/3);

}

return this;

};

}(),

setStyle:function setStyle(style){

function handleAlpha(string){

if(string===undefined)return;

if(parseFloat(string)<1){

console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');

}

}


var m;

if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){

// rgb / hsl

var color;
var name=m[1];
var components=m[2];

switch(name){

case'rgb':
case'rgba':

if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){

// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(color[1],10))/255;
this.g=Math.min(255,parseInt(color[2],10))/255;
this.b=Math.min(255,parseInt(color[3],10))/255;

handleAlpha(color[5]);

return this;

}

if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){

// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(color[1],10))/100;
this.g=Math.min(100,parseInt(color[2],10))/100;
this.b=Math.min(100,parseInt(color[3],10))/100;

handleAlpha(color[5]);

return this;

}

break;

case'hsl':
case'hsla':

if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){

// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
var h=parseFloat(color[1])/360;
var s=parseInt(color[2],10)/100;
var l=parseInt(color[3],10)/100;

handleAlpha(color[5]);

return this.setHSL(h,s,l);

}

break;}



}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){

// hex color

var hex=m[1];
var size=hex.length;

if(size===3){

// #ff0
this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;
this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;
this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;

return this;

}else if(size===6){

// #ff0000
this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;
this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;
this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;

return this;

}

}

if(style&&style.length>0){

// color keywords
var hex=ColorKeywords[style];

if(hex!==undefined){

// red
this.setHex(hex);

}else{

// unknown color
console.warn('THREE.Color: Unknown color '+style);

}

}

return this;

},

clone:function clone(){

return new this.constructor(this.r,this.g,this.b);

},

copy:function copy(color){

this.r=color.r;
this.g=color.g;
this.b=color.b;

return this;

},

copyGammaToLinear:function copyGammaToLinear(color,gammaFactor){

if(gammaFactor===undefined)gammaFactor=2.0;

this.r=Math.pow(color.r,gammaFactor);
this.g=Math.pow(color.g,gammaFactor);
this.b=Math.pow(color.b,gammaFactor);

return this;

},

copyLinearToGamma:function copyLinearToGamma(color,gammaFactor){

if(gammaFactor===undefined)gammaFactor=2.0;

var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;

this.r=Math.pow(color.r,safeInverse);
this.g=Math.pow(color.g,safeInverse);
this.b=Math.pow(color.b,safeInverse);

return this;

},

convertGammaToLinear:function convertGammaToLinear(gammaFactor){

this.copyGammaToLinear(this,gammaFactor);

return this;

},

convertLinearToGamma:function convertLinearToGamma(gammaFactor){

this.copyLinearToGamma(this,gammaFactor);

return this;

},

copySRGBToLinear:function(){

function SRGBToLinear(c){

return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);

}

return function copySRGBToLinear(color){

this.r=SRGBToLinear(color.r);
this.g=SRGBToLinear(color.g);
this.b=SRGBToLinear(color.b);

return this;

};

}(),

copyLinearToSRGB:function(){

function LinearToSRGB(c){

return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;

}

return function copyLinearToSRGB(color){

this.r=LinearToSRGB(color.r);
this.g=LinearToSRGB(color.g);
this.b=LinearToSRGB(color.b);

return this;

};

}(),

convertSRGBToLinear:function convertSRGBToLinear(){

this.copySRGBToLinear(this);

return this;

},

convertLinearToSRGB:function convertLinearToSRGB(){

this.copyLinearToSRGB(this);

return this;

},

getHex:function getHex(){

return this.r*255<<16^this.g*255<<8^this.b*255<<0;

},

getHexString:function getHexString(){

return('000000'+this.getHex().toString(16)).slice(-6);

},

getHSL:function getHSL(target){

// h,s,l ranges are in 0.0 - 1.0

if(target===undefined){

console.warn('THREE.Color: .getHSL() target is now required');
target={h:0,s:0,l:0};

}

var r=this.r,g=this.g,b=this.b;

var max=Math.max(r,g,b);
var min=Math.min(r,g,b);

var hue,saturation;
var lightness=(min+max)/2.0;

if(min===max){

hue=0;
saturation=0;

}else{

var delta=max-min;

saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);

switch(max){

case r:hue=(g-b)/delta+(g<b?6:0);break;
case g:hue=(b-r)/delta+2;break;
case b:hue=(r-g)/delta+4;break;}



hue/=6;

}

target.h=hue;
target.s=saturation;
target.l=lightness;

return target;

},

getStyle:function getStyle(){

return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';

},

offsetHSL:function(){

var hsl={};

return function(h,s,l){

this.getHSL(hsl);

hsl.h+=h;hsl.s+=s;hsl.l+=l;

this.setHSL(hsl.h,hsl.s,hsl.l);

return this;

};

}(),

add:function add(color){

this.r+=color.r;
this.g+=color.g;
this.b+=color.b;

return this;

},

addColors:function addColors(color1,color2){

this.r=color1.r+color2.r;
this.g=color1.g+color2.g;
this.b=color1.b+color2.b;

return this;

},

addScalar:function addScalar(s){

this.r+=s;
this.g+=s;
this.b+=s;

return this;

},

sub:function sub(color){

this.r=Math.max(0,this.r-color.r);
this.g=Math.max(0,this.g-color.g);
this.b=Math.max(0,this.b-color.b);

return this;

},

multiply:function multiply(color){

this.r*=color.r;
this.g*=color.g;
this.b*=color.b;

return this;

},

multiplyScalar:function multiplyScalar(s){

this.r*=s;
this.g*=s;
this.b*=s;

return this;

},

lerp:function lerp(color,alpha){

this.r+=(color.r-this.r)*alpha;
this.g+=(color.g-this.g)*alpha;
this.b+=(color.b-this.b)*alpha;

return this;

},

lerpHSL:function(){

var hslA={h:0,s:0,l:0};
var hslB={h:0,s:0,l:0};

return function lerpHSL(color,alpha){

this.getHSL(hslA);
color.getHSL(hslB);

var h=_Math.lerp(hslA.h,hslB.h,alpha);
var s=_Math.lerp(hslA.s,hslB.s,alpha);
var l=_Math.lerp(hslA.l,hslB.l,alpha);

this.setHSL(h,s,l);

return this;

};

}(),

equals:function equals(c){

return c.r===this.r&&c.g===this.g&&c.b===this.b;

},

fromArray:function fromArray(array,offset){

if(offset===undefined)offset=0;

this.r=array[offset];
this.g=array[offset+1];
this.b=array[offset+2];

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this.r;
array[offset+1]=this.g;
array[offset+2]=this.b;

return array;

},

toJSON:function toJSON(){

return this.getHex();

}});



/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib={

common:{

diffuse:{value:new Color(0xeeeeee)},
opacity:{value:1.0},

map:{value:null},
uvTransform:{value:new Matrix3()},

alphaMap:{value:null}},



specularmap:{

specularMap:{value:null}},



envmap:{

envMap:{value:null},
flipEnvMap:{value:-1},
reflectivity:{value:1.0},
refractionRatio:{value:0.98},
maxMipLevel:{value:0}},



aomap:{

aoMap:{value:null},
aoMapIntensity:{value:1}},



lightmap:{

lightMap:{value:null},
lightMapIntensity:{value:1}},



emissivemap:{

emissiveMap:{value:null}},



bumpmap:{

bumpMap:{value:null},
bumpScale:{value:1}},



normalmap:{

normalMap:{value:null},
normalScale:{value:new Vector2(1,1)}},



displacementmap:{

displacementMap:{value:null},
displacementScale:{value:1},
displacementBias:{value:0}},



roughnessmap:{

roughnessMap:{value:null}},



metalnessmap:{

metalnessMap:{value:null}},



gradientmap:{

gradientMap:{value:null}},



fog:{

fogDensity:{value:0.00025},
fogNear:{value:1},
fogFar:{value:2000},
fogColor:{value:new Color(0xffffff)}},



lights:{

ambientLightColor:{value:[]},

lightProbe:{value:[]},

directionalLights:{value:[],properties:{
direction:{},
color:{},

shadow:{},
shadowBias:{},
shadowRadius:{},
shadowMapSize:{}}},


directionalShadowMap:{value:[]},
directionalShadowMatrix:{value:[]},

spotLights:{value:[],properties:{
color:{},
position:{},
direction:{},
distance:{},
coneCos:{},
penumbraCos:{},
decay:{},

shadow:{},
shadowBias:{},
shadowRadius:{},
shadowMapSize:{}}},


spotShadowMap:{value:[]},
spotShadowMatrix:{value:[]},

pointLights:{value:[],properties:{
color:{},
position:{},
decay:{},
distance:{},

shadow:{},
shadowBias:{},
shadowRadius:{},
shadowMapSize:{},
shadowCameraNear:{},
shadowCameraFar:{}}},


pointShadowMap:{value:[]},
pointShadowMatrix:{value:[]},

hemisphereLights:{value:[],properties:{
direction:{},
skyColor:{},
groundColor:{}}},


// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{
color:{},
position:{},
width:{},
height:{}}}},




points:{

diffuse:{value:new Color(0xeeeeee)},
opacity:{value:1.0},
size:{value:1.0},
scale:{value:1.0},
map:{value:null},
uvTransform:{value:new Matrix3()}},



sprite:{

diffuse:{value:new Color(0xeeeeee)},
opacity:{value:1.0},
center:{value:new Vector2(0.5,0.5)},
rotation:{value:0.0},
map:{value:null},
uvTransform:{value:new Matrix3()}}};





/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib={

basic:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.specularmap,
UniformsLib.envmap,
UniformsLib.aomap,
UniformsLib.lightmap,
UniformsLib.fog]),


vertexShader:ShaderChunk.meshbasic_vert,
fragmentShader:ShaderChunk.meshbasic_frag},



lambert:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.specularmap,
UniformsLib.envmap,
UniformsLib.aomap,
UniformsLib.lightmap,
UniformsLib.emissivemap,
UniformsLib.fog,
UniformsLib.lights,
{
emissive:{value:new Color(0x000000)}}]),



vertexShader:ShaderChunk.meshlambert_vert,
fragmentShader:ShaderChunk.meshlambert_frag},



phong:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.specularmap,
UniformsLib.envmap,
UniformsLib.aomap,
UniformsLib.lightmap,
UniformsLib.emissivemap,
UniformsLib.bumpmap,
UniformsLib.normalmap,
UniformsLib.displacementmap,
UniformsLib.gradientmap,
UniformsLib.fog,
UniformsLib.lights,
{
emissive:{value:new Color(0x000000)},
specular:{value:new Color(0x111111)},
shininess:{value:30}}]),



vertexShader:ShaderChunk.meshphong_vert,
fragmentShader:ShaderChunk.meshphong_frag},



standard:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.envmap,
UniformsLib.aomap,
UniformsLib.lightmap,
UniformsLib.emissivemap,
UniformsLib.bumpmap,
UniformsLib.normalmap,
UniformsLib.displacementmap,
UniformsLib.roughnessmap,
UniformsLib.metalnessmap,
UniformsLib.fog,
UniformsLib.lights,
{
emissive:{value:new Color(0x000000)},
roughness:{value:0.5},
metalness:{value:0.5},
envMapIntensity:{value:1// temporary
}}]),


vertexShader:ShaderChunk.meshphysical_vert,
fragmentShader:ShaderChunk.meshphysical_frag},



matcap:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.bumpmap,
UniformsLib.normalmap,
UniformsLib.displacementmap,
UniformsLib.fog,
{
matcap:{value:null}}]),



vertexShader:ShaderChunk.meshmatcap_vert,
fragmentShader:ShaderChunk.meshmatcap_frag},



points:{

uniforms:mergeUniforms([
UniformsLib.points,
UniformsLib.fog]),


vertexShader:ShaderChunk.points_vert,
fragmentShader:ShaderChunk.points_frag},



dashed:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.fog,
{
scale:{value:1},
dashSize:{value:1},
totalSize:{value:2}}]),



vertexShader:ShaderChunk.linedashed_vert,
fragmentShader:ShaderChunk.linedashed_frag},



depth:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.displacementmap]),


vertexShader:ShaderChunk.depth_vert,
fragmentShader:ShaderChunk.depth_frag},



normal:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.bumpmap,
UniformsLib.normalmap,
UniformsLib.displacementmap,
{
opacity:{value:1.0}}]),



vertexShader:ShaderChunk.normal_vert,
fragmentShader:ShaderChunk.normal_frag},



sprite:{

uniforms:mergeUniforms([
UniformsLib.sprite,
UniformsLib.fog]),


vertexShader:ShaderChunk.sprite_vert,
fragmentShader:ShaderChunk.sprite_frag},



background:{

uniforms:{
uvTransform:{value:new Matrix3()},
t2D:{value:null}},


vertexShader:ShaderChunk.background_vert,
fragmentShader:ShaderChunk.background_frag},


/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

cube:{

uniforms:{
tCube:{value:null},
tFlip:{value:-1},
opacity:{value:1.0}},


vertexShader:ShaderChunk.cube_vert,
fragmentShader:ShaderChunk.cube_frag},



equirect:{

uniforms:{
tEquirect:{value:null}},


vertexShader:ShaderChunk.equirect_vert,
fragmentShader:ShaderChunk.equirect_frag},



distanceRGBA:{

uniforms:mergeUniforms([
UniformsLib.common,
UniformsLib.displacementmap,
{
referencePosition:{value:new Vector3()},
nearDistance:{value:1},
farDistance:{value:1000}}]),



vertexShader:ShaderChunk.distanceRGBA_vert,
fragmentShader:ShaderChunk.distanceRGBA_frag},



shadow:{

uniforms:mergeUniforms([
UniformsLib.lights,
UniformsLib.fog,
{
color:{value:new Color(0x00000)},
opacity:{value:1.0}}]),



vertexShader:ShaderChunk.shadow_vert,
fragmentShader:ShaderChunk.shadow_frag}};





ShaderLib.physical={

uniforms:mergeUniforms([
ShaderLib.standard.uniforms,
{
clearCoat:{value:0},
clearCoatRoughness:{value:0}}]),



vertexShader:ShaderChunk.meshphysical_vert,
fragmentShader:ShaderChunk.meshphysical_frag};



/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAnimation(){

var context=null;
var isAnimating=false;
var animationLoop=null;

function onAnimationFrame(time,frame){

if(isAnimating===false)return;

animationLoop(time,frame);

context.requestAnimationFrame(onAnimationFrame);

}

return{

start:function start(){

if(isAnimating===true)return;
if(animationLoop===null)return;

context.requestAnimationFrame(onAnimationFrame);

isAnimating=true;

},

stop:function stop(){

isAnimating=false;

},

setAnimationLoop:function setAnimationLoop(callback){

animationLoop=callback;

},

setContext:function setContext(value){

context=value;

}};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLAttributes(gl){

var buffers=new WeakMap();

function createBuffer(attribute,bufferType){

var array=attribute.array;
var usage=attribute.dynamic?35048:35044;

var buffer=gl.createBuffer();

gl.bindBuffer(bufferType,buffer);
gl.bufferData(bufferType,array,usage);

attribute.onUploadCallback();

var type=5126;

if(array instanceof Float32Array){

type=5126;

}else if(array instanceof Float64Array){

console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');

}else if(array instanceof Uint16Array){

type=5123;

}else if(array instanceof Int16Array){

type=5122;

}else if(array instanceof Uint32Array){

type=5125;

}else if(array instanceof Int32Array){

type=5124;

}else if(array instanceof Int8Array){

type=5120;

}else if(array instanceof Uint8Array){

type=5121;

}

return{
buffer:buffer,
type:type,
bytesPerElement:array.BYTES_PER_ELEMENT,
version:attribute.version};


}

function updateBuffer(buffer,attribute,bufferType){

var array=attribute.array;
var updateRange=attribute.updateRange;

gl.bindBuffer(bufferType,buffer);

if(attribute.dynamic===false){

gl.bufferData(bufferType,array,35044);

}else if(updateRange.count===-1){

// Not using update ranges

gl.bufferSubData(bufferType,0,array);

}else if(updateRange.count===0){

console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');

}else{

gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,
array.subarray(updateRange.offset,updateRange.offset+updateRange.count));

updateRange.count=-1;// reset range

}

}

//

function get(attribute){

if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;

return buffers.get(attribute);

}

function remove(attribute){

if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;

var data=buffers.get(attribute);

if(data){

gl.deleteBuffer(data.buffer);

buffers.delete(attribute);

}

}

function update(attribute,bufferType){

if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;

var data=buffers.get(attribute);

if(data===undefined){

buffers.set(attribute,createBuffer(attribute,bufferType));

}else if(data.version<attribute.version){

updateBuffer(data.buffer,attribute,bufferType);

data.version=attribute.version;

}

}

return{

get:get,
remove:remove,
update:update};



}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3(a,b,c,normal,color,materialIndex){

this.a=a;
this.b=b;
this.c=c;

this.normal=normal&&normal.isVector3?normal:new Vector3();
this.vertexNormals=Array.isArray(normal)?normal:[];

this.color=color&&color.isColor?color:new Color();
this.vertexColors=Array.isArray(color)?color:[];

this.materialIndex=materialIndex!==undefined?materialIndex:0;

}

Object.assign(Face3.prototype,{

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(source){

this.a=source.a;
this.b=source.b;
this.c=source.c;

this.normal.copy(source.normal);
this.color.copy(source.color);

this.materialIndex=source.materialIndex;

for(var i=0,il=source.vertexNormals.length;i<il;i++){

this.vertexNormals[i]=source.vertexNormals[i].clone();

}

for(var i=0,il=source.vertexColors.length;i<il;i++){

this.vertexColors[i]=source.vertexColors[i].clone();

}

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler(x,y,z,order){

this._x=x||0;
this._y=y||0;
this._z=z||0;
this._order=order||Euler.DefaultOrder;

}

Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];

Euler.DefaultOrder='XYZ';

Object.defineProperties(Euler.prototype,{

x:{

get:function get(){

return this._x;

},

set:function set(value){

this._x=value;
this.onChangeCallback();

}},



y:{

get:function get(){

return this._y;

},

set:function set(value){

this._y=value;
this.onChangeCallback();

}},



z:{

get:function get(){

return this._z;

},

set:function set(value){

this._z=value;
this.onChangeCallback();

}},



order:{

get:function get(){

return this._order;

},

set:function set(value){

this._order=value;
this.onChangeCallback();

}}});





Object.assign(Euler.prototype,{

isEuler:true,

set:function set(x,y,z,order){

this._x=x;
this._y=y;
this._z=z;
this._order=order||this._order;

this.onChangeCallback();

return this;

},

clone:function clone(){

return new this.constructor(this._x,this._y,this._z,this._order);

},

copy:function copy(euler){

this._x=euler._x;
this._y=euler._y;
this._z=euler._z;
this._order=euler._order;

this.onChangeCallback();

return this;

},

setFromRotationMatrix:function setFromRotationMatrix(m,order,update){

var clamp=_Math.clamp;

// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

var te=m.elements;
var m11=te[0],m12=te[4],m13=te[8];
var m21=te[1],m22=te[5],m23=te[9];
var m31=te[2],m32=te[6],m33=te[10];

order=order||this._order;

if(order==='XYZ'){

this._y=Math.asin(clamp(m13,-1,1));

if(Math.abs(m13)<0.99999){

this._x=Math.atan2(-m23,m33);
this._z=Math.atan2(-m12,m11);

}else{

this._x=Math.atan2(m32,m22);
this._z=0;

}

}else if(order==='YXZ'){

this._x=Math.asin(-clamp(m23,-1,1));

if(Math.abs(m23)<0.99999){

this._y=Math.atan2(m13,m33);
this._z=Math.atan2(m21,m22);

}else{

this._y=Math.atan2(-m31,m11);
this._z=0;

}

}else if(order==='ZXY'){

this._x=Math.asin(clamp(m32,-1,1));

if(Math.abs(m32)<0.99999){

this._y=Math.atan2(-m31,m33);
this._z=Math.atan2(-m12,m22);

}else{

this._y=0;
this._z=Math.atan2(m21,m11);

}

}else if(order==='ZYX'){

this._y=Math.asin(-clamp(m31,-1,1));

if(Math.abs(m31)<0.99999){

this._x=Math.atan2(m32,m33);
this._z=Math.atan2(m21,m11);

}else{

this._x=0;
this._z=Math.atan2(-m12,m22);

}

}else if(order==='YZX'){

this._z=Math.asin(clamp(m21,-1,1));

if(Math.abs(m21)<0.99999){

this._x=Math.atan2(-m23,m22);
this._y=Math.atan2(-m31,m11);

}else{

this._x=0;
this._y=Math.atan2(m13,m33);

}

}else if(order==='XZY'){

this._z=Math.asin(-clamp(m12,-1,1));

if(Math.abs(m12)<0.99999){

this._x=Math.atan2(m32,m22);
this._y=Math.atan2(m13,m11);

}else{

this._x=Math.atan2(-m23,m33);
this._y=0;

}

}else{

console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);

}

this._order=order;

if(update!==false)this.onChangeCallback();

return this;

},

setFromQuaternion:function(){

var matrix=new Matrix4();

return function setFromQuaternion(q,order,update){

matrix.makeRotationFromQuaternion(q);

return this.setFromRotationMatrix(matrix,order,update);

};

}(),

setFromVector3:function setFromVector3(v,order){

return this.set(v.x,v.y,v.z,order||this._order);

},

reorder:function(){

// WARNING: this discards revolution information -bhouston

var q=new Quaternion();

return function reorder(newOrder){

q.setFromEuler(this);

return this.setFromQuaternion(q,newOrder);

};

}(),

equals:function equals(euler){

return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;

},

fromArray:function fromArray(array){

this._x=array[0];
this._y=array[1];
this._z=array[2];
if(array[3]!==undefined)this._order=array[3];

this.onChangeCallback();

return this;

},

toArray:function toArray(array,offset){

if(array===undefined)array=[];
if(offset===undefined)offset=0;

array[offset]=this._x;
array[offset+1]=this._y;
array[offset+2]=this._z;
array[offset+3]=this._order;

return array;

},

toVector3:function toVector3(optionalResult){

if(optionalResult){

return optionalResult.set(this._x,this._y,this._z);

}else{

return new Vector3(this._x,this._y,this._z);

}

},

onChange:function onChange(callback){

this.onChangeCallback=callback;

return this;

},

onChangeCallback:function onChangeCallback(){}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers(){

this.mask=1|0;

}

Object.assign(Layers.prototype,{

set:function set(channel){

this.mask=1<<channel|0;

},

enable:function enable(channel){

this.mask|=1<<channel|0;

},

toggle:function toggle(channel){

this.mask^=1<<channel|0;

},

disable:function disable(channel){

this.mask&=~(1<<channel|0);

},

test:function test(layers){

return(this.mask&layers.mask)!==0;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId=0;

function Object3D(){

Object.defineProperty(this,'id',{value:object3DId++});

this.uuid=_Math.generateUUID();

this.name='';
this.type='Object3D';

this.parent=null;
this.children=[];

this.up=Object3D.DefaultUp.clone();

var position=new Vector3();
var rotation=new Euler();
var quaternion=new Quaternion();
var scale=new Vector3(1,1,1);

function onRotationChange(){

quaternion.setFromEuler(rotation,false);

}

function onQuaternionChange(){

rotation.setFromQuaternion(quaternion,undefined,false);

}

rotation.onChange(onRotationChange);
quaternion.onChange(onQuaternionChange);

Object.defineProperties(this,{
position:{
configurable:true,
enumerable:true,
value:position},

rotation:{
configurable:true,
enumerable:true,
value:rotation},

quaternion:{
configurable:true,
enumerable:true,
value:quaternion},

scale:{
configurable:true,
enumerable:true,
value:scale},

modelViewMatrix:{
value:new Matrix4()},

normalMatrix:{
value:new Matrix3()}});



this.matrix=new Matrix4();
this.matrixWorld=new Matrix4();

this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;
this.matrixWorldNeedsUpdate=false;

this.layers=new Layers();
this.visible=true;

this.castShadow=false;
this.receiveShadow=false;

this.frustumCulled=true;
this.renderOrder=0;

this.userData={};

}

Object3D.DefaultUp=new Vector3(0,1,0);
Object3D.DefaultMatrixAutoUpdate=true;

Object3D.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:Object3D,

isObject3D:true,

onBeforeRender:function onBeforeRender(){},
onAfterRender:function onAfterRender(){},

applyMatrix:function applyMatrix(matrix){

if(this.matrixAutoUpdate)this.updateMatrix();

this.matrix.premultiply(matrix);

this.matrix.decompose(this.position,this.quaternion,this.scale);

},

applyQuaternion:function applyQuaternion(q){

this.quaternion.premultiply(q);

return this;

},

setRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){

// assumes axis is normalized

this.quaternion.setFromAxisAngle(axis,angle);

},

setRotationFromEuler:function setRotationFromEuler(euler){

this.quaternion.setFromEuler(euler,true);

},

setRotationFromMatrix:function setRotationFromMatrix(m){

// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

this.quaternion.setFromRotationMatrix(m);

},

setRotationFromQuaternion:function setRotationFromQuaternion(q){

// assumes q is normalized

this.quaternion.copy(q);

},

rotateOnAxis:function(){

// rotate object on axis in object space
// axis is assumed to be normalized

var q1=new Quaternion();

return function rotateOnAxis(axis,angle){

q1.setFromAxisAngle(axis,angle);

this.quaternion.multiply(q1);

return this;

};

}(),

rotateOnWorldAxis:function(){

// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent

var q1=new Quaternion();

return function rotateOnWorldAxis(axis,angle){

q1.setFromAxisAngle(axis,angle);

this.quaternion.premultiply(q1);

return this;

};

}(),

rotateX:function(){

var v1=new Vector3(1,0,0);

return function rotateX(angle){

return this.rotateOnAxis(v1,angle);

};

}(),

rotateY:function(){

var v1=new Vector3(0,1,0);

return function rotateY(angle){

return this.rotateOnAxis(v1,angle);

};

}(),

rotateZ:function(){

var v1=new Vector3(0,0,1);

return function rotateZ(angle){

return this.rotateOnAxis(v1,angle);

};

}(),

translateOnAxis:function(){

// translate object by distance along axis in object space
// axis is assumed to be normalized

var v1=new Vector3();

return function translateOnAxis(axis,distance){

v1.copy(axis).applyQuaternion(this.quaternion);

this.position.add(v1.multiplyScalar(distance));

return this;

};

}(),

translateX:function(){

var v1=new Vector3(1,0,0);

return function translateX(distance){

return this.translateOnAxis(v1,distance);

};

}(),

translateY:function(){

var v1=new Vector3(0,1,0);

return function translateY(distance){

return this.translateOnAxis(v1,distance);

};

}(),

translateZ:function(){

var v1=new Vector3(0,0,1);

return function translateZ(distance){

return this.translateOnAxis(v1,distance);

};

}(),

localToWorld:function localToWorld(vector){

return vector.applyMatrix4(this.matrixWorld);

},

worldToLocal:function(){

var m1=new Matrix4();

return function worldToLocal(vector){

return vector.applyMatrix4(m1.getInverse(this.matrixWorld));

};

}(),

lookAt:function(){

// This method does not support objects having non-uniformly-scaled parent(s)

var q1=new Quaternion();
var m1=new Matrix4();
var target=new Vector3();
var position=new Vector3();

return function lookAt(x,y,z){

if(x.isVector3){

target.copy(x);

}else{

target.set(x,y,z);

}

var parent=this.parent;

this.updateWorldMatrix(true,false);

position.setFromMatrixPosition(this.matrixWorld);

if(this.isCamera||this.isLight){

m1.lookAt(position,target,this.up);

}else{

m1.lookAt(target,position,this.up);

}

this.quaternion.setFromRotationMatrix(m1);

if(parent){

m1.extractRotation(parent.matrixWorld);
q1.setFromRotationMatrix(m1);
this.quaternion.premultiply(q1.inverse());

}

};

}(),

add:function add(object){

if(arguments.length>1){

for(var i=0;i<arguments.length;i++){

this.add(arguments[i]);

}

return this;

}

if(object===this){

console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);
return this;

}

if(object&&object.isObject3D){

if(object.parent!==null){

object.parent.remove(object);

}

object.parent=this;
object.dispatchEvent({type:'added'});

this.children.push(object);

}else{

console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);

}

return this;

},

remove:function remove(object){

if(arguments.length>1){

for(var i=0;i<arguments.length;i++){

this.remove(arguments[i]);

}

return this;

}

var index=this.children.indexOf(object);

if(index!==-1){

object.parent=null;

object.dispatchEvent({type:'removed'});

this.children.splice(index,1);

}

return this;

},

attach:function(){

// adds object as a child of this, while maintaining the object's world transform

var m=new Matrix4();

return function attach(object){

this.updateWorldMatrix(true,false);

m.getInverse(this.matrixWorld);

if(object.parent!==null){

object.parent.updateWorldMatrix(true,false);

m.multiply(object.parent.matrixWorld);

}

object.applyMatrix(m);

object.updateWorldMatrix(false,false);

this.add(object);

return this;

};

}(),

getObjectById:function getObjectById(id){

return this.getObjectByProperty('id',id);

},

getObjectByName:function getObjectByName(name){

return this.getObjectByProperty('name',name);

},

getObjectByProperty:function getObjectByProperty(name,value){

if(this[name]===value)return this;

for(var i=0,l=this.children.length;i<l;i++){

var child=this.children[i];
var object=child.getObjectByProperty(name,value);

if(object!==undefined){

return object;

}

}

return undefined;

},

getWorldPosition:function getWorldPosition(target){

if(target===undefined){

console.warn('THREE.Object3D: .getWorldPosition() target is now required');
target=new Vector3();

}

this.updateMatrixWorld(true);

return target.setFromMatrixPosition(this.matrixWorld);

},

getWorldQuaternion:function(){

var position=new Vector3();
var scale=new Vector3();

return function getWorldQuaternion(target){

if(target===undefined){

console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
target=new Quaternion();

}

this.updateMatrixWorld(true);

this.matrixWorld.decompose(position,target,scale);

return target;

};

}(),

getWorldScale:function(){

var position=new Vector3();
var quaternion=new Quaternion();

return function getWorldScale(target){

if(target===undefined){

console.warn('THREE.Object3D: .getWorldScale() target is now required');
target=new Vector3();

}

this.updateMatrixWorld(true);

this.matrixWorld.decompose(position,quaternion,target);

return target;

};

}(),

getWorldDirection:function getWorldDirection(target){

if(target===undefined){

console.warn('THREE.Object3D: .getWorldDirection() target is now required');
target=new Vector3();

}

this.updateMatrixWorld(true);

var e=this.matrixWorld.elements;

return target.set(e[8],e[9],e[10]).normalize();

},

raycast:function raycast(){},

traverse:function traverse(callback){

callback(this);

var children=this.children;

for(var i=0,l=children.length;i<l;i++){

children[i].traverse(callback);

}

},

traverseVisible:function traverseVisible(callback){

if(this.visible===false)return;

callback(this);

var children=this.children;

for(var i=0,l=children.length;i<l;i++){

children[i].traverseVisible(callback);

}

},

traverseAncestors:function traverseAncestors(callback){

var parent=this.parent;

if(parent!==null){

callback(parent);

parent.traverseAncestors(callback);

}

},

updateMatrix:function updateMatrix(){

this.matrix.compose(this.position,this.quaternion,this.scale);

this.matrixWorldNeedsUpdate=true;

},

updateMatrixWorld:function updateMatrixWorld(force){

if(this.matrixAutoUpdate)this.updateMatrix();

if(this.matrixWorldNeedsUpdate||force){

if(this.parent===null){

this.matrixWorld.copy(this.matrix);

}else{

this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);

}

this.matrixWorldNeedsUpdate=false;

force=true;

}

// update children

var children=this.children;

for(var i=0,l=children.length;i<l;i++){

children[i].updateMatrixWorld(force);

}

},

updateWorldMatrix:function updateWorldMatrix(updateParents,updateChildren){

var parent=this.parent;

if(updateParents===true&&parent!==null){

parent.updateWorldMatrix(true,false);

}

if(this.matrixAutoUpdate)this.updateMatrix();

if(this.parent===null){

this.matrixWorld.copy(this.matrix);

}else{

this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);

}

// update children

if(updateChildren===true){

var children=this.children;

for(var i=0,l=children.length;i<l;i++){

children[i].updateWorldMatrix(false,true);

}

}

},

toJSON:function toJSON(meta){

// meta is a string when called from JSON.stringify
var isRootObject=meta===undefined||typeof meta==='string';

var output={};

// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){

// initialize meta obj
meta={
geometries:{},
materials:{},
textures:{},
images:{},
shapes:{}};


output.metadata={
version:4.5,
type:'Object',
generator:'Object3D.toJSON'};


}

// standard Object3D serialization

var object={};

object.uuid=this.uuid;
object.type=this.type;

if(this.name!=='')object.name=this.name;
if(this.castShadow===true)object.castShadow=true;
if(this.receiveShadow===true)object.receiveShadow=true;
if(this.visible===false)object.visible=false;
if(this.frustumCulled===false)object.frustumCulled=false;
if(this.renderOrder!==0)object.renderOrder=this.renderOrder;
if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;

object.layers=this.layers.mask;
object.matrix=this.matrix.toArray();

if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;

// object specific properties

if(this.isMesh&&this.drawMode!==TrianglesDrawMode)object.drawMode=this.drawMode;

//

function serialize(library,element){

if(library[element.uuid]===undefined){

library[element.uuid]=element.toJSON(meta);

}

return element.uuid;

}

if(this.isMesh||this.isLine||this.isPoints){

object.geometry=serialize(meta.geometries,this.geometry);

var parameters=this.geometry.parameters;

if(parameters!==undefined&&parameters.shapes!==undefined){

var shapes=parameters.shapes;

if(Array.isArray(shapes)){

for(var i=0,l=shapes.length;i<l;i++){

var shape=shapes[i];

serialize(meta.shapes,shape);

}

}else{

serialize(meta.shapes,shapes);

}

}

}

if(this.material!==undefined){

if(Array.isArray(this.material)){

var uuids=[];

for(var i=0,l=this.material.length;i<l;i++){

uuids.push(serialize(meta.materials,this.material[i]));

}

object.material=uuids;

}else{

object.material=serialize(meta.materials,this.material);

}

}

//

if(this.children.length>0){

object.children=[];

for(var i=0;i<this.children.length;i++){

object.children.push(this.children[i].toJSON(meta).object);

}

}

if(isRootObject){

var geometries=extractFromCache(meta.geometries);
var materials=extractFromCache(meta.materials);
var textures=extractFromCache(meta.textures);
var images=extractFromCache(meta.images);
var shapes=extractFromCache(meta.shapes);

if(geometries.length>0)output.geometries=geometries;
if(materials.length>0)output.materials=materials;
if(textures.length>0)output.textures=textures;
if(images.length>0)output.images=images;
if(shapes.length>0)output.shapes=shapes;

}

output.object=object;

return output;

// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){

var values=[];
for(var key in cache){

var data=cache[key];
delete data.metadata;
values.push(data);

}
return values;

}

},

clone:function clone(recursive){

return new this.constructor().copy(this,recursive);

},

copy:function copy(source,recursive){

if(recursive===undefined)recursive=true;

this.name=source.name;

this.up.copy(source.up);

this.position.copy(source.position);
this.quaternion.copy(source.quaternion);
this.scale.copy(source.scale);

this.matrix.copy(source.matrix);
this.matrixWorld.copy(source.matrixWorld);

this.matrixAutoUpdate=source.matrixAutoUpdate;
this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;

this.layers.mask=source.layers.mask;
this.visible=source.visible;

this.castShadow=source.castShadow;
this.receiveShadow=source.receiveShadow;

this.frustumCulled=source.frustumCulled;
this.renderOrder=source.renderOrder;

this.userData=JSON.parse(JSON.stringify(source.userData));

if(recursive===true){

for(var i=0;i<source.children.length;i++){

var child=source.children[i];
this.add(child.clone());

}

}

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

var geometryId=0;// Geometry uses even numbers as Id

function Geometry(){

Object.defineProperty(this,'id',{value:geometryId+=2});

this.uuid=_Math.generateUUID();

this.name='';
this.type='Geometry';

this.vertices=[];
this.colors=[];
this.faces=[];
this.faceVertexUvs=[[]];

this.morphTargets=[];
this.morphNormals=[];

this.skinWeights=[];
this.skinIndices=[];

this.lineDistances=[];

this.boundingBox=null;
this.boundingSphere=null;

// update flags

this.elementsNeedUpdate=false;
this.verticesNeedUpdate=false;
this.uvsNeedUpdate=false;
this.normalsNeedUpdate=false;
this.colorsNeedUpdate=false;
this.lineDistancesNeedUpdate=false;
this.groupsNeedUpdate=false;

}

Geometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:Geometry,

isGeometry:true,

applyMatrix:function applyMatrix(matrix){

var normalMatrix=new Matrix3().getNormalMatrix(matrix);

for(var i=0,il=this.vertices.length;i<il;i++){

var vertex=this.vertices[i];
vertex.applyMatrix4(matrix);

}

for(var i=0,il=this.faces.length;i<il;i++){

var face=this.faces[i];
face.normal.applyMatrix3(normalMatrix).normalize();

for(var j=0,jl=face.vertexNormals.length;j<jl;j++){

face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();

}

}

if(this.boundingBox!==null){

this.computeBoundingBox();

}

if(this.boundingSphere!==null){

this.computeBoundingSphere();

}

this.verticesNeedUpdate=true;
this.normalsNeedUpdate=true;

return this;

},

rotateX:function(){

// rotate geometry around world x-axis

var m1=new Matrix4();

return function rotateX(angle){

m1.makeRotationX(angle);

this.applyMatrix(m1);

return this;

};

}(),

rotateY:function(){

// rotate geometry around world y-axis

var m1=new Matrix4();

return function rotateY(angle){

m1.makeRotationY(angle);

this.applyMatrix(m1);

return this;

};

}(),

rotateZ:function(){

// rotate geometry around world z-axis

var m1=new Matrix4();

return function rotateZ(angle){

m1.makeRotationZ(angle);

this.applyMatrix(m1);

return this;

};

}(),

translate:function(){

// translate geometry

var m1=new Matrix4();

return function translate(x,y,z){

m1.makeTranslation(x,y,z);

this.applyMatrix(m1);

return this;

};

}(),

scale:function(){

// scale geometry

var m1=new Matrix4();

return function scale(x,y,z){

m1.makeScale(x,y,z);

this.applyMatrix(m1);

return this;

};

}(),

lookAt:function(){

var obj=new Object3D();

return function lookAt(vector){

obj.lookAt(vector);

obj.updateMatrix();

this.applyMatrix(obj.matrix);

};

}(),

fromBufferGeometry:function fromBufferGeometry(geometry){

var scope=this;

var indices=geometry.index!==null?geometry.index.array:undefined;
var attributes=geometry.attributes;

var positions=attributes.position.array;
var normals=attributes.normal!==undefined?attributes.normal.array:undefined;
var colors=attributes.color!==undefined?attributes.color.array:undefined;
var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;
var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;

if(uvs2!==undefined)this.faceVertexUvs[1]=[];

for(var i=0;i<positions.length;i+=3){

scope.vertices.push(new Vector3().fromArray(positions,i));

if(colors!==undefined){

scope.colors.push(new Color().fromArray(colors,i));

}

}

function addFace(a,b,c,materialIndex){

var vertexColors=colors===undefined?[]:[
scope.colors[a].clone(),
scope.colors[b].clone(),
scope.colors[c].clone()];

var vertexNormals=normals===undefined?[]:[
new Vector3().fromArray(normals,a*3),
new Vector3().fromArray(normals,b*3),
new Vector3().fromArray(normals,c*3)];


var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);

scope.faces.push(face);

if(uvs!==undefined){

scope.faceVertexUvs[0].push([
new Vector2().fromArray(uvs,a*2),
new Vector2().fromArray(uvs,b*2),
new Vector2().fromArray(uvs,c*2)]);


}

if(uvs2!==undefined){

scope.faceVertexUvs[1].push([
new Vector2().fromArray(uvs2,a*2),
new Vector2().fromArray(uvs2,b*2),
new Vector2().fromArray(uvs2,c*2)]);


}

}

var groups=geometry.groups;

if(groups.length>0){

for(var i=0;i<groups.length;i++){

var group=groups[i];

var start=group.start;
var count=group.count;

for(var j=start,jl=start+count;j<jl;j+=3){

if(indices!==undefined){

addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);

}else{

addFace(j,j+1,j+2,group.materialIndex);

}

}

}

}else{

if(indices!==undefined){

for(var i=0;i<indices.length;i+=3){

addFace(indices[i],indices[i+1],indices[i+2]);

}

}else{

for(var i=0;i<positions.length/3;i+=3){

addFace(i,i+1,i+2);

}

}

}

this.computeFaceNormals();

if(geometry.boundingBox!==null){

this.boundingBox=geometry.boundingBox.clone();

}

if(geometry.boundingSphere!==null){

this.boundingSphere=geometry.boundingSphere.clone();

}

return this;

},

center:function(){

var offset=new Vector3();

return function center(){

this.computeBoundingBox();

this.boundingBox.getCenter(offset).negate();

this.translate(offset.x,offset.y,offset.z);

return this;

};

}(),

normalize:function normalize(){

this.computeBoundingSphere();

var center=this.boundingSphere.center;
var radius=this.boundingSphere.radius;

var s=radius===0?1:1.0/radius;

var matrix=new Matrix4();
matrix.set(
s,0,0,-s*center.x,
0,s,0,-s*center.y,
0,0,s,-s*center.z,
0,0,0,1);


this.applyMatrix(matrix);

return this;

},

computeFaceNormals:function computeFaceNormals(){

var cb=new Vector3(),ab=new Vector3();

for(var f=0,fl=this.faces.length;f<fl;f++){

var face=this.faces[f];

var vA=this.vertices[face.a];
var vB=this.vertices[face.b];
var vC=this.vertices[face.c];

cb.subVectors(vC,vB);
ab.subVectors(vA,vB);
cb.cross(ab);

cb.normalize();

face.normal.copy(cb);

}

},

computeVertexNormals:function computeVertexNormals(areaWeighted){

if(areaWeighted===undefined)areaWeighted=true;

var v,vl,f,fl,face,vertices;

vertices=new Array(this.vertices.length);

for(v=0,vl=this.vertices.length;v<vl;v++){

vertices[v]=new Vector3();

}

if(areaWeighted){

// vertex normals weighted by triangle areas
// http://www.iquilezles.org/www/articles/normals/normals.htm

var vA,vB,vC;
var cb=new Vector3(),ab=new Vector3();

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

vA=this.vertices[face.a];
vB=this.vertices[face.b];
vC=this.vertices[face.c];

cb.subVectors(vC,vB);
ab.subVectors(vA,vB);
cb.cross(ab);

vertices[face.a].add(cb);
vertices[face.b].add(cb);
vertices[face.c].add(cb);

}

}else{

this.computeFaceNormals();

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

vertices[face.a].add(face.normal);
vertices[face.b].add(face.normal);
vertices[face.c].add(face.normal);

}

}

for(v=0,vl=this.vertices.length;v<vl;v++){

vertices[v].normalize();

}

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

var vertexNormals=face.vertexNormals;

if(vertexNormals.length===3){

vertexNormals[0].copy(vertices[face.a]);
vertexNormals[1].copy(vertices[face.b]);
vertexNormals[2].copy(vertices[face.c]);

}else{

vertexNormals[0]=vertices[face.a].clone();
vertexNormals[1]=vertices[face.b].clone();
vertexNormals[2]=vertices[face.c].clone();

}

}

if(this.faces.length>0){

this.normalsNeedUpdate=true;

}

},

computeFlatVertexNormals:function computeFlatVertexNormals(){

var f,fl,face;

this.computeFaceNormals();

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

var vertexNormals=face.vertexNormals;

if(vertexNormals.length===3){

vertexNormals[0].copy(face.normal);
vertexNormals[1].copy(face.normal);
vertexNormals[2].copy(face.normal);

}else{

vertexNormals[0]=face.normal.clone();
vertexNormals[1]=face.normal.clone();
vertexNormals[2]=face.normal.clone();

}

}

if(this.faces.length>0){

this.normalsNeedUpdate=true;

}

},

computeMorphNormals:function computeMorphNormals(){

var i,il,f,fl,face;

// save original normals
// - create temp variables on first access
//   otherwise just copy (for faster repeated calls)

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

if(!face.__originalFaceNormal){

face.__originalFaceNormal=face.normal.clone();

}else{

face.__originalFaceNormal.copy(face.normal);

}

if(!face.__originalVertexNormals)face.__originalVertexNormals=[];

for(i=0,il=face.vertexNormals.length;i<il;i++){

if(!face.__originalVertexNormals[i]){

face.__originalVertexNormals[i]=face.vertexNormals[i].clone();

}else{

face.__originalVertexNormals[i].copy(face.vertexNormals[i]);

}

}

}

// use temp geometry to compute face and vertex normals for each morph

var tmpGeo=new Geometry();
tmpGeo.faces=this.faces;

for(i=0,il=this.morphTargets.length;i<il;i++){

// create on first access

if(!this.morphNormals[i]){

this.morphNormals[i]={};
this.morphNormals[i].faceNormals=[];
this.morphNormals[i].vertexNormals=[];

var dstNormalsFace=this.morphNormals[i].faceNormals;
var dstNormalsVertex=this.morphNormals[i].vertexNormals;

var faceNormal,vertexNormals;

for(f=0,fl=this.faces.length;f<fl;f++){

faceNormal=new Vector3();
vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};

dstNormalsFace.push(faceNormal);
dstNormalsVertex.push(vertexNormals);

}

}

var morphNormals=this.morphNormals[i];

// set vertices to morph target

tmpGeo.vertices=this.morphTargets[i].vertices;

// compute morph normals

tmpGeo.computeFaceNormals();
tmpGeo.computeVertexNormals();

// store morph normals

var faceNormal,vertexNormals;

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

faceNormal=morphNormals.faceNormals[f];
vertexNormals=morphNormals.vertexNormals[f];

faceNormal.copy(face.normal);

vertexNormals.a.copy(face.vertexNormals[0]);
vertexNormals.b.copy(face.vertexNormals[1]);
vertexNormals.c.copy(face.vertexNormals[2]);

}

}

// restore original normals

for(f=0,fl=this.faces.length;f<fl;f++){

face=this.faces[f];

face.normal=face.__originalFaceNormal;
face.vertexNormals=face.__originalVertexNormals;

}

},

computeBoundingBox:function computeBoundingBox(){

if(this.boundingBox===null){

this.boundingBox=new Box3();

}

this.boundingBox.setFromPoints(this.vertices);

},

computeBoundingSphere:function computeBoundingSphere(){

if(this.boundingSphere===null){

this.boundingSphere=new Sphere();

}

this.boundingSphere.setFromPoints(this.vertices);

},

merge:function merge(geometry,matrix,materialIndexOffset){

if(!(geometry&&geometry.isGeometry)){

console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);
return;

}

var normalMatrix,
vertexOffset=this.vertices.length,
vertices1=this.vertices,
vertices2=geometry.vertices,
faces1=this.faces,
faces2=geometry.faces,
uvs1=this.faceVertexUvs[0],
uvs2=geometry.faceVertexUvs[0],
colors1=this.colors,
colors2=geometry.colors;

if(materialIndexOffset===undefined)materialIndexOffset=0;

if(matrix!==undefined){

normalMatrix=new Matrix3().getNormalMatrix(matrix);

}

// vertices

for(var i=0,il=vertices2.length;i<il;i++){

var vertex=vertices2[i];

var vertexCopy=vertex.clone();

if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);

vertices1.push(vertexCopy);

}

// colors

for(var i=0,il=colors2.length;i<il;i++){

colors1.push(colors2[i].clone());

}

// faces

for(i=0,il=faces2.length;i<il;i++){

var face=faces2[i],faceCopy,normal,color,
faceVertexNormals=face.vertexNormals,
faceVertexColors=face.vertexColors;

faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);
faceCopy.normal.copy(face.normal);

if(normalMatrix!==undefined){

faceCopy.normal.applyMatrix3(normalMatrix).normalize();

}

for(var j=0,jl=faceVertexNormals.length;j<jl;j++){

normal=faceVertexNormals[j].clone();

if(normalMatrix!==undefined){

normal.applyMatrix3(normalMatrix).normalize();

}

faceCopy.vertexNormals.push(normal);

}

faceCopy.color.copy(face.color);

for(var j=0,jl=faceVertexColors.length;j<jl;j++){

color=faceVertexColors[j];
faceCopy.vertexColors.push(color.clone());

}

faceCopy.materialIndex=face.materialIndex+materialIndexOffset;

faces1.push(faceCopy);

}

// uvs

for(i=0,il=uvs2.length;i<il;i++){

var uv=uvs2[i],uvCopy=[];

if(uv===undefined){

continue;

}

for(var j=0,jl=uv.length;j<jl;j++){

uvCopy.push(uv[j].clone());

}

uvs1.push(uvCopy);

}

},

mergeMesh:function mergeMesh(mesh){

if(!(mesh&&mesh.isMesh)){

console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);
return;

}

if(mesh.matrixAutoUpdate)mesh.updateMatrix();

this.merge(mesh.geometry,mesh.matrix);

},

/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

mergeVertices:function mergeVertices(){

var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var unique=[],changes=[];

var v,key;
var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);
var i,il,face;
var indices,j,jl;

for(i=0,il=this.vertices.length;i<il;i++){

v=this.vertices[i];
key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);

if(verticesMap[key]===undefined){

verticesMap[key]=i;
unique.push(this.vertices[i]);
changes[i]=unique.length-1;

}else{

//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
changes[i]=changes[verticesMap[key]];

}

}


// if faces are completely degenerate after merging vertices, we
// have to remove them from the geometry.
var faceIndicesToRemove=[];

for(i=0,il=this.faces.length;i<il;i++){

face=this.faces[i];

face.a=changes[face.a];
face.b=changes[face.b];
face.c=changes[face.c];

indices=[face.a,face.b,face.c];

// if any duplicate vertices are found in a Face3
// we have to remove the face as nothing can be saved
for(var n=0;n<3;n++){

if(indices[n]===indices[(n+1)%3]){

faceIndicesToRemove.push(i);
break;

}

}

}

for(i=faceIndicesToRemove.length-1;i>=0;i--){

var idx=faceIndicesToRemove[i];

this.faces.splice(idx,1);

for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){

this.faceVertexUvs[j].splice(idx,1);

}

}

// Use unique set of vertices

var diff=this.vertices.length-unique.length;
this.vertices=unique;
return diff;

},

setFromPoints:function setFromPoints(points){

this.vertices=[];

for(var i=0,l=points.length;i<l;i++){

var point=points[i];
this.vertices.push(new Vector3(point.x,point.y,point.z||0));

}

return this;

},

sortFacesByMaterialIndex:function sortFacesByMaterialIndex(){

var faces=this.faces;
var length=faces.length;

// tag faces

for(var i=0;i<length;i++){

faces[i]._id=i;

}

// sort faces

function materialIndexSort(a,b){

return a.materialIndex-b.materialIndex;

}

faces.sort(materialIndexSort);

// sort uvs

var uvs1=this.faceVertexUvs[0];
var uvs2=this.faceVertexUvs[1];

var newUvs1,newUvs2;

if(uvs1&&uvs1.length===length)newUvs1=[];
if(uvs2&&uvs2.length===length)newUvs2=[];

for(var i=0;i<length;i++){

var id=faces[i]._id;

if(newUvs1)newUvs1.push(uvs1[id]);
if(newUvs2)newUvs2.push(uvs2[id]);

}

if(newUvs1)this.faceVertexUvs[0]=newUvs1;
if(newUvs2)this.faceVertexUvs[1]=newUvs2;

},

toJSON:function toJSON(){

var data={
metadata:{
version:4.5,
type:'Geometry',
generator:'Geometry.toJSON'}};



// standard Geometry serialization

data.uuid=this.uuid;
data.type=this.type;
if(this.name!=='')data.name=this.name;

if(this.parameters!==undefined){

var parameters=this.parameters;

for(var key in parameters){

if(parameters[key]!==undefined)data[key]=parameters[key];

}

return data;

}

var vertices=[];

for(var i=0;i<this.vertices.length;i++){

var vertex=this.vertices[i];
vertices.push(vertex.x,vertex.y,vertex.z);

}

var faces=[];
var normals=[];
var normalsHash={};
var colors=[];
var colorsHash={};
var uvs=[];
var uvsHash={};

for(var i=0;i<this.faces.length;i++){

var face=this.faces[i];

var hasMaterial=true;
var hasFaceUv=false;// deprecated
var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;
var hasFaceNormal=face.normal.length()>0;
var hasFaceVertexNormal=face.vertexNormals.length>0;
var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;
var hasFaceVertexColor=face.vertexColors.length>0;

var faceType=0;

faceType=setBit(faceType,0,0);// isQuad
faceType=setBit(faceType,1,hasMaterial);
faceType=setBit(faceType,2,hasFaceUv);
faceType=setBit(faceType,3,hasFaceVertexUv);
faceType=setBit(faceType,4,hasFaceNormal);
faceType=setBit(faceType,5,hasFaceVertexNormal);
faceType=setBit(faceType,6,hasFaceColor);
faceType=setBit(faceType,7,hasFaceVertexColor);

faces.push(faceType);
faces.push(face.a,face.b,face.c);
faces.push(face.materialIndex);

if(hasFaceVertexUv){

var faceVertexUvs=this.faceVertexUvs[0][i];

faces.push(
getUvIndex(faceVertexUvs[0]),
getUvIndex(faceVertexUvs[1]),
getUvIndex(faceVertexUvs[2]));


}

if(hasFaceNormal){

faces.push(getNormalIndex(face.normal));

}

if(hasFaceVertexNormal){

var vertexNormals=face.vertexNormals;

faces.push(
getNormalIndex(vertexNormals[0]),
getNormalIndex(vertexNormals[1]),
getNormalIndex(vertexNormals[2]));


}

if(hasFaceColor){

faces.push(getColorIndex(face.color));

}

if(hasFaceVertexColor){

var vertexColors=face.vertexColors;

faces.push(
getColorIndex(vertexColors[0]),
getColorIndex(vertexColors[1]),
getColorIndex(vertexColors[2]));


}

}

function setBit(value,position,enabled){

return enabled?value|1<<position:value&~(1<<position);

}

function getNormalIndex(normal){

var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();

if(normalsHash[hash]!==undefined){

return normalsHash[hash];

}

normalsHash[hash]=normals.length/3;
normals.push(normal.x,normal.y,normal.z);

return normalsHash[hash];

}

function getColorIndex(color){

var hash=color.r.toString()+color.g.toString()+color.b.toString();

if(colorsHash[hash]!==undefined){

return colorsHash[hash];

}

colorsHash[hash]=colors.length;
colors.push(color.getHex());

return colorsHash[hash];

}

function getUvIndex(uv){

var hash=uv.x.toString()+uv.y.toString();

if(uvsHash[hash]!==undefined){

return uvsHash[hash];

}

uvsHash[hash]=uvs.length/2;
uvs.push(uv.x,uv.y);

return uvsHash[hash];

}

data.data={};

data.data.vertices=vertices;
data.data.normals=normals;
if(colors.length>0)data.data.colors=colors;
if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
data.data.faces=faces;

return data;

},

clone:function clone(){

/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

return new Geometry().copy(this);

},

copy:function copy(source){

var i,il,j,jl,k,kl;

// reset

this.vertices=[];
this.colors=[];
this.faces=[];
this.faceVertexUvs=[[]];
this.morphTargets=[];
this.morphNormals=[];
this.skinWeights=[];
this.skinIndices=[];
this.lineDistances=[];
this.boundingBox=null;
this.boundingSphere=null;

// name

this.name=source.name;

// vertices

var vertices=source.vertices;

for(i=0,il=vertices.length;i<il;i++){

this.vertices.push(vertices[i].clone());

}

// colors

var colors=source.colors;

for(i=0,il=colors.length;i<il;i++){

this.colors.push(colors[i].clone());

}

// faces

var faces=source.faces;

for(i=0,il=faces.length;i<il;i++){

this.faces.push(faces[i].clone());

}

// face vertex uvs

for(i=0,il=source.faceVertexUvs.length;i<il;i++){

var faceVertexUvs=source.faceVertexUvs[i];

if(this.faceVertexUvs[i]===undefined){

this.faceVertexUvs[i]=[];

}

for(j=0,jl=faceVertexUvs.length;j<jl;j++){

var uvs=faceVertexUvs[j],uvsCopy=[];

for(k=0,kl=uvs.length;k<kl;k++){

var uv=uvs[k];

uvsCopy.push(uv.clone());

}

this.faceVertexUvs[i].push(uvsCopy);

}

}

// morph targets

var morphTargets=source.morphTargets;

for(i=0,il=morphTargets.length;i<il;i++){

var morphTarget={};
morphTarget.name=morphTargets[i].name;

// vertices

if(morphTargets[i].vertices!==undefined){

morphTarget.vertices=[];

for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){

morphTarget.vertices.push(morphTargets[i].vertices[j].clone());

}

}

// normals

if(morphTargets[i].normals!==undefined){

morphTarget.normals=[];

for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){

morphTarget.normals.push(morphTargets[i].normals[j].clone());

}

}

this.morphTargets.push(morphTarget);

}

// morph normals

var morphNormals=source.morphNormals;

for(i=0,il=morphNormals.length;i<il;i++){

var morphNormal={};

// vertex normals

if(morphNormals[i].vertexNormals!==undefined){

morphNormal.vertexNormals=[];

for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){

var srcVertexNormal=morphNormals[i].vertexNormals[j];
var destVertexNormal={};

destVertexNormal.a=srcVertexNormal.a.clone();
destVertexNormal.b=srcVertexNormal.b.clone();
destVertexNormal.c=srcVertexNormal.c.clone();

morphNormal.vertexNormals.push(destVertexNormal);

}

}

// face normals

if(morphNormals[i].faceNormals!==undefined){

morphNormal.faceNormals=[];

for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){

morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());

}

}

this.morphNormals.push(morphNormal);

}

// skin weights

var skinWeights=source.skinWeights;

for(i=0,il=skinWeights.length;i<il;i++){

this.skinWeights.push(skinWeights[i].clone());

}

// skin indices

var skinIndices=source.skinIndices;

for(i=0,il=skinIndices.length;i<il;i++){

this.skinIndices.push(skinIndices[i].clone());

}

// line distances

var lineDistances=source.lineDistances;

for(i=0,il=lineDistances.length;i<il;i++){

this.lineDistances.push(lineDistances[i]);

}

// bounding box

var boundingBox=source.boundingBox;

if(boundingBox!==null){

this.boundingBox=boundingBox.clone();

}

// bounding sphere

var boundingSphere=source.boundingSphere;

if(boundingSphere!==null){

this.boundingSphere=boundingSphere.clone();

}

// update flags

this.elementsNeedUpdate=source.elementsNeedUpdate;
this.verticesNeedUpdate=source.verticesNeedUpdate;
this.uvsNeedUpdate=source.uvsNeedUpdate;
this.normalsNeedUpdate=source.normalsNeedUpdate;
this.colorsNeedUpdate=source.colorsNeedUpdate;
this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;
this.groupsNeedUpdate=source.groupsNeedUpdate;

return this;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute(array,itemSize,normalized){

if(Array.isArray(array)){

throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

}

this.name='';

this.array=array;
this.itemSize=itemSize;
this.count=array!==undefined?array.length/itemSize:0;
this.normalized=normalized===true;

this.dynamic=false;
this.updateRange={offset:0,count:-1};

this.version=0;

}

Object.defineProperty(BufferAttribute.prototype,'needsUpdate',{

set:function set(value){

if(value===true)this.version++;

}});



Object.assign(BufferAttribute.prototype,{

isBufferAttribute:true,

onUploadCallback:function onUploadCallback(){},

setArray:function setArray(array){

if(Array.isArray(array)){

throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

}

this.count=array!==undefined?array.length/this.itemSize:0;
this.array=array;

return this;

},

setDynamic:function setDynamic(value){

this.dynamic=value;

return this;

},

copy:function copy(source){

this.name=source.name;
this.array=new source.array.constructor(source.array);
this.itemSize=source.itemSize;
this.count=source.count;
this.normalized=source.normalized;

this.dynamic=source.dynamic;

return this;

},

copyAt:function copyAt(index1,attribute,index2){

index1*=this.itemSize;
index2*=attribute.itemSize;

for(var i=0,l=this.itemSize;i<l;i++){

this.array[index1+i]=attribute.array[index2+i];

}

return this;

},

copyArray:function copyArray(array){

this.array.set(array);

return this;

},

copyColorsArray:function copyColorsArray(colors){

var array=this.array,offset=0;

for(var i=0,l=colors.length;i<l;i++){

var color=colors[i];

if(color===undefined){

console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);
color=new Color();

}

array[offset++]=color.r;
array[offset++]=color.g;
array[offset++]=color.b;

}

return this;

},

copyVector2sArray:function copyVector2sArray(vectors){

var array=this.array,offset=0;

for(var i=0,l=vectors.length;i<l;i++){

var vector=vectors[i];

if(vector===undefined){

console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);
vector=new Vector2();

}

array[offset++]=vector.x;
array[offset++]=vector.y;

}

return this;

},

copyVector3sArray:function copyVector3sArray(vectors){

var array=this.array,offset=0;

for(var i=0,l=vectors.length;i<l;i++){

var vector=vectors[i];

if(vector===undefined){

console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);
vector=new Vector3();

}

array[offset++]=vector.x;
array[offset++]=vector.y;
array[offset++]=vector.z;

}

return this;

},

copyVector4sArray:function copyVector4sArray(vectors){

var array=this.array,offset=0;

for(var i=0,l=vectors.length;i<l;i++){

var vector=vectors[i];

if(vector===undefined){

console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);
vector=new Vector4();

}

array[offset++]=vector.x;
array[offset++]=vector.y;
array[offset++]=vector.z;
array[offset++]=vector.w;

}

return this;

},

set:function set(value,offset){

if(offset===undefined)offset=0;

this.array.set(value,offset);

return this;

},

getX:function getX(index){

return this.array[index*this.itemSize];

},

setX:function setX(index,x){

this.array[index*this.itemSize]=x;

return this;

},

getY:function getY(index){

return this.array[index*this.itemSize+1];

},

setY:function setY(index,y){

this.array[index*this.itemSize+1]=y;

return this;

},

getZ:function getZ(index){

return this.array[index*this.itemSize+2];

},

setZ:function setZ(index,z){

this.array[index*this.itemSize+2]=z;

return this;

},

getW:function getW(index){

return this.array[index*this.itemSize+3];

},

setW:function setW(index,w){

this.array[index*this.itemSize+3]=w;

return this;

},

setXY:function setXY(index,x,y){

index*=this.itemSize;

this.array[index+0]=x;
this.array[index+1]=y;

return this;

},

setXYZ:function setXYZ(index,x,y,z){

index*=this.itemSize;

this.array[index+0]=x;
this.array[index+1]=y;
this.array[index+2]=z;

return this;

},

setXYZW:function setXYZW(index,x,y,z,w){

index*=this.itemSize;

this.array[index+0]=x;
this.array[index+1]=y;
this.array[index+2]=z;
this.array[index+3]=w;

return this;

},

onUpload:function onUpload(callback){

this.onUploadCallback=callback;

return this;

},

clone:function clone(){

return new this.constructor(this.array,this.itemSize).copy(this);

},

toJSON:function toJSON(){

return{
itemSize:this.itemSize,
type:this.array.constructor.name,
array:Array.prototype.slice.call(this.array),
normalized:this.normalized};


}});



//

function Int8BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Int8Array(array),itemSize,normalized);

}

Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;


function Uint8BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Uint8Array(array),itemSize,normalized);

}

Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;


function Uint8ClampedBufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize,normalized);

}

Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;


function Int16BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Int16Array(array),itemSize,normalized);

}

Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;


function Uint16BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Uint16Array(array),itemSize,normalized);

}

Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;


function Int32BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Int32Array(array),itemSize,normalized);

}

Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;


function Uint32BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Uint32Array(array),itemSize,normalized);

}

Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;


function Float32BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Float32Array(array),itemSize,normalized);

}

Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;


function Float64BufferAttribute(array,itemSize,normalized){

BufferAttribute.call(this,new Float64Array(array),itemSize,normalized);

}

Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry(){

this.vertices=[];
this.normals=[];
this.colors=[];
this.uvs=[];
this.uvs2=[];

this.groups=[];

this.morphTargets={};

this.skinWeights=[];
this.skinIndices=[];

// this.lineDistances = [];

this.boundingBox=null;
this.boundingSphere=null;

// update flags

this.verticesNeedUpdate=false;
this.normalsNeedUpdate=false;
this.colorsNeedUpdate=false;
this.uvsNeedUpdate=false;
this.groupsNeedUpdate=false;

}

Object.assign(DirectGeometry.prototype,{

computeGroups:function computeGroups(geometry){

var group;
var groups=[];
var materialIndex=undefined;

var faces=geometry.faces;

for(var i=0;i<faces.length;i++){

var face=faces[i];

// materials

if(face.materialIndex!==materialIndex){

materialIndex=face.materialIndex;

if(group!==undefined){

group.count=i*3-group.start;
groups.push(group);

}

group={
start:i*3,
materialIndex:materialIndex};


}

}

if(group!==undefined){

group.count=i*3-group.start;
groups.push(group);

}

this.groups=groups;

},

fromGeometry:function fromGeometry(geometry){

var faces=geometry.faces;
var vertices=geometry.vertices;
var faceVertexUvs=geometry.faceVertexUvs;

var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;
var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;

// morphs

var morphTargets=geometry.morphTargets;
var morphTargetsLength=morphTargets.length;

var morphTargetsPosition;

if(morphTargetsLength>0){

morphTargetsPosition=[];

for(var i=0;i<morphTargetsLength;i++){

morphTargetsPosition[i]={
name:morphTargets[i].name,
data:[]};


}

this.morphTargets.position=morphTargetsPosition;

}

var morphNormals=geometry.morphNormals;
var morphNormalsLength=morphNormals.length;

var morphTargetsNormal;

if(morphNormalsLength>0){

morphTargetsNormal=[];

for(var i=0;i<morphNormalsLength;i++){

morphTargetsNormal[i]={
name:morphNormals[i].name,
data:[]};


}

this.morphTargets.normal=morphTargetsNormal;

}

// skins

var skinIndices=geometry.skinIndices;
var skinWeights=geometry.skinWeights;

var hasSkinIndices=skinIndices.length===vertices.length;
var hasSkinWeights=skinWeights.length===vertices.length;

//

if(vertices.length>0&&faces.length===0){

console.error('THREE.DirectGeometry: Faceless geometries are not supported.');

}

for(var i=0;i<faces.length;i++){

var face=faces[i];

this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);

var vertexNormals=face.vertexNormals;

if(vertexNormals.length===3){

this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);

}else{

var normal=face.normal;

this.normals.push(normal,normal,normal);

}

var vertexColors=face.vertexColors;

if(vertexColors.length===3){

this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);

}else{

var color=face.color;

this.colors.push(color,color,color);

}

if(hasFaceVertexUv===true){

var vertexUvs=faceVertexUvs[0][i];

if(vertexUvs!==undefined){

this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);

}else{

console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);

this.uvs.push(new Vector2(),new Vector2(),new Vector2());

}

}

if(hasFaceVertexUv2===true){

var vertexUvs=faceVertexUvs[1][i];

if(vertexUvs!==undefined){

this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);

}else{

console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);

this.uvs2.push(new Vector2(),new Vector2(),new Vector2());

}

}

// morphs

for(var j=0;j<morphTargetsLength;j++){

var morphTarget=morphTargets[j].vertices;

morphTargetsPosition[j].data.push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);

}

for(var j=0;j<morphNormalsLength;j++){

var morphNormal=morphNormals[j].vertexNormals[i];

morphTargetsNormal[j].data.push(morphNormal.a,morphNormal.b,morphNormal.c);

}

// skins

if(hasSkinIndices){

this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);

}

if(hasSkinWeights){

this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);

}

}

this.computeGroups(geometry);

this.verticesNeedUpdate=geometry.verticesNeedUpdate;
this.normalsNeedUpdate=geometry.normalsNeedUpdate;
this.colorsNeedUpdate=geometry.colorsNeedUpdate;
this.uvsNeedUpdate=geometry.uvsNeedUpdate;
this.groupsNeedUpdate=geometry.groupsNeedUpdate;

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax(array){

if(array.length===0)return-Infinity;

var max=array[0];

for(var i=1,l=array.length;i<l;++i){

if(array[i]>max)max=array[i];

}

return max;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var bufferGeometryId=1;// BufferGeometry uses odd numbers as Id

function BufferGeometry(){

Object.defineProperty(this,'id',{value:bufferGeometryId+=2});

this.uuid=_Math.generateUUID();

this.name='';
this.type='BufferGeometry';

this.index=null;
this.attributes={};

this.morphAttributes={};

this.groups=[];

this.boundingBox=null;
this.boundingSphere=null;

this.drawRange={start:0,count:Infinity};

this.userData={};

}

BufferGeometry.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:BufferGeometry,

isBufferGeometry:true,

getIndex:function getIndex(){

return this.index;

},

setIndex:function setIndex(index){

if(Array.isArray(index)){

this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);

}else{

this.index=index;

}

},

addAttribute:function addAttribute(name,attribute){

if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){

console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

return this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));

}

if(name==='index'){

console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
this.setIndex(attribute);

return this;

}

this.attributes[name]=attribute;

return this;

},

getAttribute:function getAttribute(name){

return this.attributes[name];

},

removeAttribute:function removeAttribute(name){

delete this.attributes[name];

return this;

},

addGroup:function addGroup(start,count,materialIndex){

this.groups.push({

start:start,
count:count,
materialIndex:materialIndex!==undefined?materialIndex:0});



},

clearGroups:function clearGroups(){

this.groups=[];

},

setDrawRange:function setDrawRange(start,count){

this.drawRange.start=start;
this.drawRange.count=count;

},

applyMatrix:function applyMatrix(matrix){

var position=this.attributes.position;

if(position!==undefined){

matrix.applyToBufferAttribute(position);
position.needsUpdate=true;

}

var normal=this.attributes.normal;

if(normal!==undefined){

var normalMatrix=new Matrix3().getNormalMatrix(matrix);

normalMatrix.applyToBufferAttribute(normal);
normal.needsUpdate=true;

}

var tangent=this.attributes.tangent;

if(tangent!==undefined){

var normalMatrix=new Matrix3().getNormalMatrix(matrix);

// Tangent is vec4, but the '.w' component is a sign value (+1/-1).
normalMatrix.applyToBufferAttribute(tangent);
tangent.needsUpdate=true;

}

if(this.boundingBox!==null){

this.computeBoundingBox();

}

if(this.boundingSphere!==null){

this.computeBoundingSphere();

}

return this;

},

rotateX:function(){

// rotate geometry around world x-axis

var m1=new Matrix4();

return function rotateX(angle){

m1.makeRotationX(angle);

this.applyMatrix(m1);

return this;

};

}(),

rotateY:function(){

// rotate geometry around world y-axis

var m1=new Matrix4();

return function rotateY(angle){

m1.makeRotationY(angle);

this.applyMatrix(m1);

return this;

};

}(),

rotateZ:function(){

// rotate geometry around world z-axis

var m1=new Matrix4();

return function rotateZ(angle){

m1.makeRotationZ(angle);

this.applyMatrix(m1);

return this;

};

}(),

translate:function(){

// translate geometry

var m1=new Matrix4();

return function translate(x,y,z){

m1.makeTranslation(x,y,z);

this.applyMatrix(m1);

return this;

};

}(),

scale:function(){

// scale geometry

var m1=new Matrix4();

return function scale(x,y,z){

m1.makeScale(x,y,z);

this.applyMatrix(m1);

return this;

};

}(),

lookAt:function(){

var obj=new Object3D();

return function lookAt(vector){

obj.lookAt(vector);

obj.updateMatrix();

this.applyMatrix(obj.matrix);

};

}(),

center:function(){

var offset=new Vector3();

return function center(){

this.computeBoundingBox();

this.boundingBox.getCenter(offset).negate();

this.translate(offset.x,offset.y,offset.z);

return this;

};

}(),

setFromObject:function setFromObject(object){

// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

var geometry=object.geometry;

if(object.isPoints||object.isLine){

var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);
var colors=new Float32BufferAttribute(geometry.colors.length*3,3);

this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));
this.addAttribute('color',colors.copyColorsArray(geometry.colors));

if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){

var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);

this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));

}

if(geometry.boundingSphere!==null){

this.boundingSphere=geometry.boundingSphere.clone();

}

if(geometry.boundingBox!==null){

this.boundingBox=geometry.boundingBox.clone();

}

}else if(object.isMesh){

if(geometry&&geometry.isGeometry){

this.fromGeometry(geometry);

}

}

return this;

},

setFromPoints:function setFromPoints(points){

var position=[];

for(var i=0,l=points.length;i<l;i++){

var point=points[i];
position.push(point.x,point.y,point.z||0);

}

this.addAttribute('position',new Float32BufferAttribute(position,3));

return this;

},

updateFromObject:function updateFromObject(object){

var geometry=object.geometry;

if(object.isMesh){

var direct=geometry.__directGeometry;

if(geometry.elementsNeedUpdate===true){

direct=undefined;
geometry.elementsNeedUpdate=false;

}

if(direct===undefined){

return this.fromGeometry(geometry);

}

direct.verticesNeedUpdate=geometry.verticesNeedUpdate;
direct.normalsNeedUpdate=geometry.normalsNeedUpdate;
direct.colorsNeedUpdate=geometry.colorsNeedUpdate;
direct.uvsNeedUpdate=geometry.uvsNeedUpdate;
direct.groupsNeedUpdate=geometry.groupsNeedUpdate;

geometry.verticesNeedUpdate=false;
geometry.normalsNeedUpdate=false;
geometry.colorsNeedUpdate=false;
geometry.uvsNeedUpdate=false;
geometry.groupsNeedUpdate=false;

geometry=direct;

}

var attribute;

if(geometry.verticesNeedUpdate===true){

attribute=this.attributes.position;

if(attribute!==undefined){

attribute.copyVector3sArray(geometry.vertices);
attribute.needsUpdate=true;

}

geometry.verticesNeedUpdate=false;

}

if(geometry.normalsNeedUpdate===true){

attribute=this.attributes.normal;

if(attribute!==undefined){

attribute.copyVector3sArray(geometry.normals);
attribute.needsUpdate=true;

}

geometry.normalsNeedUpdate=false;

}

if(geometry.colorsNeedUpdate===true){

attribute=this.attributes.color;

if(attribute!==undefined){

attribute.copyColorsArray(geometry.colors);
attribute.needsUpdate=true;

}

geometry.colorsNeedUpdate=false;

}

if(geometry.uvsNeedUpdate){

attribute=this.attributes.uv;

if(attribute!==undefined){

attribute.copyVector2sArray(geometry.uvs);
attribute.needsUpdate=true;

}

geometry.uvsNeedUpdate=false;

}

if(geometry.lineDistancesNeedUpdate){

attribute=this.attributes.lineDistance;

if(attribute!==undefined){

attribute.copyArray(geometry.lineDistances);
attribute.needsUpdate=true;

}

geometry.lineDistancesNeedUpdate=false;

}

if(geometry.groupsNeedUpdate){

geometry.computeGroups(object.geometry);
this.groups=geometry.groups;

geometry.groupsNeedUpdate=false;

}

return this;

},

fromGeometry:function fromGeometry(geometry){

geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);

return this.fromDirectGeometry(geometry.__directGeometry);

},

fromDirectGeometry:function fromDirectGeometry(geometry){

var positions=new Float32Array(geometry.vertices.length*3);
this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));

if(geometry.normals.length>0){

var normals=new Float32Array(geometry.normals.length*3);
this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));

}

if(geometry.colors.length>0){

var colors=new Float32Array(geometry.colors.length*3);
this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));

}

if(geometry.uvs.length>0){

var uvs=new Float32Array(geometry.uvs.length*2);
this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));

}

if(geometry.uvs2.length>0){

var uvs2=new Float32Array(geometry.uvs2.length*2);
this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));

}

// groups

this.groups=geometry.groups;

// morphs

for(var name in geometry.morphTargets){

var array=[];
var morphTargets=geometry.morphTargets[name];

for(var i=0,l=morphTargets.length;i<l;i++){

var morphTarget=morphTargets[i];

var attribute=new Float32BufferAttribute(morphTarget.data.length*3,3);
attribute.name=morphTarget.name;

array.push(attribute.copyVector3sArray(morphTarget.data));

}

this.morphAttributes[name]=array;

}

// skinning

if(geometry.skinIndices.length>0){

var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);
this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));

}

if(geometry.skinWeights.length>0){

var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);
this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));

}

//

if(geometry.boundingSphere!==null){

this.boundingSphere=geometry.boundingSphere.clone();

}

if(geometry.boundingBox!==null){

this.boundingBox=geometry.boundingBox.clone();

}

return this;

},

computeBoundingBox:function(){

var box=new Box3();

return function computeBoundingBox(){

if(this.boundingBox===null){

this.boundingBox=new Box3();

}

var position=this.attributes.position;
var morphAttributesPosition=this.morphAttributes.position;

if(position!==undefined){

this.boundingBox.setFromBufferAttribute(position);

// process morph attributes if present

if(morphAttributesPosition){

for(var i=0,il=morphAttributesPosition.length;i<il;i++){

var morphAttribute=morphAttributesPosition[i];
box.setFromBufferAttribute(morphAttribute);

this.boundingBox.expandByPoint(box.min);
this.boundingBox.expandByPoint(box.max);

}

}

}else{

this.boundingBox.makeEmpty();

}

if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){

console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);

}

};

}(),

computeBoundingSphere:function(){

var box=new Box3();
var boxMorphTargets=new Box3();
var vector=new Vector3();

return function computeBoundingSphere(){

if(this.boundingSphere===null){

this.boundingSphere=new Sphere();

}

var position=this.attributes.position;
var morphAttributesPosition=this.morphAttributes.position;

if(position){

// first, find the center of the bounding sphere

var center=this.boundingSphere.center;

box.setFromBufferAttribute(position);

// process morph attributes if present

if(morphAttributesPosition){

for(var i=0,il=morphAttributesPosition.length;i<il;i++){

var morphAttribute=morphAttributesPosition[i];
boxMorphTargets.setFromBufferAttribute(morphAttribute);

box.expandByPoint(boxMorphTargets.min);
box.expandByPoint(boxMorphTargets.max);

}

}

box.getCenter(center);

// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

var maxRadiusSq=0;

for(var i=0,il=position.count;i<il;i++){

vector.fromBufferAttribute(position,i);

maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));

}

// process morph attributes if present

if(morphAttributesPosition){

for(var i=0,il=morphAttributesPosition.length;i<il;i++){

var morphAttribute=morphAttributesPosition[i];

for(var j=0,jl=morphAttribute.count;j<jl;j++){

vector.fromBufferAttribute(morphAttribute,j);

maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));

}

}

}

this.boundingSphere.radius=Math.sqrt(maxRadiusSq);

if(isNaN(this.boundingSphere.radius)){

console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);

}

}

};

}(),

computeFaceNormals:function computeFaceNormals(){

// backwards compatibility

},

computeVertexNormals:function computeVertexNormals(){

var index=this.index;
var attributes=this.attributes;

if(attributes.position){

var positions=attributes.position.array;

if(attributes.normal===undefined){

this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));

}else{

// reset existing normals to zero

var array=attributes.normal.array;

for(var i=0,il=array.length;i<il;i++){

array[i]=0;

}

}

var normals=attributes.normal.array;

var vA,vB,vC;
var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();
var cb=new Vector3(),ab=new Vector3();

// indexed elements

if(index){

var indices=index.array;

for(var i=0,il=index.count;i<il;i+=3){

vA=indices[i+0]*3;
vB=indices[i+1]*3;
vC=indices[i+2]*3;

pA.fromArray(positions,vA);
pB.fromArray(positions,vB);
pC.fromArray(positions,vC);

cb.subVectors(pC,pB);
ab.subVectors(pA,pB);
cb.cross(ab);

normals[vA]+=cb.x;
normals[vA+1]+=cb.y;
normals[vA+2]+=cb.z;

normals[vB]+=cb.x;
normals[vB+1]+=cb.y;
normals[vB+2]+=cb.z;

normals[vC]+=cb.x;
normals[vC+1]+=cb.y;
normals[vC+2]+=cb.z;

}

}else{

// non-indexed elements (unconnected triangle soup)

for(var i=0,il=positions.length;i<il;i+=9){

pA.fromArray(positions,i);
pB.fromArray(positions,i+3);
pC.fromArray(positions,i+6);

cb.subVectors(pC,pB);
ab.subVectors(pA,pB);
cb.cross(ab);

normals[i]=cb.x;
normals[i+1]=cb.y;
normals[i+2]=cb.z;

normals[i+3]=cb.x;
normals[i+4]=cb.y;
normals[i+5]=cb.z;

normals[i+6]=cb.x;
normals[i+7]=cb.y;
normals[i+8]=cb.z;

}

}

this.normalizeNormals();

attributes.normal.needsUpdate=true;

}

},

merge:function merge(geometry,offset){

if(!(geometry&&geometry.isBufferGeometry)){

console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);
return;

}

if(offset===undefined){

offset=0;

console.warn(
'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+
'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');


}

var attributes=this.attributes;

for(var key in attributes){

if(geometry.attributes[key]===undefined)continue;

var attribute1=attributes[key];
var attributeArray1=attribute1.array;

var attribute2=geometry.attributes[key];
var attributeArray2=attribute2.array;

var attributeOffset=attribute2.itemSize*offset;
var length=Math.min(attributeArray2.length,attributeArray1.length-attributeOffset);

for(var i=0,j=attributeOffset;i<length;i++,j++){

attributeArray1[j]=attributeArray2[i];

}

}

return this;

},

normalizeNormals:function(){

var vector=new Vector3();

return function normalizeNormals(){

var normals=this.attributes.normal;

for(var i=0,il=normals.count;i<il;i++){

vector.x=normals.getX(i);
vector.y=normals.getY(i);
vector.z=normals.getZ(i);

vector.normalize();

normals.setXYZ(i,vector.x,vector.y,vector.z);

}

};

}(),

toNonIndexed:function toNonIndexed(){

function convertBufferAttribute(attribute,indices){

var array=attribute.array;
var itemSize=attribute.itemSize;

var array2=new array.constructor(indices.length*itemSize);

var index=0,index2=0;

for(var i=0,l=indices.length;i<l;i++){

index=indices[i]*itemSize;

for(var j=0;j<itemSize;j++){

array2[index2++]=array[index++];

}

}

return new BufferAttribute(array2,itemSize);

}

//

if(this.index===null){

console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
return this;

}

var geometry2=new BufferGeometry();

var indices=this.index.array;
var attributes=this.attributes;

// attributes

for(var name in attributes){

var attribute=attributes[name];

var newAttribute=convertBufferAttribute(attribute,indices);

geometry2.addAttribute(name,newAttribute);

}

// morph attributes

var morphAttributes=this.morphAttributes;

for(name in morphAttributes){

var morphArray=[];
var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes

for(var i=0,il=morphAttribute.length;i<il;i++){

var attribute=morphAttribute[i];

var newAttribute=convertBufferAttribute(attribute,indices);

morphArray.push(newAttribute);

}

geometry2.morphAttributes[name]=morphArray;

}

// groups

var groups=this.groups;

for(var i=0,l=groups.length;i<l;i++){

var group=groups[i];
geometry2.addGroup(group.start,group.count,group.materialIndex);

}

return geometry2;

},

toJSON:function toJSON(){

var data={
metadata:{
version:4.5,
type:'BufferGeometry',
generator:'BufferGeometry.toJSON'}};



// standard BufferGeometry serialization

data.uuid=this.uuid;
data.type=this.type;
if(this.name!=='')data.name=this.name;
if(Object.keys(this.userData).length>0)data.userData=this.userData;

if(this.parameters!==undefined){

var parameters=this.parameters;

for(var key in parameters){

if(parameters[key]!==undefined)data[key]=parameters[key];

}

return data;

}

data.data={attributes:{}};

var index=this.index;

if(index!==null){

data.data.index={
type:index.array.constructor.name,
array:Array.prototype.slice.call(index.array)};


}

var attributes=this.attributes;

for(var key in attributes){

var attribute=attributes[key];

var attributeData=attribute.toJSON();

if(attribute.name!=='')attributeData.name=attribute.name;

data.data.attributes[key]=attributeData;

}

var morphAttributes={};
var hasMorphAttributes=false;

for(var key in this.morphAttributes){

var attributeArray=this.morphAttributes[key];

var array=[];

for(var i=0,il=attributeArray.length;i<il;i++){

var attribute=attributeArray[i];

var attributeData=attribute.toJSON();

if(attribute.name!=='')attributeData.name=attribute.name;

array.push(attributeData);

}

if(array.length>0){

morphAttributes[key]=array;

hasMorphAttributes=true;

}

}

if(hasMorphAttributes)data.data.morphAttributes=morphAttributes;

var groups=this.groups;

if(groups.length>0){

data.data.groups=JSON.parse(JSON.stringify(groups));

}

var boundingSphere=this.boundingSphere;

if(boundingSphere!==null){

data.data.boundingSphere={
center:boundingSphere.center.toArray(),
radius:boundingSphere.radius};


}

return data;

},

clone:function clone(){

/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

return new BufferGeometry().copy(this);

},

copy:function copy(source){

var name,i,l;

// reset

this.index=null;
this.attributes={};
this.morphAttributes={};
this.groups=[];
this.boundingBox=null;
this.boundingSphere=null;

// name

this.name=source.name;

// index

var index=source.index;

if(index!==null){

this.setIndex(index.clone());

}

// attributes

var attributes=source.attributes;

for(name in attributes){

var attribute=attributes[name];
this.addAttribute(name,attribute.clone());

}

// morph attributes

var morphAttributes=source.morphAttributes;

for(name in morphAttributes){

var array=[];
var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes

for(i=0,l=morphAttribute.length;i<l;i++){

array.push(morphAttribute[i].clone());

}

this.morphAttributes[name]=array;

}

// groups

var groups=source.groups;

for(i=0,l=groups.length;i<l;i++){

var group=groups[i];
this.addGroup(group.start,group.count,group.materialIndex);

}

// bounding box

var boundingBox=source.boundingBox;

if(boundingBox!==null){

this.boundingBox=boundingBox.clone();

}

// bounding sphere

var boundingSphere=source.boundingSphere;

if(boundingSphere!==null){

this.boundingSphere=boundingSphere.clone();

}

// draw range

this.drawRange.start=source.drawRange.start;
this.drawRange.count=source.drawRange.count;

// user data

this.userData=source.userData;

return this;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// BoxGeometry

function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){

Geometry.call(this);

this.type='BoxGeometry';

this.parameters={
width:width,
height:height,
depth:depth,
widthSegments:widthSegments,
heightSegments:heightSegments,
depthSegments:depthSegments};


this.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));
this.mergeVertices();

}

BoxGeometry.prototype=Object.create(Geometry.prototype);
BoxGeometry.prototype.constructor=BoxGeometry;

// BoxBufferGeometry

function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){

BufferGeometry.call(this);

this.type='BoxBufferGeometry';

this.parameters={
width:width,
height:height,
depth:depth,
widthSegments:widthSegments,
heightSegments:heightSegments,
depthSegments:depthSegments};


var scope=this;

width=width||1;
height=height||1;
depth=depth||1;

// segments

widthSegments=Math.floor(widthSegments)||1;
heightSegments=Math.floor(heightSegments)||1;
depthSegments=Math.floor(depthSegments)||1;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var numberOfVertices=0;
var groupStart=0;

// build each side of the box geometry

buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){

var segmentWidth=width/gridX;
var segmentHeight=height/gridY;

var widthHalf=width/2;
var heightHalf=height/2;
var depthHalf=depth/2;

var gridX1=gridX+1;
var gridY1=gridY+1;

var vertexCounter=0;
var groupCount=0;

var ix,iy;

var vector=new Vector3();

// generate vertices, normals and uvs

for(iy=0;iy<gridY1;iy++){

var y=iy*segmentHeight-heightHalf;

for(ix=0;ix<gridX1;ix++){

var x=ix*segmentWidth-widthHalf;

// set values to correct vector component

vector[u]=x*udir;
vector[v]=y*vdir;
vector[w]=depthHalf;

// now apply vector to vertex buffer

vertices.push(vector.x,vector.y,vector.z);

// set values to correct vector component

vector[u]=0;
vector[v]=0;
vector[w]=depth>0?1:-1;

// now apply vector to normal buffer

normals.push(vector.x,vector.y,vector.z);

// uvs

uvs.push(ix/gridX);
uvs.push(1-iy/gridY);

// counters

vertexCounter+=1;

}

}

// indices

// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment

for(iy=0;iy<gridY;iy++){

for(ix=0;ix<gridX;ix++){

var a=numberOfVertices+ix+gridX1*iy;
var b=numberOfVertices+ix+gridX1*(iy+1);
var c=numberOfVertices+(ix+1)+gridX1*(iy+1);
var d=numberOfVertices+(ix+1)+gridX1*iy;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

// increase counter

groupCount+=6;

}

}

// add a group to the geometry. this will ensure multi material support

scope.addGroup(groupStart,groupCount,materialIndex);

// calculate new start value for groups

groupStart+=groupCount;

// update total number of vertices

numberOfVertices+=vertexCounter;

}

}

BoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// PlaneGeometry

function PlaneGeometry(width,height,widthSegments,heightSegments){

Geometry.call(this);

this.type='PlaneGeometry';

this.parameters={
width:width,
height:height,
widthSegments:widthSegments,
heightSegments:heightSegments};


this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));
this.mergeVertices();

}

PlaneGeometry.prototype=Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor=PlaneGeometry;

// PlaneBufferGeometry

function PlaneBufferGeometry(width,height,widthSegments,heightSegments){

BufferGeometry.call(this);

this.type='PlaneBufferGeometry';

this.parameters={
width:width,
height:height,
widthSegments:widthSegments,
heightSegments:heightSegments};


width=width||1;
height=height||1;

var width_half=width/2;
var height_half=height/2;

var gridX=Math.floor(widthSegments)||1;
var gridY=Math.floor(heightSegments)||1;

var gridX1=gridX+1;
var gridY1=gridY+1;

var segment_width=width/gridX;
var segment_height=height/gridY;

var ix,iy;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// generate vertices, normals and uvs

for(iy=0;iy<gridY1;iy++){

var y=iy*segment_height-height_half;

for(ix=0;ix<gridX1;ix++){

var x=ix*segment_width-width_half;

vertices.push(x,-y,0);

normals.push(0,0,1);

uvs.push(ix/gridX);
uvs.push(1-iy/gridY);

}

}

// indices

for(iy=0;iy<gridY;iy++){

for(ix=0;ix<gridX;ix++){

var a=ix+gridX1*iy;
var b=ix+gridX1*(iy+1);
var c=ix+1+gridX1*(iy+1);
var d=ix+1+gridX1*iy;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId=0;

function Material(){

Object.defineProperty(this,'id',{value:materialId++});

this.uuid=_Math.generateUUID();

this.name='';
this.type='Material';

this.fog=true;
this.lights=true;

this.blending=NormalBlending;
this.side=FrontSide;
this.flatShading=false;
this.vertexTangents=false;
this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors

this.opacity=1;
this.transparent=false;

this.blendSrc=SrcAlphaFactor;
this.blendDst=OneMinusSrcAlphaFactor;
this.blendEquation=AddEquation;
this.blendSrcAlpha=null;
this.blendDstAlpha=null;
this.blendEquationAlpha=null;

this.depthFunc=LessEqualDepth;
this.depthTest=true;
this.depthWrite=true;

this.clippingPlanes=null;
this.clipIntersection=false;
this.clipShadows=false;

this.shadowSide=null;

this.colorWrite=true;

this.precision=null;// override the renderer's default precision for this material

this.polygonOffset=false;
this.polygonOffsetFactor=0;
this.polygonOffsetUnits=0;

this.dithering=false;

this.alphaTest=0;
this.premultipliedAlpha=false;

this.visible=true;

this.userData={};

this.needsUpdate=true;

}

Material.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:Material,

isMaterial:true,

onBeforeCompile:function onBeforeCompile(){},

setValues:function setValues(values){

if(values===undefined)return;

for(var key in values){

var newValue=values[key];

if(newValue===undefined){

console.warn("THREE.Material: '"+key+"' parameter is undefined.");
continue;

}

// for backward compatability if shading is set in the constructor
if(key==='shading'){

console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');
this.flatShading=newValue===FlatShading?true:false;
continue;

}

var currentValue=this[key];

if(currentValue===undefined){

console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");
continue;

}

if(currentValue&&currentValue.isColor){

currentValue.set(newValue);

}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){

currentValue.copy(newValue);

}else{

this[key]=newValue;

}

}

},

toJSON:function toJSON(meta){

var isRoot=meta===undefined||typeof meta==='string';

if(isRoot){

meta={
textures:{},
images:{}};


}

var data={
metadata:{
version:4.5,
type:'Material',
generator:'Material.toJSON'}};



// standard Material serialization
data.uuid=this.uuid;
data.type=this.type;

if(this.name!=='')data.name=this.name;

if(this.color&&this.color.isColor)data.color=this.color.getHex();

if(this.roughness!==undefined)data.roughness=this.roughness;
if(this.metalness!==undefined)data.metalness=this.metalness;

if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();
if(this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;

if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();
if(this.shininess!==undefined)data.shininess=this.shininess;
if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;
if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;

if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;
if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;
if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;
if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;

if(this.aoMap&&this.aoMap.isTexture){

data.aoMap=this.aoMap.toJSON(meta).uuid;
data.aoMapIntensity=this.aoMapIntensity;

}

if(this.bumpMap&&this.bumpMap.isTexture){

data.bumpMap=this.bumpMap.toJSON(meta).uuid;
data.bumpScale=this.bumpScale;

}

if(this.normalMap&&this.normalMap.isTexture){

data.normalMap=this.normalMap.toJSON(meta).uuid;
data.normalMapType=this.normalMapType;
data.normalScale=this.normalScale.toArray();

}

if(this.displacementMap&&this.displacementMap.isTexture){

data.displacementMap=this.displacementMap.toJSON(meta).uuid;
data.displacementScale=this.displacementScale;
data.displacementBias=this.displacementBias;

}

if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;
if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;

if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;
if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;

if(this.envMap&&this.envMap.isTexture){

data.envMap=this.envMap.toJSON(meta).uuid;
data.reflectivity=this.reflectivity;// Scale behind envMap

if(this.combine!==undefined)data.combine=this.combine;
if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;

}

if(this.gradientMap&&this.gradientMap.isTexture){

data.gradientMap=this.gradientMap.toJSON(meta).uuid;

}

if(this.size!==undefined)data.size=this.size;
if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;

if(this.blending!==NormalBlending)data.blending=this.blending;
if(this.flatShading===true)data.flatShading=this.flatShading;
if(this.side!==FrontSide)data.side=this.side;
if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;

if(this.opacity<1)data.opacity=this.opacity;
if(this.transparent===true)data.transparent=this.transparent;

data.depthFunc=this.depthFunc;
data.depthTest=this.depthTest;
data.depthWrite=this.depthWrite;

// rotation (SpriteMaterial)
if(this.rotation!==0)data.rotation=this.rotation;

if(this.polygonOffset===true)data.polygonOffset=true;
if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;
if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;

if(this.linewidth!==1)data.linewidth=this.linewidth;
if(this.dashSize!==undefined)data.dashSize=this.dashSize;
if(this.gapSize!==undefined)data.gapSize=this.gapSize;
if(this.scale!==undefined)data.scale=this.scale;

if(this.dithering===true)data.dithering=true;

if(this.alphaTest>0)data.alphaTest=this.alphaTest;
if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;

if(this.wireframe===true)data.wireframe=this.wireframe;
if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;
if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;
if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;

if(this.morphTargets===true)data.morphTargets=true;
if(this.skinning===true)data.skinning=true;

if(this.visible===false)data.visible=false;
if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;

// TODO: Copied from Object3D.toJSON

function extractFromCache(cache){

var values=[];

for(var key in cache){

var data=cache[key];
delete data.metadata;
values.push(data);

}

return values;

}

if(isRoot){

var textures=extractFromCache(meta.textures);
var images=extractFromCache(meta.images);

if(textures.length>0)data.textures=textures;
if(images.length>0)data.images=images;

}

return data;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(source){

this.name=source.name;

this.fog=source.fog;
this.lights=source.lights;

this.blending=source.blending;
this.side=source.side;
this.flatShading=source.flatShading;
this.vertexColors=source.vertexColors;

this.opacity=source.opacity;
this.transparent=source.transparent;

this.blendSrc=source.blendSrc;
this.blendDst=source.blendDst;
this.blendEquation=source.blendEquation;
this.blendSrcAlpha=source.blendSrcAlpha;
this.blendDstAlpha=source.blendDstAlpha;
this.blendEquationAlpha=source.blendEquationAlpha;

this.depthFunc=source.depthFunc;
this.depthTest=source.depthTest;
this.depthWrite=source.depthWrite;

this.colorWrite=source.colorWrite;

this.precision=source.precision;

this.polygonOffset=source.polygonOffset;
this.polygonOffsetFactor=source.polygonOffsetFactor;
this.polygonOffsetUnits=source.polygonOffsetUnits;

this.dithering=source.dithering;

this.alphaTest=source.alphaTest;
this.premultipliedAlpha=source.premultipliedAlpha;

this.visible=source.visible;
this.userData=JSON.parse(JSON.stringify(source.userData));

this.clipShadows=source.clipShadows;
this.clipIntersection=source.clipIntersection;

var srcPlanes=source.clippingPlanes,
dstPlanes=null;

if(srcPlanes!==null){

var n=srcPlanes.length;
dstPlanes=new Array(n);

for(var i=0;i!==n;++i){
dstPlanes[i]=srcPlanes[i].clone();}

}

this.clippingPlanes=dstPlanes;

this.shadowSide=source.shadowSide;

return this;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

}});



var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters){

Material.call(this);

this.type='ShaderMaterial';

this.defines={};
this.uniforms={};

this.vertexShader=default_vertex;
this.fragmentShader=default_fragment;

this.linewidth=1;

this.wireframe=false;
this.wireframeLinewidth=1;

this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes

this.skinning=false;// set to use skinning attribute streams
this.morphTargets=false;// set to use morph targets
this.morphNormals=false;// set to use morph normals

this.extensions={
derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};

// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={
'color':[1,1,1],
'uv':[0,0],
'uv2':[0,0]};


this.index0AttributeName=undefined;
this.uniformsNeedUpdate=false;

if(parameters!==undefined){

if(parameters.attributes!==undefined){

console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');

}

this.setValues(parameters);

}

}

ShaderMaterial.prototype=Object.create(Material.prototype);
ShaderMaterial.prototype.constructor=ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial=true;

ShaderMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.fragmentShader=source.fragmentShader;
this.vertexShader=source.vertexShader;

this.uniforms=cloneUniforms(source.uniforms);

this.defines=Object.assign({},source.defines);

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;

this.lights=source.lights;
this.clipping=source.clipping;

this.skinning=source.skinning;

this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

this.extensions=source.extensions;

return this;

};

ShaderMaterial.prototype.toJSON=function(meta){

var data=Material.prototype.toJSON.call(this,meta);

data.uniforms={};

for(var name in this.uniforms){

var uniform=this.uniforms[name];
var value=uniform.value;

if(value&&value.isTexture){

data.uniforms[name]={
type:'t',
value:value.toJSON(meta).uuid};


}else if(value&&value.isColor){

data.uniforms[name]={
type:'c',
value:value.getHex()};


}else if(value&&value.isVector2){

data.uniforms[name]={
type:'v2',
value:value.toArray()};


}else if(value&&value.isVector3){

data.uniforms[name]={
type:'v3',
value:value.toArray()};


}else if(value&&value.isVector4){

data.uniforms[name]={
type:'v4',
value:value.toArray()};


}else if(value&&value.isMatrix3){

data.uniforms[name]={
type:'m3',
value:value.toArray()};


}else if(value&&value.isMatrix4){

data.uniforms[name]={
type:'m4',
value:value.toArray()};


}else{

data.uniforms[name]={
value:value};


// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

}

}

if(Object.keys(this.defines).length>0)data.defines=this.defines;

data.vertexShader=this.vertexShader;
data.fragmentShader=this.fragmentShader;

var extensions={};

for(var key in this.extensions){

if(this.extensions[key]===true)extensions[key]=true;

}

if(Object.keys(extensions).length>0)data.extensions=extensions;

return data;

};

/**
 * @author bhouston / http://clara.io
 */

function Ray(origin,direction){

this.origin=origin!==undefined?origin:new Vector3();
this.direction=direction!==undefined?direction:new Vector3();

}

Object.assign(Ray.prototype,{

set:function set(origin,direction){

this.origin.copy(origin);
this.direction.copy(direction);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(ray){

this.origin.copy(ray.origin);
this.direction.copy(ray.direction);

return this;

},

at:function at(t,target){

if(target===undefined){

console.warn('THREE.Ray: .at() target is now required');
target=new Vector3();

}

return target.copy(this.direction).multiplyScalar(t).add(this.origin);

},

lookAt:function lookAt(v){

this.direction.copy(v).sub(this.origin).normalize();

return this;

},

recast:function(){

var v1=new Vector3();

return function recast(t){

this.origin.copy(this.at(t,v1));

return this;

};

}(),

closestPointToPoint:function closestPointToPoint(point,target){

if(target===undefined){

console.warn('THREE.Ray: .closestPointToPoint() target is now required');
target=new Vector3();

}

target.subVectors(point,this.origin);

var directionDistance=target.dot(this.direction);

if(directionDistance<0){

return target.copy(this.origin);

}

return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

},

distanceToPoint:function distanceToPoint(point){

return Math.sqrt(this.distanceSqToPoint(point));

},

distanceSqToPoint:function(){

var v1=new Vector3();

return function distanceSqToPoint(point){

var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);

// point behind the ray

if(directionDistance<0){

return this.origin.distanceToSquared(point);

}

v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

return v1.distanceToSquared(point);

};

}(),

distanceSqToSegment:function(){

var segCenter=new Vector3();
var segDir=new Vector3();
var diff=new Vector3();

return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){

// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment

segCenter.copy(v0).add(v1).multiplyScalar(0.5);
segDir.copy(v1).sub(v0).normalize();
diff.copy(this.origin).sub(segCenter);

var segExtent=v0.distanceTo(v1)*0.5;
var a01=-this.direction.dot(segDir);
var b0=diff.dot(this.direction);
var b1=-diff.dot(segDir);
var c=diff.lengthSq();
var det=Math.abs(1-a01*a01);
var s0,s1,sqrDist,extDet;

if(det>0){

// The ray and segment are not parallel.

s0=a01*b1-b0;
s1=a01*b0-b1;
extDet=segExtent*det;

if(s0>=0){

if(s1>=-extDet){

if(s1<=extDet){

// region 0
// Minimum at interior points of ray and segment.

var invDet=1/det;
s0*=invDet;
s1*=invDet;
sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;

}else{

// region 1

s1=segExtent;
s0=Math.max(0,-(a01*s1+b0));
sqrDist=-s0*s0+s1*(s1+2*b1)+c;

}

}else{

// region 5

s1=-segExtent;
s0=Math.max(0,-(a01*s1+b0));
sqrDist=-s0*s0+s1*(s1+2*b1)+c;

}

}else{

if(s1<=-extDet){

// region 4

s0=Math.max(0,-(-a01*segExtent+b0));
s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);
sqrDist=-s0*s0+s1*(s1+2*b1)+c;

}else if(s1<=extDet){

// region 3

s0=0;
s1=Math.min(Math.max(-segExtent,-b1),segExtent);
sqrDist=s1*(s1+2*b1)+c;

}else{

// region 2

s0=Math.max(0,-(a01*segExtent+b0));
s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);
sqrDist=-s0*s0+s1*(s1+2*b1)+c;

}

}

}else{

// Ray and segment are parallel.

s1=a01>0?-segExtent:segExtent;
s0=Math.max(0,-(a01*s1+b0));
sqrDist=-s0*s0+s1*(s1+2*b1)+c;

}

if(optionalPointOnRay){

optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);

}

if(optionalPointOnSegment){

optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);

}

return sqrDist;

};

}(),

intersectSphere:function(){

var v1=new Vector3();

return function intersectSphere(sphere,target){

v1.subVectors(sphere.center,this.origin);
var tca=v1.dot(this.direction);
var d2=v1.dot(v1)-tca*tca;
var radius2=sphere.radius*sphere.radius;

if(d2>radius2)return null;

var thc=Math.sqrt(radius2-d2);

// t0 = first intersect point - entrance on front of sphere
var t0=tca-thc;

// t1 = second intersect point - exit point on back of sphere
var t1=tca+thc;

// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;

// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,target);

// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,target);

};

}(),

intersectsSphere:function intersectsSphere(sphere){

return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;

},

distanceToPlane:function distanceToPlane(plane){

var denominator=plane.normal.dot(this.direction);

if(denominator===0){

// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){

return 0;

}

// Null is preferable to undefined since undefined means.... it is undefined

return null;

}

var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;

// Return if the ray never intersects the plane

return t>=0?t:null;

},

intersectPlane:function intersectPlane(plane,target){

var t=this.distanceToPlane(plane);

if(t===null){

return null;

}

return this.at(t,target);

},

intersectsPlane:function intersectsPlane(plane){

// check if the ray lies on the plane first

var distToPoint=plane.distanceToPoint(this.origin);

if(distToPoint===0){

return true;

}

var denominator=plane.normal.dot(this.direction);

if(denominator*distToPoint<0){

return true;

}

// ray origin is behind the plane (and is pointing behind it)

return false;

},

intersectBox:function intersectBox(box,target){

var tmin,tmax,tymin,tymax,tzmin,tzmax;

var invdirx=1/this.direction.x,
invdiry=1/this.direction.y,
invdirz=1/this.direction.z;

var origin=this.origin;

if(invdirx>=0){

tmin=(box.min.x-origin.x)*invdirx;
tmax=(box.max.x-origin.x)*invdirx;

}else{

tmin=(box.max.x-origin.x)*invdirx;
tmax=(box.min.x-origin.x)*invdirx;

}

if(invdiry>=0){

tymin=(box.min.y-origin.y)*invdiry;
tymax=(box.max.y-origin.y)*invdiry;

}else{

tymin=(box.max.y-origin.y)*invdiry;
tymax=(box.min.y-origin.y)*invdiry;

}

if(tmin>tymax||tymin>tmax)return null;

// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN

if(tymin>tmin||tmin!==tmin)tmin=tymin;

if(tymax<tmax||tmax!==tmax)tmax=tymax;

if(invdirz>=0){

tzmin=(box.min.z-origin.z)*invdirz;
tzmax=(box.max.z-origin.z)*invdirz;

}else{

tzmin=(box.max.z-origin.z)*invdirz;
tzmax=(box.min.z-origin.z)*invdirz;

}

if(tmin>tzmax||tzmin>tmax)return null;

if(tzmin>tmin||tmin!==tmin)tmin=tzmin;

if(tzmax<tmax||tmax!==tmax)tmax=tzmax;

//return point closest to the ray (positive side)

if(tmax<0)return null;

return this.at(tmin>=0?tmin:tmax,target);

},

intersectsBox:function(){

var v=new Vector3();

return function intersectsBox(box){

return this.intersectBox(box,v)!==null;

};

}(),

intersectTriangle:function(){

// Compute the offset origin, edges, and normal.
var diff=new Vector3();
var edge1=new Vector3();
var edge2=new Vector3();
var normal=new Vector3();

return function intersectTriangle(a,b,c,backfaceCulling,target){

// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

edge1.subVectors(b,a);
edge2.subVectors(c,a);
normal.crossVectors(edge1,edge2);

// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
var DdN=this.direction.dot(normal);
var sign;

if(DdN>0){

if(backfaceCulling)return null;
sign=1;

}else if(DdN<0){

sign=-1;
DdN=-DdN;

}else{

return null;

}

diff.subVectors(this.origin,a);
var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));

// b1 < 0, no intersection
if(DdQxE2<0){

return null;

}

var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));

// b2 < 0, no intersection
if(DdE1xQ<0){

return null;

}

// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){

return null;

}

// Line intersects triangle, check if ray does.
var QdN=-sign*diff.dot(normal);

// t < 0, no intersection
if(QdN<0){

return null;

}

// Ray intersects triangle.
return this.at(QdN/DdN,target);

};

}(),

applyMatrix4:function applyMatrix4(matrix4){

this.origin.applyMatrix4(matrix4);
this.direction.transformDirection(matrix4);

return this;

},

equals:function equals(ray){

return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);

}});



/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle(a,b,c){

this.a=a!==undefined?a:new Vector3();
this.b=b!==undefined?b:new Vector3();
this.c=c!==undefined?c:new Vector3();

}

Object.assign(Triangle,{

getNormal:function(){

var v0=new Vector3();

return function getNormal(a,b,c,target){

if(target===undefined){

console.warn('THREE.Triangle: .getNormal() target is now required');
target=new Vector3();

}

target.subVectors(c,b);
v0.subVectors(a,b);
target.cross(v0);

var targetLengthSq=target.lengthSq();
if(targetLengthSq>0){

return target.multiplyScalar(1/Math.sqrt(targetLengthSq));

}

return target.set(0,0,0);

};

}(),

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
getBarycoord:function(){

var v0=new Vector3();
var v1=new Vector3();
var v2=new Vector3();

return function getBarycoord(point,a,b,c,target){

v0.subVectors(c,a);
v1.subVectors(b,a);
v2.subVectors(point,a);

var dot00=v0.dot(v0);
var dot01=v0.dot(v1);
var dot02=v0.dot(v2);
var dot11=v1.dot(v1);
var dot12=v1.dot(v2);

var denom=dot00*dot11-dot01*dot01;

if(target===undefined){

console.warn('THREE.Triangle: .getBarycoord() target is now required');
target=new Vector3();

}

// collinear or singular triangle
if(denom===0){

// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return target.set(-2,-1,-1);

}

var invDenom=1/denom;
var u=(dot11*dot02-dot01*dot12)*invDenom;
var v=(dot00*dot12-dot01*dot02)*invDenom;

// barycentric coordinates must always sum to 1
return target.set(1-u-v,v,u);

};

}(),

containsPoint:function(){

var v1=new Vector3();

return function containsPoint(point,a,b,c){

Triangle.getBarycoord(point,a,b,c,v1);

return v1.x>=0&&v1.y>=0&&v1.x+v1.y<=1;

};

}(),

getUV:function(){

var barycoord=new Vector3();

return function getUV(point,p1,p2,p3,uv1,uv2,uv3,target){

this.getBarycoord(point,p1,p2,p3,barycoord);

target.set(0,0);
target.addScaledVector(uv1,barycoord.x);
target.addScaledVector(uv2,barycoord.y);
target.addScaledVector(uv3,barycoord.z);

return target;

};

}(),

isFrontFacing:function(){

var v0=new Vector3();
var v1=new Vector3();

return function isFrontFacing(a,b,c,direction){

v0.subVectors(c,b);
v1.subVectors(a,b);

// strictly front facing
return v0.cross(v1).dot(direction)<0?true:false;

};

}()});



Object.assign(Triangle.prototype,{

set:function set(a,b,c){

this.a.copy(a);
this.b.copy(b);
this.c.copy(c);

return this;

},

setFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){

this.a.copy(points[i0]);
this.b.copy(points[i1]);
this.c.copy(points[i2]);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(triangle){

this.a.copy(triangle.a);
this.b.copy(triangle.b);
this.c.copy(triangle.c);

return this;

},

getArea:function(){

var v0=new Vector3();
var v1=new Vector3();

return function getArea(){

v0.subVectors(this.c,this.b);
v1.subVectors(this.a,this.b);

return v0.cross(v1).length()*0.5;

};

}(),

getMidpoint:function getMidpoint(target){

if(target===undefined){

console.warn('THREE.Triangle: .getMidpoint() target is now required');
target=new Vector3();

}

return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);

},

getNormal:function getNormal(target){

return Triangle.getNormal(this.a,this.b,this.c,target);

},

getPlane:function getPlane(target){

if(target===undefined){

console.warn('THREE.Triangle: .getPlane() target is now required');
target=new Vector3();

}

return target.setFromCoplanarPoints(this.a,this.b,this.c);

},

getBarycoord:function getBarycoord(point,target){

return Triangle.getBarycoord(point,this.a,this.b,this.c,target);

},

getUV:function getUV(point,uv1,uv2,uv3,target){

return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);

},

containsPoint:function containsPoint(point){

return Triangle.containsPoint(point,this.a,this.b,this.c);

},

isFrontFacing:function isFrontFacing(direction){

return Triangle.isFrontFacing(this.a,this.b,this.c,direction);

},

intersectsBox:function intersectsBox(box){

return box.intersectsTriangle(this);

},

closestPointToPoint:function(){

var vab=new Vector3();
var vac=new Vector3();
var vbc=new Vector3();
var vap=new Vector3();
var vbp=new Vector3();
var vcp=new Vector3();

return function closestPointToPoint(p,target){

if(target===undefined){

console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
target=new Vector3();

}

var a=this.a,b=this.b,c=this.c;
var v,w;

// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.

vab.subVectors(b,a);
vac.subVectors(c,a);
vap.subVectors(p,a);
var d1=vab.dot(vap);
var d2=vac.dot(vap);
if(d1<=0&&d2<=0){

// vertex region of A; barycentric coords (1, 0, 0)
return target.copy(a);

}

vbp.subVectors(p,b);
var d3=vab.dot(vbp);
var d4=vac.dot(vbp);
if(d3>=0&&d4<=d3){

// vertex region of B; barycentric coords (0, 1, 0)
return target.copy(b);

}

var vc=d1*d4-d3*d2;
if(vc<=0&&d1>=0&&d3<=0){

v=d1/(d1-d3);
// edge region of AB; barycentric coords (1-v, v, 0)
return target.copy(a).addScaledVector(vab,v);

}

vcp.subVectors(p,c);
var d5=vab.dot(vcp);
var d6=vac.dot(vcp);
if(d6>=0&&d5<=d6){

// vertex region of C; barycentric coords (0, 0, 1)
return target.copy(c);

}

var vb=d5*d2-d1*d6;
if(vb<=0&&d2>=0&&d6<=0){

w=d2/(d2-d6);
// edge region of AC; barycentric coords (1-w, 0, w)
return target.copy(a).addScaledVector(vac,w);

}

var va=d3*d6-d5*d4;
if(va<=0&&d4-d3>=0&&d5-d6>=0){

vbc.subVectors(c,b);
w=(d4-d3)/(d4-d3+(d5-d6));
// edge region of BC; barycentric coords (0, 1-w, w)
return target.copy(b).addScaledVector(vbc,w);// edge region of BC

}

// face region
var denom=1/(va+vb+vc);
// u = va * denom
v=vb*denom;
w=vc*denom;
return target.copy(a).addScaledVector(vab,v).addScaledVector(vac,w);

};

}(),

equals:function equals(triangle){

return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters){

Material.call(this);

this.type='MeshBasicMaterial';

this.color=new Color(0xffffff);// emissive

this.map=null;

this.lightMap=null;
this.lightMapIntensity=1.0;

this.aoMap=null;
this.aoMapIntensity=1.0;

this.specularMap=null;

this.alphaMap=null;

this.envMap=null;
this.combine=MultiplyOperation;
this.reflectivity=1;
this.refractionRatio=0.98;

this.wireframe=false;
this.wireframeLinewidth=1;
this.wireframeLinecap='round';
this.wireframeLinejoin='round';

this.skinning=false;
this.morphTargets=false;

this.lights=false;

this.setValues(parameters);

}

MeshBasicMaterial.prototype=Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial=true;

MeshBasicMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);

this.map=source.map;

this.lightMap=source.lightMap;
this.lightMapIntensity=source.lightMapIntensity;

this.aoMap=source.aoMap;
this.aoMapIntensity=source.aoMapIntensity;

this.specularMap=source.specularMap;

this.alphaMap=source.alphaMap;

this.envMap=source.envMap;
this.combine=source.combine;
this.reflectivity=source.reflectivity;
this.refractionRatio=source.refractionRatio;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;
this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh(geometry,material){

Object3D.call(this);

this.type='Mesh';

this.geometry=geometry!==undefined?geometry:new BufferGeometry();
this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});

this.drawMode=TrianglesDrawMode;

this.updateMorphTargets();

}

Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Mesh,

isMesh:true,

setDrawMode:function setDrawMode(value){

this.drawMode=value;

},

copy:function copy(source){

Object3D.prototype.copy.call(this,source);

this.drawMode=source.drawMode;

if(source.morphTargetInfluences!==undefined){

this.morphTargetInfluences=source.morphTargetInfluences.slice();

}

if(source.morphTargetDictionary!==undefined){

this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);

}

return this;

},

updateMorphTargets:function updateMorphTargets(){

var geometry=this.geometry;
var m,ml,name;

if(geometry.isBufferGeometry){

var morphAttributes=geometry.morphAttributes;
var keys=Object.keys(morphAttributes);

if(keys.length>0){

var morphAttribute=morphAttributes[keys[0]];

if(morphAttribute!==undefined){

this.morphTargetInfluences=[];
this.morphTargetDictionary={};

for(m=0,ml=morphAttribute.length;m<ml;m++){

name=morphAttribute[m].name||String(m);

this.morphTargetInfluences.push(0);
this.morphTargetDictionary[name]=m;

}

}

}

}else{

var morphTargets=geometry.morphTargets;

if(morphTargets!==undefined&&morphTargets.length>0){

console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');

}

}

},

raycast:function(){

var inverseMatrix=new Matrix4();
var ray=new Ray();
var sphere=new Sphere();

var vA=new Vector3();
var vB=new Vector3();
var vC=new Vector3();

var tempA=new Vector3();
var tempB=new Vector3();
var tempC=new Vector3();

var morphA=new Vector3();
var morphB=new Vector3();
var morphC=new Vector3();

var uvA=new Vector2();
var uvB=new Vector2();
var uvC=new Vector2();

var intersectionPoint=new Vector3();
var intersectionPointWorld=new Vector3();

function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){

var intersect;

if(material.side===BackSide){

intersect=ray.intersectTriangle(pC,pB,pA,true,point);

}else{

intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);

}

if(intersect===null)return null;

intersectionPointWorld.copy(point);
intersectionPointWorld.applyMatrix4(object.matrixWorld);

var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);

if(distance<raycaster.near||distance>raycaster.far)return null;

return{
distance:distance,
point:intersectionPointWorld.clone(),
object:object};


}

function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,uv,a,b,c){

vA.fromBufferAttribute(position,a);
vB.fromBufferAttribute(position,b);
vC.fromBufferAttribute(position,c);

var morphInfluences=object.morphTargetInfluences;

if(material.morphTargets&&morphPosition&&morphInfluences){

morphA.set(0,0,0);
morphB.set(0,0,0);
morphC.set(0,0,0);

for(var i=0,il=morphPosition.length;i<il;i++){

var influence=morphInfluences[i];
var morphAttribute=morphPosition[i];

if(influence===0)continue;

tempA.fromBufferAttribute(morphAttribute,a);
tempB.fromBufferAttribute(morphAttribute,b);
tempC.fromBufferAttribute(morphAttribute,c);

morphA.addScaledVector(tempA.sub(vA),influence);
morphB.addScaledVector(tempB.sub(vB),influence);
morphC.addScaledVector(tempC.sub(vC),influence);

}

vA.add(morphA);
vB.add(morphB);
vC.add(morphC);

}

var intersection=checkIntersection(object,material,raycaster,ray,vA,vB,vC,intersectionPoint);

if(intersection){

if(uv){

uvA.fromBufferAttribute(uv,a);
uvB.fromBufferAttribute(uv,b);
uvC.fromBufferAttribute(uv,c);

intersection.uv=Triangle.getUV(intersectionPoint,vA,vB,vC,uvA,uvB,uvC,new Vector2());

}

var face=new Face3(a,b,c);
Triangle.getNormal(vA,vB,vC,face.normal);

intersection.face=face;

}

return intersection;

}

return function raycast(raycaster,intersects){

var geometry=this.geometry;
var material=this.material;
var matrixWorld=this.matrixWorld;

if(material===undefined)return;

// Checking boundingSphere distance to ray

if(geometry.boundingSphere===null)geometry.computeBoundingSphere();

sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);

if(raycaster.ray.intersectsSphere(sphere)===false)return;

//

inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

// Check boundingBox before continuing

if(geometry.boundingBox!==null){

if(ray.intersectsBox(geometry.boundingBox)===false)return;

}

var intersection;

if(geometry.isBufferGeometry){

var a,b,c;
var index=geometry.index;
var position=geometry.attributes.position;
var morphPosition=geometry.morphAttributes.position;
var uv=geometry.attributes.uv;
var groups=geometry.groups;
var drawRange=geometry.drawRange;
var i,j,il,jl;
var group,groupMaterial;
var start,end;

if(index!==null){

// indexed buffer geometry

if(Array.isArray(material)){

for(i=0,il=groups.length;i<il;i++){

group=groups[i];
groupMaterial=material[group.materialIndex];

start=Math.max(group.start,drawRange.start);
end=Math.min(group.start+group.count,drawRange.start+drawRange.count);

for(j=start,jl=end;j<jl;j+=3){

a=index.getX(j);
b=index.getX(j+1);
c=index.getX(j+2);

intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,ray,position,morphPosition,uv,a,b,c);

if(intersection){

intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;
intersects.push(intersection);

}

}

}

}else{

start=Math.max(0,drawRange.start);
end=Math.min(index.count,drawRange.start+drawRange.count);

for(i=start,il=end;i<il;i+=3){

a=index.getX(i);
b=index.getX(i+1);
c=index.getX(i+2);

intersection=checkBufferGeometryIntersection(this,material,raycaster,ray,position,morphPosition,uv,a,b,c);

if(intersection){

intersection.faceIndex=Math.floor(i/3);// triangle number in indexed buffer semantics
intersects.push(intersection);

}

}

}

}else if(position!==undefined){

// non-indexed buffer geometry

if(Array.isArray(material)){

for(i=0,il=groups.length;i<il;i++){

group=groups[i];
groupMaterial=material[group.materialIndex];

start=Math.max(group.start,drawRange.start);
end=Math.min(group.start+group.count,drawRange.start+drawRange.count);

for(j=start,jl=end;j<jl;j+=3){

a=j;
b=j+1;
c=j+2;

intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,ray,position,morphPosition,uv,a,b,c);

if(intersection){

intersection.faceIndex=Math.floor(j/3);// triangle number in non-indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;
intersects.push(intersection);

}

}

}

}else{

start=Math.max(0,drawRange.start);
end=Math.min(position.count,drawRange.start+drawRange.count);

for(i=start,il=end;i<il;i+=3){

a=i;
b=i+1;
c=i+2;

intersection=checkBufferGeometryIntersection(this,material,raycaster,ray,position,morphPosition,uv,a,b,c);

if(intersection){

intersection.faceIndex=Math.floor(i/3);// triangle number in non-indexed buffer semantics
intersects.push(intersection);

}

}

}

}

}else if(geometry.isGeometry){

var fvA,fvB,fvC;
var isMultiMaterial=Array.isArray(material);

var vertices=geometry.vertices;
var faces=geometry.faces;
var uvs;

var faceVertexUvs=geometry.faceVertexUvs[0];
if(faceVertexUvs.length>0)uvs=faceVertexUvs;

for(var f=0,fl=faces.length;f<fl;f++){

var face=faces[f];
var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;

if(faceMaterial===undefined)continue;

fvA=vertices[face.a];
fvB=vertices[face.b];
fvC=vertices[face.c];

intersection=checkIntersection(this,faceMaterial,raycaster,ray,fvA,fvB,fvC,intersectionPoint);

if(intersection){

if(uvs&&uvs[f]){

var uvs_f=uvs[f];
uvA.copy(uvs_f[0]);
uvB.copy(uvs_f[1]);
uvC.copy(uvs_f[2]);

intersection.uv=Triangle.getUV(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC,new Vector2());

}

intersection.face=face;
intersection.faceIndex=f;
intersects.push(intersection);

}

}

}

};

}(),

clone:function clone(){

return new this.constructor(this.geometry,this.material).copy(this);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground(renderer,state,objects,premultipliedAlpha){

var clearColor=new Color(0x000000);
var clearAlpha=0;

var planeMesh;
var boxMesh;
// Store the current background texture and its `version`
// so we can recompile the material accordingly.
var currentBackground=null;
var currentBackgroundVersion=0;

function render(renderList,scene,camera,forceClear){

var background=scene.background;

// Ignore background in AR
// TODO: Reconsider this.

var vr=renderer.vr;
var session=vr.getSession&&vr.getSession();

if(session&&session.environmentBlendMode==='additive'){

background=null;

}

if(background===null){

setClear(clearColor,clearAlpha);
currentBackground=null;
currentBackgroundVersion=0;

}else if(background&&background.isColor){

setClear(background,1);
forceClear=true;
currentBackground=null;
currentBackgroundVersion=0;

}

if(renderer.autoClear||forceClear){

renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);

}

if(background&&(background.isCubeTexture||background.isWebGLRenderTargetCube)){

if(boxMesh===undefined){

boxMesh=new Mesh(
new BoxBufferGeometry(1,1,1),
new ShaderMaterial({
type:'BackgroundCubeMaterial',
uniforms:cloneUniforms(ShaderLib.cube.uniforms),
vertexShader:ShaderLib.cube.vertexShader,
fragmentShader:ShaderLib.cube.fragmentShader,
side:BackSide,
depthTest:false,
depthWrite:false,
fog:false}));



boxMesh.geometry.removeAttribute('normal');
boxMesh.geometry.removeAttribute('uv');

boxMesh.onBeforeRender=function(renderer,scene,camera){

this.matrixWorld.copyPosition(camera.matrixWorld);

};

// enable code injection for non-built-in material
Object.defineProperty(boxMesh.material,'map',{

get:function get(){

return this.uniforms.tCube.value;

}});



objects.update(boxMesh);

}

var texture=background.isWebGLRenderTargetCube?background.texture:background;
boxMesh.material.uniforms.tCube.value=texture;
boxMesh.material.uniforms.tFlip.value=background.isWebGLRenderTargetCube?1:-1;

if(currentBackground!==background||
currentBackgroundVersion!==texture.version){

boxMesh.material.needsUpdate=true;

currentBackground=background;
currentBackgroundVersion=texture.version;

}

// push to the pre-sorted opaque render list
renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);

}else if(background&&background.isTexture){

if(planeMesh===undefined){

planeMesh=new Mesh(
new PlaneBufferGeometry(2,2),
new ShaderMaterial({
type:'BackgroundMaterial',
uniforms:cloneUniforms(ShaderLib.background.uniforms),
vertexShader:ShaderLib.background.vertexShader,
fragmentShader:ShaderLib.background.fragmentShader,
side:FrontSide,
depthTest:false,
depthWrite:false,
fog:false}));



planeMesh.geometry.removeAttribute('normal');

// enable code injection for non-built-in material
Object.defineProperty(planeMesh.material,'map',{

get:function get(){

return this.uniforms.t2D.value;

}});



objects.update(planeMesh);

}

planeMesh.material.uniforms.t2D.value=background;

if(background.matrixAutoUpdate===true){

background.updateMatrix();

}

planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

if(currentBackground!==background||
currentBackgroundVersion!==background.version){

planeMesh.material.needsUpdate=true;

currentBackground=background;
currentBackgroundVersion=background.version;

}


// push to the pre-sorted opaque render list
renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);

}

}

function setClear(color,alpha){

state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);

}

return{

getClearColor:function getClearColor(){

return clearColor;

},
setClearColor:function setClearColor(color,alpha){

clearColor.set(color);
clearAlpha=alpha!==undefined?alpha:1;
setClear(clearColor,clearAlpha);

},
getClearAlpha:function getClearAlpha(){

return clearAlpha;

},
setClearAlpha:function setClearAlpha(alpha){

clearAlpha=alpha;
setClear(clearColor,clearAlpha);

},
render:render};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer(gl,extensions,info,capabilities){

var mode;

function setMode(value){

mode=value;

}

function render(start,count){

gl.drawArrays(mode,start,count);

info.update(count,mode);

}

function renderInstances(geometry,start,count){

var extension;

if(capabilities.isWebGL2){

extension=gl;

}else{

extension=extensions.get('ANGLE_instanced_arrays');

if(extension===null){

console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
return;

}

}

extension[capabilities.isWebGL2?'drawArraysInstanced':'drawArraysInstancedANGLE'](mode,start,count,geometry.maxInstancedCount);

info.update(count,mode,geometry.maxInstancedCount);

}

//

this.setMode=setMode;
this.render=render;
this.renderInstances=renderInstances;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities(gl,extensions,parameters){

var maxAnisotropy;

function getMaxAnisotropy(){

if(maxAnisotropy!==undefined)return maxAnisotropy;

var extension=extensions.get('EXT_texture_filter_anisotropic');

if(extension!==null){

maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);

}else{

maxAnisotropy=0;

}

return maxAnisotropy;

}

function getMaxPrecision(precision){

if(precision==='highp'){

if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&
gl.getShaderPrecisionFormat(35632,36338).precision>0){

return'highp';

}

precision='mediump';

}

if(precision==='mediump'){

if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&
gl.getShaderPrecisionFormat(35632,36337).precision>0){

return'mediump';

}

}

return'lowp';

}

var isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext;

var precision=parameters.precision!==undefined?parameters.precision:'highp';
var maxPrecision=getMaxPrecision(precision);

if(maxPrecision!==precision){

console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');
precision=maxPrecision;

}

var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;

var maxTextures=gl.getParameter(34930);
var maxVertexTextures=gl.getParameter(35660);
var maxTextureSize=gl.getParameter(3379);
var maxCubemapSize=gl.getParameter(34076);

var maxAttributes=gl.getParameter(34921);
var maxVertexUniforms=gl.getParameter(36347);
var maxVaryings=gl.getParameter(36348);
var maxFragmentUniforms=gl.getParameter(36349);

var vertexTextures=maxVertexTextures>0;
var floatFragmentTextures=isWebGL2||!!extensions.get('OES_texture_float');
var floatVertexTextures=vertexTextures&&floatFragmentTextures;

var maxSamples=isWebGL2?gl.getParameter(36183):0;

return{

isWebGL2:isWebGL2,

getMaxAnisotropy:getMaxAnisotropy,
getMaxPrecision:getMaxPrecision,

precision:precision,
logarithmicDepthBuffer:logarithmicDepthBuffer,

maxTextures:maxTextures,
maxVertexTextures:maxVertexTextures,
maxTextureSize:maxTextureSize,
maxCubemapSize:maxCubemapSize,

maxAttributes:maxAttributes,
maxVertexUniforms:maxVertexUniforms,
maxVaryings:maxVaryings,
maxFragmentUniforms:maxFragmentUniforms,

vertexTextures:vertexTextures,
floatFragmentTextures:floatFragmentTextures,
floatVertexTextures:floatVertexTextures,

maxSamples:maxSamples};



}

/**
 * @author tschw
 */

function WebGLClipping(){

var scope=this,

globalState=null,
numGlobalPlanes=0,
localClippingEnabled=false,
renderingShadows=false,

plane=new Plane(),
viewNormalMatrix=new Matrix3(),

uniform={value:null,needsUpdate:false};

this.uniform=uniform;
this.numPlanes=0;
this.numIntersection=0;

this.init=function(planes,enableLocalClipping,camera){

var enabled=
planes.length!==0||
enableLocalClipping||
// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||
localClippingEnabled;

localClippingEnabled=enableLocalClipping;

globalState=projectPlanes(planes,camera,0);
numGlobalPlanes=planes.length;

return enabled;

};

this.beginShadows=function(){

renderingShadows=true;
projectPlanes(null);

};

this.endShadows=function(){

renderingShadows=false;
resetGlobalState();

};

this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){

if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){

// there's no local clipping

if(renderingShadows){

// there's no global clipping

projectPlanes(null);

}else{

resetGlobalState();

}

}else{

var nGlobal=renderingShadows?0:numGlobalPlanes,
lGlobal=nGlobal*4,

dstArray=cache.clippingState||null;

uniform.value=dstArray;// ensure unique state

dstArray=projectPlanes(planes,camera,lGlobal,fromCache);

for(var i=0;i!==lGlobal;++i){

dstArray[i]=globalState[i];

}

cache.clippingState=dstArray;
this.numIntersection=clipIntersection?this.numPlanes:0;
this.numPlanes+=nGlobal;

}


};

function resetGlobalState(){

if(uniform.value!==globalState){

uniform.value=globalState;
uniform.needsUpdate=numGlobalPlanes>0;

}

scope.numPlanes=numGlobalPlanes;
scope.numIntersection=0;

}

function projectPlanes(planes,camera,dstOffset,skipTransform){

var nPlanes=planes!==null?planes.length:0,
dstArray=null;

if(nPlanes!==0){

dstArray=uniform.value;

if(skipTransform!==true||dstArray===null){

var flatSize=dstOffset+nPlanes*4,
viewMatrix=camera.matrixWorldInverse;

viewNormalMatrix.getNormalMatrix(viewMatrix);

if(dstArray===null||dstArray.length<flatSize){

dstArray=new Float32Array(flatSize);

}

for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){

plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);

plane.normal.toArray(dstArray,i4);
dstArray[i4+3]=plane.constant;

}

}

uniform.value=dstArray;
uniform.needsUpdate=true;

}

scope.numPlanes=nPlanes;

return dstArray;

}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions(gl){

var extensions={};

return{

get:function get(name){

if(extensions[name]!==undefined){

return extensions[name];

}

var extension;

switch(name){

case'WEBGL_depth_texture':
extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');
break;

case'EXT_texture_filter_anisotropic':
extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
break;

case'WEBGL_compressed_texture_s3tc':
extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
break;

case'WEBGL_compressed_texture_pvrtc':
extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
break;

default:
extension=gl.getExtension(name);}



if(extension===null){

console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');

}

extensions[name]=extension;

return extension;

}};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries(gl,attributes,info){

var geometries={};
var wireframeAttributes={};

function onGeometryDispose(event){

var geometry=event.target;
var buffergeometry=geometries[geometry.id];

if(buffergeometry.index!==null){

attributes.remove(buffergeometry.index);

}

for(var name in buffergeometry.attributes){

attributes.remove(buffergeometry.attributes[name]);

}

geometry.removeEventListener('dispose',onGeometryDispose);

delete geometries[geometry.id];

var attribute=wireframeAttributes[buffergeometry.id];

if(attribute){

attributes.remove(attribute);
delete wireframeAttributes[buffergeometry.id];

}

//

info.memory.geometries--;

}

function get(object,geometry){

var buffergeometry=geometries[geometry.id];

if(buffergeometry)return buffergeometry;

geometry.addEventListener('dispose',onGeometryDispose);

if(geometry.isBufferGeometry){

buffergeometry=geometry;

}else if(geometry.isGeometry){

if(geometry._bufferGeometry===undefined){

geometry._bufferGeometry=new BufferGeometry().setFromObject(object);

}

buffergeometry=geometry._bufferGeometry;

}

geometries[geometry.id]=buffergeometry;

info.memory.geometries++;

return buffergeometry;

}

function update(geometry){

var index=geometry.index;
var geometryAttributes=geometry.attributes;

if(index!==null){

attributes.update(index,34963);

}

for(var name in geometryAttributes){

attributes.update(geometryAttributes[name],34962);

}

// morph targets

var morphAttributes=geometry.morphAttributes;

for(var name in morphAttributes){

var array=morphAttributes[name];

for(var i=0,l=array.length;i<l;i++){

attributes.update(array[i],34962);

}

}

}

function getWireframeAttribute(geometry){

var attribute=wireframeAttributes[geometry.id];

if(attribute)return attribute;

var indices=[];

var geometryIndex=geometry.index;
var geometryAttributes=geometry.attributes;

// console.time( 'wireframe' );

if(geometryIndex!==null){

var array=geometryIndex.array;

for(var i=0,l=array.length;i<l;i+=3){

var a=array[i+0];
var b=array[i+1];
var c=array[i+2];

indices.push(a,b,b,c,c,a);

}

}else{

var array=geometryAttributes.position.array;

for(var i=0,l=array.length/3-1;i<l;i+=3){

var a=i+0;
var b=i+1;
var c=i+2;

indices.push(a,b,b,c,c,a);

}

}

// console.timeEnd( 'wireframe' );

attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);

attributes.update(attribute,34963);

wireframeAttributes[geometry.id]=attribute;

return attribute;

}

return{

get:get,
update:update,

getWireframeAttribute:getWireframeAttribute};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){

var mode;

function setMode(value){

mode=value;

}

var type,bytesPerElement;

function setIndex(value){

type=value.type;
bytesPerElement=value.bytesPerElement;

}

function render(start,count){

gl.drawElements(mode,count,type,start*bytesPerElement);

info.update(count,mode);

}

function renderInstances(geometry,start,count){

var extension;

if(capabilities.isWebGL2){

extension=gl;

}else{

var extension=extensions.get('ANGLE_instanced_arrays');

if(extension===null){

console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
return;

}

}

extension[capabilities.isWebGL2?'drawElementsInstanced':'drawElementsInstancedANGLE'](mode,count,type,start*bytesPerElement,geometry.maxInstancedCount);

info.update(count,mode,geometry.maxInstancedCount);

}

//

this.setMode=setMode;
this.setIndex=setIndex;
this.render=render;
this.renderInstances=renderInstances;

}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLInfo(gl){

var memory={
geometries:0,
textures:0};


var render={
frame:0,
calls:0,
triangles:0,
points:0,
lines:0};


function update(count,mode,instanceCount){

instanceCount=instanceCount||1;

render.calls++;

switch(mode){

case 4:
render.triangles+=instanceCount*(count/3);
break;

case 5:
case 6:
render.triangles+=instanceCount*(count-2);
break;

case 1:
render.lines+=instanceCount*(count/2);
break;

case 3:
render.lines+=instanceCount*(count-1);
break;

case 2:
render.lines+=instanceCount*count;
break;

case 0:
render.points+=instanceCount*count;
break;

default:
console.error('THREE.WebGLInfo: Unknown draw mode:',mode);
break;}



}

function reset(){

render.frame++;
render.calls=0;
render.triangles=0;
render.points=0;
render.lines=0;

}

return{
memory:memory,
render:render,
programs:null,
autoReset:true,
reset:reset,
update:update};


}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function absNumericalSort(a,b){

return Math.abs(b[1])-Math.abs(a[1]);

}

function WebGLMorphtargets(gl){

var influencesList={};
var morphInfluences=new Float32Array(8);

function update(object,geometry,material,program){

var objectInfluences=object.morphTargetInfluences;

var length=objectInfluences.length;

var influences=influencesList[geometry.id];

if(influences===undefined){

// initialise list

influences=[];

for(var i=0;i<length;i++){

influences[i]=[i,0];

}

influencesList[geometry.id]=influences;

}

var morphTargets=material.morphTargets&&geometry.morphAttributes.position;
var morphNormals=material.morphNormals&&geometry.morphAttributes.normal;

// Remove current morphAttributes

for(var i=0;i<length;i++){

var influence=influences[i];

if(influence[1]!==0){

if(morphTargets)geometry.removeAttribute('morphTarget'+i);
if(morphNormals)geometry.removeAttribute('morphNormal'+i);

}

}

// Collect influences

for(var i=0;i<length;i++){

var influence=influences[i];

influence[0]=i;
influence[1]=objectInfluences[i];

}

influences.sort(absNumericalSort);

// Add morphAttributes

for(var i=0;i<8;i++){

var influence=influences[i];

if(influence){

var index=influence[0];
var value=influence[1];

if(value){

if(morphTargets)geometry.addAttribute('morphTarget'+i,morphTargets[index]);
if(morphNormals)geometry.addAttribute('morphNormal'+i,morphNormals[index]);

morphInfluences[i]=value;
continue;

}

}

morphInfluences[i]=0;

}

program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);

}

return{

update:update};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects(geometries,info){

var updateList={};

function update(object){

var frame=info.render.frame;

var geometry=object.geometry;
var buffergeometry=geometries.get(object,geometry);

// Update once per frame

if(updateList[buffergeometry.id]!==frame){

if(geometry.isGeometry){

buffergeometry.updateFromObject(object);

}

geometries.update(buffergeometry);

updateList[buffergeometry.id]=frame;

}

return buffergeometry;

}

function dispose(){

updateList={};

}

return{

update:update,
dispose:dispose};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){

images=images!==undefined?images:[];
mapping=mapping!==undefined?mapping:CubeReflectionMapping;
format=format!==undefined?format:RGBFormat;

Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);

this.flipY=false;

}

CubeTexture.prototype=Object.create(Texture.prototype);
CubeTexture.prototype.constructor=CubeTexture;

CubeTexture.prototype.isCubeTexture=true;

Object.defineProperty(CubeTexture.prototype,'images',{

get:function get(){

return this.image;

},

set:function set(value){

this.image=value;

}});



/**
 * @author Takahiro https://github.com/takahirox
 */

function DataTexture2DArray(data,width,height,depth){

Texture.call(this,null);

this.image={data:data,width:width,height:height,depth:depth};

this.magFilter=NearestFilter;
this.minFilter=NearestFilter;

this.wrapR=ClampToEdgeWrapping;

this.generateMipmaps=false;
this.flipY=false;

}

DataTexture2DArray.prototype=Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor=DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray=true;

/**
 * @author Artur Trzesiok
 */

function DataTexture3D(data,width,height,depth){

// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	var texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839

Texture.call(this,null);

this.image={data:data,width:width,height:height,depth:depth};

this.magFilter=NearestFilter;
this.minFilter=NearestFilter;

this.wrapR=ClampToEdgeWrapping;

this.generateMipmaps=false;
this.flipY=false;

}

DataTexture3D.prototype=Object.create(Texture.prototype);
DataTexture3D.prototype.constructor=DataTexture3D;
DataTexture3D.prototype.isDataTexture3D=true;

/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture=new Texture();
var emptyTexture2dArray=new DataTexture2DArray();
var emptyTexture3d=new DataTexture3D();
var emptyCubeTexture=new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32=[];
var arrayCacheI32=[];

// Float32Array caches used for uploading Matrix uniforms

var mat4array=new Float32Array(16);
var mat3array=new Float32Array(9);
var mat2array=new Float32Array(4);

// Flattening for arrays of vectors and matrices

function flatten(array,nBlocks,blockSize){

var firstElem=array[0];

if(firstElem<=0||firstElem>0)return array;
// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983

var n=nBlocks*blockSize,
r=arrayCacheF32[n];

if(r===undefined){

r=new Float32Array(n);
arrayCacheF32[n]=r;

}

if(nBlocks!==0){

firstElem.toArray(r,0);

for(var i=1,offset=0;i!==nBlocks;++i){

offset+=blockSize;
array[i].toArray(r,offset);

}

}

return r;

}

function arraysEqual(a,b){

if(a.length!==b.length)return false;

for(var i=0,l=a.length;i<l;i++){

if(a[i]!==b[i])return false;

}

return true;

}

function copyArray(a,b){

for(var i=0,l=b.length;i<l;i++){

a[i]=b[i];

}

}

// Texture unit allocation

function allocTexUnits(textures,n){

var r=arrayCacheI32[n];

if(r===undefined){

r=new Int32Array(n);
arrayCacheI32[n]=r;

}

for(var i=0;i!==n;++i){
r[i]=textures.allocateTextureUnit();}

return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f(gl,v){

var cache=this.cache;

if(cache[0]===v)return;

gl.uniform1f(this.addr,v);

cache[0]=v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f(gl,v){

var cache=this.cache;

if(v.x!==undefined){

if(cache[0]!==v.x||cache[1]!==v.y){

gl.uniform2f(this.addr,v.x,v.y);

cache[0]=v.x;
cache[1]=v.y;

}

}else{

if(arraysEqual(cache,v))return;

gl.uniform2fv(this.addr,v);

copyArray(cache,v);

}

}

function setValueV3f(gl,v){

var cache=this.cache;

if(v.x!==undefined){

if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){

gl.uniform3f(this.addr,v.x,v.y,v.z);

cache[0]=v.x;
cache[1]=v.y;
cache[2]=v.z;

}

}else if(v.r!==undefined){

if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){

gl.uniform3f(this.addr,v.r,v.g,v.b);

cache[0]=v.r;
cache[1]=v.g;
cache[2]=v.b;

}

}else{

if(arraysEqual(cache,v))return;

gl.uniform3fv(this.addr,v);

copyArray(cache,v);

}

}

function setValueV4f(gl,v){

var cache=this.cache;

if(v.x!==undefined){

if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){

gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);

cache[0]=v.x;
cache[1]=v.y;
cache[2]=v.z;
cache[3]=v.w;

}

}else{

if(arraysEqual(cache,v))return;

gl.uniform4fv(this.addr,v);

copyArray(cache,v);

}

}

// Single matrix (from flat array or MatrixN)

function setValueM2(gl,v){

var cache=this.cache;
var elements=v.elements;

if(elements===undefined){

if(arraysEqual(cache,v))return;

gl.uniformMatrix2fv(this.addr,false,v);

copyArray(cache,v);

}else{

if(arraysEqual(cache,elements))return;

mat2array.set(elements);

gl.uniformMatrix2fv(this.addr,false,mat2array);

copyArray(cache,elements);

}

}

function setValueM3(gl,v){

var cache=this.cache;
var elements=v.elements;

if(elements===undefined){

if(arraysEqual(cache,v))return;

gl.uniformMatrix3fv(this.addr,false,v);

copyArray(cache,v);

}else{

if(arraysEqual(cache,elements))return;

mat3array.set(elements);

gl.uniformMatrix3fv(this.addr,false,mat3array);

copyArray(cache,elements);

}

}

function setValueM4(gl,v){

var cache=this.cache;
var elements=v.elements;

if(elements===undefined){

if(arraysEqual(cache,v))return;

gl.uniformMatrix4fv(this.addr,false,v);

copyArray(cache,v);

}else{

if(arraysEqual(cache,elements))return;

mat4array.set(elements);

gl.uniformMatrix4fv(this.addr,false,mat4array);

copyArray(cache,elements);

}

}

// Single texture (2D / Cube)

function setValueT1(gl,v,textures){

var cache=this.cache;
var unit=textures.allocateTextureUnit();

if(cache[0]!==unit){

gl.uniform1i(this.addr,unit);
cache[0]=unit;

}

textures.safeSetTexture2D(v||emptyTexture,unit);

}

function setValueT2DArray1(gl,v,textures){

var cache=this.cache;
var unit=textures.allocateTextureUnit();

if(cache[0]!==unit){

gl.uniform1i(this.addr,unit);
cache[0]=unit;

}

textures.setTexture2DArray(v||emptyTexture2dArray,unit);

}

function setValueT3D1(gl,v,textures){

var cache=this.cache;
var unit=textures.allocateTextureUnit();

if(cache[0]!==unit){

gl.uniform1i(this.addr,unit);
cache[0]=unit;

}

textures.setTexture3D(v||emptyTexture3d,unit);

}

function setValueT6(gl,v,textures){

var cache=this.cache;
var unit=textures.allocateTextureUnit();

if(cache[0]!==unit){

gl.uniform1i(this.addr,unit);
cache[0]=unit;

}

textures.safeSetTextureCube(v||emptyCubeTexture,unit);

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i(gl,v){

var cache=this.cache;

if(cache[0]===v)return;

gl.uniform1i(this.addr,v);

cache[0]=v;

}

function setValueV2i(gl,v){

var cache=this.cache;

if(arraysEqual(cache,v))return;

gl.uniform2iv(this.addr,v);

copyArray(cache,v);

}

function setValueV3i(gl,v){

var cache=this.cache;

if(arraysEqual(cache,v))return;

gl.uniform3iv(this.addr,v);

copyArray(cache,v);

}

function setValueV4i(gl,v){

var cache=this.cache;

if(arraysEqual(cache,v))return;

gl.uniform4iv(this.addr,v);

copyArray(cache,v);

}

// Helper to pick the right setter for the singular case

function getSingularSetter(type){

switch(type){

case 0x1406:return setValueV1f;// FLOAT
case 0x8b50:return setValueV2f;// _VEC2
case 0x8b51:return setValueV3f;// _VEC3
case 0x8b52:return setValueV4f;// _VEC4

case 0x8b5a:return setValueM2;// _MAT2
case 0x8b5b:return setValueM3;// _MAT3
case 0x8b5c:return setValueM4;// _MAT4

case 0x8b5e:case 0x8d66:return setValueT1;// SAMPLER_2D, SAMPLER_EXTERNAL_OES
case 0x8b5f:return setValueT3D1;// SAMPLER_3D
case 0x8b60:return setValueT6;// SAMPLER_CUBE
case 0x8DC1:return setValueT2DArray1;// SAMPLER_2D_ARRAY

case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
}


}

// Array of scalars
function setValueV1fArray(gl,v){

gl.uniform1fv(this.addr,v);

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl,v){

gl.uniform1iv(this.addr,v);

}

function setValueV2iArray(gl,v){

gl.uniform2iv(this.addr,v);

}

function setValueV3iArray(gl,v){

gl.uniform3iv(this.addr,v);

}

function setValueV4iArray(gl,v){

gl.uniform4iv(this.addr,v);

}


// Array of vectors (flat or from THREE classes)

function setValueV2fArray(gl,v){

var data=flatten(v,this.size,2);

gl.uniform2fv(this.addr,data);

}

function setValueV3fArray(gl,v){

var data=flatten(v,this.size,3);

gl.uniform3fv(this.addr,data);

}

function setValueV4fArray(gl,v){

var data=flatten(v,this.size,4);

gl.uniform4fv(this.addr,data);

}

// Array of matrices (flat or from THREE clases)

function setValueM2Array(gl,v){

var data=flatten(v,this.size,4);

gl.uniformMatrix2fv(this.addr,false,data);

}

function setValueM3Array(gl,v){

var data=flatten(v,this.size,9);

gl.uniformMatrix3fv(this.addr,false,data);

}

function setValueM4Array(gl,v){

var data=flatten(v,this.size,16);

gl.uniformMatrix4fv(this.addr,false,data);

}

// Array of textures (2D / Cube)

function setValueT1Array(gl,v,textures){

var n=v.length;

var units=allocTexUnits(textures,n);

gl.uniform1iv(this.addr,units);

for(var i=0;i!==n;++i){

textures.safeSetTexture2D(v[i]||emptyTexture,units[i]);

}

}

function setValueT6Array(gl,v,textures){

var n=v.length;

var units=allocTexUnits(textures,n);

gl.uniform1iv(this.addr,units);

for(var i=0;i!==n;++i){

textures.safeSetTextureCube(v[i]||emptyCubeTexture,units[i]);

}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter(type){

switch(type){

case 0x1406:return setValueV1fArray;// FLOAT
case 0x8b50:return setValueV2fArray;// _VEC2
case 0x8b51:return setValueV3fArray;// _VEC3
case 0x8b52:return setValueV4fArray;// _VEC4

case 0x8b5a:return setValueM2Array;// _MAT2
case 0x8b5b:return setValueM3Array;// _MAT3
case 0x8b5c:return setValueM4Array;// _MAT4

case 0x8b5e:return setValueT1Array;// SAMPLER_2D
case 0x8b60:return setValueT6Array;// SAMPLER_CUBE

case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
}


}

// --- Uniform Classes ---

function SingleUniform(id,activeInfo,addr){

this.id=id;
this.addr=addr;
this.cache=[];
this.setValue=getSingularSetter(activeInfo.type);

// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform(id,activeInfo,addr){

this.id=id;
this.addr=addr;
this.cache=[];
this.size=activeInfo.size;
this.setValue=getPureArraySetter(activeInfo.type);

// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache=function(data){

var cache=this.cache;

if(data instanceof Float32Array&&cache.length!==data.length){

this.cache=new Float32Array(data.length);

}

copyArray(cache,data);

};

function StructuredUniform(id){

this.id=id;

this.seq=[];
this.map={};

}

StructuredUniform.prototype.setValue=function(gl,value,textures){

var seq=this.seq;

for(var i=0,n=seq.length;i!==n;++i){

var u=seq[i];
u.setValue(gl,value[u.id],textures);

}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container,uniformObject){

container.seq.push(uniformObject);
container.map[uniformObject.id]=uniformObject;

}

function parseUniform(activeInfo,addr,container){

var path=activeInfo.name,
pathLength=path.length;

// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;

while(true){

var match=RePathPart.exec(path),
matchEnd=RePathPart.lastIndex,

id=match[1],
idIsIndex=match[2]===']',
subscript=match[3];

if(idIsIndex)id=id|0;// convert to integer

if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){

// bare name or "pure" bottom-level array "[0]" suffix

addUniform(container,subscript===undefined?
new SingleUniform(id,activeInfo,addr):
new PureArrayUniform(id,activeInfo,addr));

break;

}else{

// step into inner node / create it in case it doesn't exist

var map=container.map,next=map[id];

if(next===undefined){

next=new StructuredUniform(id);
addUniform(container,next);

}

container=next;

}

}

}

// Root Container

function WebGLUniforms(gl,program){

this.seq=[];
this.map={};

var n=gl.getProgramParameter(program,35718);

for(var i=0;i<n;++i){

var info=gl.getActiveUniform(program,i),
addr=gl.getUniformLocation(program,info.name);

parseUniform(info,addr,this);

}

}

WebGLUniforms.prototype.setValue=function(gl,name,value,textures){

var u=this.map[name];

if(u!==undefined)u.setValue(gl,value,textures);

};

WebGLUniforms.prototype.setOptional=function(gl,object,name){

var v=object[name];

if(v!==undefined)this.setValue(gl,name,v);

};


// Static interface

WebGLUniforms.upload=function(gl,seq,values,textures){

for(var i=0,n=seq.length;i!==n;++i){

var u=seq[i],
v=values[u.id];

if(v.needsUpdate!==false){

// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,textures);

}

}

};

WebGLUniforms.seqWithValue=function(seq,values){

var r=[];

for(var i=0,n=seq.length;i!==n;++i){

var u=seq[i];
if(u.id in values)r.push(u);

}

return r;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function addLineNumbers(string){

var lines=string.split('\n');

for(var i=0;i<lines.length;i++){

lines[i]=i+1+': '+lines[i];

}

return lines.join('\n');

}

function WebGLShader(gl,type,string,debug){

var shader=gl.createShader(type);

gl.shaderSource(shader,string);
gl.compileShader(shader);

if(debug===true){

if(gl.getShaderParameter(shader,35713)===false){

console.error('THREE.WebGLShader: Shader couldn\'t compile.');

}

if(gl.getShaderInfoLog(shader)!==''){

console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===35633?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));

}

}

// --enable-privileged-webgl-extension
// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount=0;

function getEncodingComponents(encoding){

switch(encoding){

case LinearEncoding:
return['Linear','( value )'];
case sRGBEncoding:
return['sRGB','( value )'];
case RGBEEncoding:
return['RGBE','( value )'];
case RGBM7Encoding:
return['RGBM','( value, 7.0 )'];
case RGBM16Encoding:
return['RGBM','( value, 16.0 )'];
case RGBDEncoding:
return['RGBD','( value, 256.0 )'];
case GammaEncoding:
return['Gamma','( value, float( GAMMA_FACTOR ) )'];
default:
throw new Error('unsupported encoding: '+encoding);}



}

function getTexelDecodingFunction(functionName,encoding){

var components=getEncodingComponents(encoding);
return'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';

}

function getTexelEncodingFunction(functionName,encoding){

var components=getEncodingComponents(encoding);
return'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';

}

function getToneMappingFunction(functionName,toneMapping){

var toneMappingName;

switch(toneMapping){

case LinearToneMapping:
toneMappingName='Linear';
break;

case ReinhardToneMapping:
toneMappingName='Reinhard';
break;

case Uncharted2ToneMapping:
toneMappingName='Uncharted2';
break;

case CineonToneMapping:
toneMappingName='OptimizedCineon';
break;

case ACESFilmicToneMapping:
toneMappingName='ACESFilmic';
break;

default:
throw new Error('unsupported toneMapping: '+toneMapping);}



return'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';

}

function generateExtensions(extensions,parameters,rendererExtensions){

extensions=extensions||{};

var chunks=[
extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap&&!parameters.objectSpaceNormalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',
(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',
extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',
(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];


return chunks.filter(filterEmptyLine).join('\n');

}

function generateDefines(defines){

var chunks=[];

for(var name in defines){

var value=defines[name];

if(value===false)continue;

chunks.push('#define '+name+' '+value);

}

return chunks.join('\n');

}

function fetchAttributeLocations(gl,program){

var attributes={};

var n=gl.getProgramParameter(program,35721);

for(var i=0;i<n;i++){

var info=gl.getActiveAttrib(program,i);
var name=info.name;

// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

attributes[name]=gl.getAttribLocation(program,name);

}

return attributes;

}

function filterEmptyLine(string){

return string!=='';

}

function replaceLightNums(string,parameters){

return string.
replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).
replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).
replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).
replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).
replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);

}

function replaceClippingPlaneNums(string,parameters){

return string.
replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).
replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);

}

function parseIncludes(string){

var pattern=/^[ \t]*#include +<([\w\d./]+)>/gm;

function replace(match,include){

var replace=ShaderChunk[include];

if(replace===undefined){

throw new Error('Can not resolve #include <'+include+'>');

}

return parseIncludes(replace);

}

return string.replace(pattern,replace);

}

function unrollLoops(string){

var pattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

function replace(match,start,end,snippet){

var unroll='';

for(var i=parseInt(start);i<parseInt(end);i++){

unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');

}

return unroll;

}

return string.replace(pattern,replace);

}

function WebGLProgram(renderer,extensions,code,material,shader,parameters,capabilities,textures){

var gl=renderer.context;

var defines=material.defines;

var vertexShader=shader.vertexShader;
var fragmentShader=shader.fragmentShader;

var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';

if(parameters.shadowMapType===PCFShadowMap){

shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';

}else if(parameters.shadowMapType===PCFSoftShadowMap){

shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';

}

var envMapTypeDefine='ENVMAP_TYPE_CUBE';
var envMapModeDefine='ENVMAP_MODE_REFLECTION';
var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';

if(parameters.envMap){

switch(material.envMap.mapping){

case CubeReflectionMapping:
case CubeRefractionMapping:
envMapTypeDefine='ENVMAP_TYPE_CUBE';
break;

case CubeUVReflectionMapping:
case CubeUVRefractionMapping:
envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';
break;

case EquirectangularReflectionMapping:
case EquirectangularRefractionMapping:
envMapTypeDefine='ENVMAP_TYPE_EQUIREC';
break;

case SphericalReflectionMapping:
envMapTypeDefine='ENVMAP_TYPE_SPHERE';
break;}



switch(material.envMap.mapping){

case CubeRefractionMapping:
case EquirectangularRefractionMapping:
envMapModeDefine='ENVMAP_MODE_REFRACTION';
break;}



switch(material.combine){

case MultiplyOperation:
envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';
break;

case MixOperation:
envMapBlendingDefine='ENVMAP_BLENDING_MIX';
break;

case AddOperation:
envMapBlendingDefine='ENVMAP_BLENDING_ADD';
break;}



}

var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;

// console.log( 'building new program ' );

//

var customExtensions=capabilities.isWebGL2?'':generateExtensions(material.extensions,parameters,extensions);

var customDefines=generateDefines(defines);

//

var program=gl.createProgram();

var prefixVertex,prefixFragment;

if(material.isRawShaderMaterial){

prefixVertex=[

customDefines].

filter(filterEmptyLine).join('\n');

if(prefixVertex.length>0){

prefixVertex+='\n';

}

prefixFragment=[

customExtensions,
customDefines].

filter(filterEmptyLine).join('\n');

if(prefixFragment.length>0){

prefixFragment+='\n';

}

}else{

prefixVertex=[

'precision '+parameters.precision+' float;',
'precision '+parameters.precision+' int;',

'#define SHADER_NAME '+shader.name,

customDefines,

parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'',

'#define GAMMA_FACTOR '+gammaFactorDefine,

'#define MAX_BONES '+parameters.maxBones,
parameters.useFog&&parameters.fog?'#define USE_FOG':'',
parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',

parameters.map?'#define USE_MAP':'',
parameters.envMap?'#define USE_ENVMAP':'',
parameters.envMap?'#define '+envMapModeDefine:'',
parameters.lightMap?'#define USE_LIGHTMAP':'',
parameters.aoMap?'#define USE_AOMAP':'',
parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',
parameters.bumpMap?'#define USE_BUMPMAP':'',
parameters.normalMap?'#define USE_NORMALMAP':'',
parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',
parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',
parameters.specularMap?'#define USE_SPECULARMAP':'',
parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',
parameters.metalnessMap?'#define USE_METALNESSMAP':'',
parameters.alphaMap?'#define USE_ALPHAMAP':'',

parameters.vertexTangents?'#define USE_TANGENT':'',
parameters.vertexColors?'#define USE_COLOR':'',

parameters.flatShading?'#define FLAT_SHADED':'',

parameters.skinning?'#define USE_SKINNING':'',
parameters.useVertexTexture?'#define BONE_TEXTURE':'',

parameters.morphTargets?'#define USE_MORPHTARGETS':'',
parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',
parameters.doubleSided?'#define DOUBLE_SIDED':'',
parameters.flipSided?'#define FLIP_SIDED':'',

parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',
parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',

parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',

parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',
parameters.logarithmicDepthBuffer&&(capabilities.isWebGL2||extensions.get('EXT_frag_depth'))?'#define USE_LOGDEPTHBUF_EXT':'',

'uniform mat4 modelMatrix;',
'uniform mat4 modelViewMatrix;',
'uniform mat4 projectionMatrix;',
'uniform mat4 viewMatrix;',
'uniform mat3 normalMatrix;',
'uniform vec3 cameraPosition;',

'attribute vec3 position;',
'attribute vec3 normal;',
'attribute vec2 uv;',

'#ifdef USE_TANGENT',

'	attribute vec4 tangent;',

'#endif',

'#ifdef USE_COLOR',

'	attribute vec3 color;',

'#endif',

'#ifdef USE_MORPHTARGETS',

'	attribute vec3 morphTarget0;',
'	attribute vec3 morphTarget1;',
'	attribute vec3 morphTarget2;',
'	attribute vec3 morphTarget3;',

'	#ifdef USE_MORPHNORMALS',

'		attribute vec3 morphNormal0;',
'		attribute vec3 morphNormal1;',
'		attribute vec3 morphNormal2;',
'		attribute vec3 morphNormal3;',

'	#else',

'		attribute vec3 morphTarget4;',
'		attribute vec3 morphTarget5;',
'		attribute vec3 morphTarget6;',
'		attribute vec3 morphTarget7;',

'	#endif',

'#endif',

'#ifdef USE_SKINNING',

'	attribute vec4 skinIndex;',
'	attribute vec4 skinWeight;',

'#endif',

'\n'].

filter(filterEmptyLine).join('\n');

prefixFragment=[

customExtensions,

'precision '+parameters.precision+' float;',
'precision '+parameters.precision+' int;',

'#define SHADER_NAME '+shader.name,

customDefines,

parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest+(parameters.alphaTest%1?'':'.0'):'',// add '.0' if integer

'#define GAMMA_FACTOR '+gammaFactorDefine,

parameters.useFog&&parameters.fog?'#define USE_FOG':'',
parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',

parameters.map?'#define USE_MAP':'',
parameters.matcap?'#define USE_MATCAP':'',
parameters.envMap?'#define USE_ENVMAP':'',
parameters.envMap?'#define '+envMapTypeDefine:'',
parameters.envMap?'#define '+envMapModeDefine:'',
parameters.envMap?'#define '+envMapBlendingDefine:'',
parameters.lightMap?'#define USE_LIGHTMAP':'',
parameters.aoMap?'#define USE_AOMAP':'',
parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',
parameters.bumpMap?'#define USE_BUMPMAP':'',
parameters.normalMap?'#define USE_NORMALMAP':'',
parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',
parameters.specularMap?'#define USE_SPECULARMAP':'',
parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',
parameters.metalnessMap?'#define USE_METALNESSMAP':'',
parameters.alphaMap?'#define USE_ALPHAMAP':'',

parameters.vertexTangents?'#define USE_TANGENT':'',
parameters.vertexColors?'#define USE_COLOR':'',

parameters.gradientMap?'#define USE_GRADIENTMAP':'',

parameters.flatShading?'#define FLAT_SHADED':'',

parameters.doubleSided?'#define DOUBLE_SIDED':'',
parameters.flipSided?'#define FLIP_SIDED':'',

parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',
parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',

parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',

parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',

parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',
parameters.logarithmicDepthBuffer&&(capabilities.isWebGL2||extensions.get('EXT_frag_depth'))?'#define USE_LOGDEPTHBUF_EXT':'',

parameters.envMap&&(capabilities.isWebGL2||extensions.get('EXT_shader_texture_lod'))?'#define TEXTURE_LOD_EXT':'',

'uniform mat4 viewMatrix;',
'uniform vec3 cameraPosition;',

parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',
parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',

parameters.dithering?'#define DITHERING':'',

parameters.outputEncoding||parameters.mapEncoding||parameters.matcapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?
ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',
parameters.matcapEncoding?getTexelDecodingFunction('matcapTexelToLinear',parameters.matcapEncoding):'',
parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',
parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',
parameters.outputEncoding?getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding):'',

parameters.depthPacking?'#define DEPTH_PACKING '+material.depthPacking:'',

'\n'].

filter(filterEmptyLine).join('\n');

}

vertexShader=parseIncludes(vertexShader);
vertexShader=replaceLightNums(vertexShader,parameters);
vertexShader=replaceClippingPlaneNums(vertexShader,parameters);

fragmentShader=parseIncludes(fragmentShader);
fragmentShader=replaceLightNums(fragmentShader,parameters);
fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);

vertexShader=unrollLoops(vertexShader);
fragmentShader=unrollLoops(fragmentShader);

if(capabilities.isWebGL2&&!material.isRawShaderMaterial){

var isGLSL3ShaderMaterial=false;

var versionRegex=/^\s*#version\s+300\s+es\s*\n/;

if(material.isShaderMaterial&&
vertexShader.match(versionRegex)!==null&&
fragmentShader.match(versionRegex)!==null){

isGLSL3ShaderMaterial=true;

vertexShader=vertexShader.replace(versionRegex,'');
fragmentShader=fragmentShader.replace(versionRegex,'');

}

// GLSL 3.0 conversion
prefixVertex=[
'#version 300 es\n',
'#define attribute in',
'#define varying out',
'#define texture2D texture'].
join('\n')+'\n'+prefixVertex;

prefixFragment=[
'#version 300 es\n',
'#define varying in',
isGLSL3ShaderMaterial?'':'out highp vec4 pc_fragColor;',
isGLSL3ShaderMaterial?'':'#define gl_FragColor pc_fragColor',
'#define gl_FragDepthEXT gl_FragDepth',
'#define texture2D texture',
'#define textureCube texture',
'#define texture2DProj textureProj',
'#define texture2DLodEXT textureLod',
'#define texture2DProjLodEXT textureProjLod',
'#define textureCubeLodEXT textureLod',
'#define texture2DGradEXT textureGrad',
'#define texture2DProjGradEXT textureProjGrad',
'#define textureCubeGradEXT textureGrad'].
join('\n')+'\n'+prefixFragment;

}

var vertexGlsl=prefixVertex+vertexShader;
var fragmentGlsl=prefixFragment+fragmentShader;

// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );

var glVertexShader=WebGLShader(gl,35633,vertexGlsl,renderer.debug.checkShaderErrors);
var glFragmentShader=WebGLShader(gl,35632,fragmentGlsl,renderer.debug.checkShaderErrors);

gl.attachShader(program,glVertexShader);
gl.attachShader(program,glFragmentShader);

// Force a particular attribute to index 0.

if(material.index0AttributeName!==undefined){

gl.bindAttribLocation(program,0,material.index0AttributeName);

}else if(parameters.morphTargets===true){

// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');

}

gl.linkProgram(program);

// check for link errors
if(renderer.debug.checkShaderErrors){

var programLog=gl.getProgramInfoLog(program).trim();
var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();
var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();

var runnable=true;
var haveDiagnostics=true;

// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

if(gl.getProgramParameter(program,35714)===false){

runnable=false;

console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'35715',gl.getProgramParameter(program,35715),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);

}else if(programLog!==''){

console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);

}else if(vertexLog===''||fragmentLog===''){

haveDiagnostics=false;

}

if(haveDiagnostics){

this.diagnostics={

runnable:runnable,
material:material,

programLog:programLog,

vertexShader:{

log:vertexLog,
prefix:prefixVertex},



fragmentShader:{

log:fragmentLog,
prefix:prefixFragment}};





}

}

// clean up

gl.deleteShader(glVertexShader);
gl.deleteShader(glFragmentShader);

// set up caching for uniform locations

var cachedUniforms;

this.getUniforms=function(){

if(cachedUniforms===undefined){

cachedUniforms=new WebGLUniforms(gl,program,textures);

}

return cachedUniforms;

};

// set up caching for attribute locations

var cachedAttributes;

this.getAttributes=function(){

if(cachedAttributes===undefined){

cachedAttributes=fetchAttributeLocations(gl,program);

}

return cachedAttributes;

};

// free resource

this.destroy=function(){

gl.deleteProgram(program);
this.program=undefined;

};

// DEPRECATED

Object.defineProperties(this,{

uniforms:{
get:function get(){

console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
return this.getUniforms();

}},


attributes:{
get:function get(){

console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
return this.getAttributes();

}}});





//

this.name=shader.name;
this.id=programIdCount++;
this.code=code;
this.usedTimes=1;
this.program=program;
this.vertexShader=glVertexShader;
this.fragmentShader=glFragmentShader;

return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms(renderer,extensions,capabilities,textures){

var programs=[];

var shaderIDs={
MeshDepthMaterial:'depth',
MeshDistanceMaterial:'distanceRGBA',
MeshNormalMaterial:'normal',
MeshBasicMaterial:'basic',
MeshLambertMaterial:'lambert',
MeshPhongMaterial:'phong',
MeshToonMaterial:'phong',
MeshStandardMaterial:'physical',
MeshPhysicalMaterial:'physical',
MeshMatcapMaterial:'matcap',
LineBasicMaterial:'basic',
LineDashedMaterial:'dashed',
PointsMaterial:'points',
ShadowMaterial:'shadow',
SpriteMaterial:'sprite'};


var parameterNames=[
"precision","supportsVertexTextures","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding",
"lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","displacementMap","specularMap",
"roughnessMap","metalnessMap","gradientMap",
"alphaMap","combine","vertexColors","vertexTangents","fog","useFog","fogExp",
"flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning",
"maxBones","useVertexTexture","morphTargets","morphNormals",
"maxMorphTargets","maxMorphNormals","premultipliedAlpha",
"numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights",
"shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',
"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];



function allocateBones(object){

var skeleton=object.skeleton;
var bones=skeleton.bones;

if(capabilities.floatVertexTextures){

return 1024;

}else{

// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)

var nVertexUniforms=capabilities.maxVertexUniforms;
var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);

var maxBones=Math.min(nVertexMatrices,bones.length);

if(maxBones<bones.length){

console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');
return 0;

}

return maxBones;

}

}

function getTextureEncodingFromMap(map,gammaOverrideLinear){

var encoding;

if(!map){

encoding=LinearEncoding;

}else if(map.isTexture){

encoding=map.encoding;

}else if(map.isWebGLRenderTarget){

console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
encoding=map.texture.encoding;

}

// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
if(encoding===LinearEncoding&&gammaOverrideLinear){

encoding=GammaEncoding;

}

return encoding;

}

this.getParameters=function(material,lights,shadows,fog,nClipPlanes,nClipIntersection,object){

var shaderID=shaderIDs[material.type];

// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)

var maxBones=object.isSkinnedMesh?allocateBones(object):0;
var precision=capabilities.precision;

if(material.precision!==null){

precision=capabilities.getMaxPrecision(material.precision);

if(precision!==material.precision){

console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');

}

}

var currentRenderTarget=renderer.getRenderTarget();

var parameters={

shaderID:shaderID,

precision:precision,
supportsVertexTextures:capabilities.vertexTextures,
outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),
map:!!material.map,
mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),
matcap:!!material.matcap,
matcapEncoding:getTextureEncodingFromMap(material.matcap,renderer.gammaInput),
envMap:!!material.envMap,
envMapMode:material.envMap&&material.envMap.mapping,
envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),
envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),
lightMap:!!material.lightMap,
aoMap:!!material.aoMap,
emissiveMap:!!material.emissiveMap,
emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),
bumpMap:!!material.bumpMap,
normalMap:!!material.normalMap,
objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,
displacementMap:!!material.displacementMap,
roughnessMap:!!material.roughnessMap,
metalnessMap:!!material.metalnessMap,
specularMap:!!material.specularMap,
alphaMap:!!material.alphaMap,

gradientMap:!!material.gradientMap,

combine:material.combine,

vertexTangents:material.normalMap&&material.vertexTangents,
vertexColors:material.vertexColors,

fog:!!fog,
useFog:material.fog,
fogExp:fog&&fog.isFogExp2,

flatShading:material.flatShading,

sizeAttenuation:material.sizeAttenuation,
logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,

skinning:material.skinning&&maxBones>0,
maxBones:maxBones,
useVertexTexture:capabilities.floatVertexTextures,

morphTargets:material.morphTargets,
morphNormals:material.morphNormals,
maxMorphTargets:renderer.maxMorphTargets,
maxMorphNormals:renderer.maxMorphNormals,

numDirLights:lights.directional.length,
numPointLights:lights.point.length,
numSpotLights:lights.spot.length,
numRectAreaLights:lights.rectArea.length,
numHemiLights:lights.hemi.length,

numClippingPlanes:nClipPlanes,
numClipIntersection:nClipIntersection,

dithering:material.dithering,

shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&shadows.length>0,
shadowMapType:renderer.shadowMap.type,

toneMapping:renderer.toneMapping,
physicallyCorrectLights:renderer.physicallyCorrectLights,

premultipliedAlpha:material.premultipliedAlpha,

alphaTest:material.alphaTest,
doubleSided:material.side===DoubleSide,
flipSided:material.side===BackSide,

depthPacking:material.depthPacking!==undefined?material.depthPacking:false};



return parameters;

};

this.getProgramCode=function(material,parameters){

var array=[];

if(parameters.shaderID){

array.push(parameters.shaderID);

}else{

array.push(material.fragmentShader);
array.push(material.vertexShader);

}

if(material.defines!==undefined){

for(var name in material.defines){

array.push(name);
array.push(material.defines[name]);

}

}

for(var i=0;i<parameterNames.length;i++){

array.push(parameters[parameterNames[i]]);

}

array.push(material.onBeforeCompile.toString());

array.push(renderer.gammaOutput);

array.push(renderer.gammaFactor);

return array.join();

};

this.acquireProgram=function(material,shader,parameters,code){

var program;

// Check if code has been already compiled
for(var p=0,pl=programs.length;p<pl;p++){

var programInfo=programs[p];

if(programInfo.code===code){

program=programInfo;
++program.usedTimes;

break;

}

}

if(program===undefined){

program=new WebGLProgram(renderer,extensions,code,material,shader,parameters,capabilities,textures);
programs.push(program);

}

return program;

};

this.releaseProgram=function(program){

if(--program.usedTimes===0){

// Remove from unordered set
var i=programs.indexOf(program);
programs[i]=programs[programs.length-1];
programs.pop();

// Free WebGL resources
program.destroy();

}

};

// Exposed for resource monitoring & error feedback via renderer.info:
this.programs=programs;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties(){

var properties=new WeakMap();

function get(object){

var map=properties.get(object);

if(map===undefined){

map={};
properties.set(object,map);

}

return map;

}

function remove(object){

properties.delete(object);

}

function update(object,key,value){

properties.get(object)[key]=value;

}

function dispose(){

properties=new WeakMap();

}

return{
get:get,
remove:remove,
update:update,
dispose:dispose};


}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function painterSortStable(a,b){

if(a.groupOrder!==b.groupOrder){

return a.groupOrder-b.groupOrder;

}else if(a.renderOrder!==b.renderOrder){

return a.renderOrder-b.renderOrder;

}else if(a.program!==b.program){

return a.program.id-b.program.id;

}else if(a.material.id!==b.material.id){

return a.material.id-b.material.id;

}else if(a.z!==b.z){

return a.z-b.z;

}else{

return a.id-b.id;

}

}

function reversePainterSortStable(a,b){

if(a.groupOrder!==b.groupOrder){

return a.groupOrder-b.groupOrder;

}else if(a.renderOrder!==b.renderOrder){

return a.renderOrder-b.renderOrder;

}else if(a.z!==b.z){

return b.z-a.z;

}else{

return a.id-b.id;

}

}


function WebGLRenderList(){

var renderItems=[];
var renderItemsIndex=0;

var opaque=[];
var transparent=[];

var defaultProgram={id:-1};

function init(){

renderItemsIndex=0;

opaque.length=0;
transparent.length=0;

}

function getNextRenderItem(object,geometry,material,groupOrder,z,group){

var renderItem=renderItems[renderItemsIndex];

if(renderItem===undefined){

renderItem={
id:object.id,
object:object,
geometry:geometry,
material:material,
program:material.program||defaultProgram,
groupOrder:groupOrder,
renderOrder:object.renderOrder,
z:z,
group:group};


renderItems[renderItemsIndex]=renderItem;

}else{

renderItem.id=object.id;
renderItem.object=object;
renderItem.geometry=geometry;
renderItem.material=material;
renderItem.program=material.program||defaultProgram;
renderItem.groupOrder=groupOrder;
renderItem.renderOrder=object.renderOrder;
renderItem.z=z;
renderItem.group=group;

}

renderItemsIndex++;

return renderItem;

}

function push(object,geometry,material,groupOrder,z,group){

var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);

(material.transparent===true?transparent:opaque).push(renderItem);

}

function unshift(object,geometry,material,groupOrder,z,group){

var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);

(material.transparent===true?transparent:opaque).unshift(renderItem);

}

function sort(){

if(opaque.length>1)opaque.sort(painterSortStable);
if(transparent.length>1)transparent.sort(reversePainterSortStable);

}

return{
opaque:opaque,
transparent:transparent,

init:init,
push:push,
unshift:unshift,

sort:sort};


}

function WebGLRenderLists(){

var lists={};

function onSceneDispose(event){

var scene=event.target;

scene.removeEventListener('dispose',onSceneDispose);

delete lists[scene.id];

}

function get(scene,camera){

var cameras=lists[scene.id];
var list;
if(cameras===undefined){

list=new WebGLRenderList();
lists[scene.id]={};
lists[scene.id][camera.id]=list;

scene.addEventListener('dispose',onSceneDispose);

}else{

list=cameras[camera.id];
if(list===undefined){

list=new WebGLRenderList();
cameras[camera.id]=list;

}

}

return list;

}

function dispose(){

lists={};

}

return{
get:get,
dispose:dispose};


}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function UniformsCache(){

var lights={};

return{

get:function get(light){

if(lights[light.id]!==undefined){

return lights[light.id];

}

var uniforms;

switch(light.type){

case'DirectionalLight':
uniforms={
direction:new Vector3(),
color:new Color(),

shadow:false,
shadowBias:0,
shadowRadius:1,
shadowMapSize:new Vector2()};

break;

case'SpotLight':
uniforms={
position:new Vector3(),
direction:new Vector3(),
color:new Color(),
distance:0,
coneCos:0,
penumbraCos:0,
decay:0,

shadow:false,
shadowBias:0,
shadowRadius:1,
shadowMapSize:new Vector2()};

break;

case'PointLight':
uniforms={
position:new Vector3(),
color:new Color(),
distance:0,
decay:0,

shadow:false,
shadowBias:0,
shadowRadius:1,
shadowMapSize:new Vector2(),
shadowCameraNear:1,
shadowCameraFar:1000};

break;

case'HemisphereLight':
uniforms={
direction:new Vector3(),
skyColor:new Color(),
groundColor:new Color()};

break;

case'RectAreaLight':
uniforms={
color:new Color(),
position:new Vector3(),
halfWidth:new Vector3(),
halfHeight:new Vector3()
// TODO (abelnation): set RectAreaLight shadow uniforms
};
break;}



lights[light.id]=uniforms;

return uniforms;

}};



}

var three_module_count=0;

function WebGLLights(){

var cache=new UniformsCache();

var state={

id:three_module_count++,

hash:{
stateID:-1,
directionalLength:-1,
pointLength:-1,
spotLength:-1,
rectAreaLength:-1,
hemiLength:-1,
shadowsLength:-1},


ambient:[0,0,0],
probe:[],
directional:[],
directionalShadowMap:[],
directionalShadowMatrix:[],
spot:[],
spotShadowMap:[],
spotShadowMatrix:[],
rectArea:[],
point:[],
pointShadowMap:[],
pointShadowMatrix:[],
hemi:[]};



for(var i=0;i<9;i++){state.probe.push(new Vector3());}

var vector3=new Vector3();
var matrix4=new Matrix4();
var matrix42=new Matrix4();

function setup(lights,shadows,camera){

var r=0,g=0,b=0;

for(var i=0;i<9;i++){state.probe[i].set(0,0,0);}

var directionalLength=0;
var pointLength=0;
var spotLength=0;
var rectAreaLength=0;
var hemiLength=0;

var viewMatrix=camera.matrixWorldInverse;

for(var i=0,l=lights.length;i<l;i++){

var light=lights[i];

var color=light.color;
var intensity=light.intensity;
var distance=light.distance;

var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;

if(light.isAmbientLight){

r+=color.r*intensity;
g+=color.g*intensity;
b+=color.b*intensity;

}else if(light.isLightProbe){

for(var j=0;j<9;j++){

state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);

}

}else if(light.isDirectionalLight){

var uniforms=cache.get(light);

uniforms.color.copy(light.color).multiplyScalar(light.intensity);
uniforms.direction.setFromMatrixPosition(light.matrixWorld);
vector3.setFromMatrixPosition(light.target.matrixWorld);
uniforms.direction.sub(vector3);
uniforms.direction.transformDirection(viewMatrix);

uniforms.shadow=light.castShadow;

if(light.castShadow){

var shadow=light.shadow;

uniforms.shadowBias=shadow.bias;
uniforms.shadowRadius=shadow.radius;
uniforms.shadowMapSize=shadow.mapSize;

}

state.directionalShadowMap[directionalLength]=shadowMap;
state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;
state.directional[directionalLength]=uniforms;

directionalLength++;

}else if(light.isSpotLight){

var uniforms=cache.get(light);

uniforms.position.setFromMatrixPosition(light.matrixWorld);
uniforms.position.applyMatrix4(viewMatrix);

uniforms.color.copy(color).multiplyScalar(intensity);
uniforms.distance=distance;

uniforms.direction.setFromMatrixPosition(light.matrixWorld);
vector3.setFromMatrixPosition(light.target.matrixWorld);
uniforms.direction.sub(vector3);
uniforms.direction.transformDirection(viewMatrix);

uniforms.coneCos=Math.cos(light.angle);
uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));
uniforms.decay=light.decay;

uniforms.shadow=light.castShadow;

if(light.castShadow){

var shadow=light.shadow;

uniforms.shadowBias=shadow.bias;
uniforms.shadowRadius=shadow.radius;
uniforms.shadowMapSize=shadow.mapSize;

}

state.spotShadowMap[spotLength]=shadowMap;
state.spotShadowMatrix[spotLength]=light.shadow.matrix;
state.spot[spotLength]=uniforms;

spotLength++;

}else if(light.isRectAreaLight){

var uniforms=cache.get(light);

// (a) intensity is the total visible light emitted
//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

// (b) intensity is the brightness of the light
uniforms.color.copy(color).multiplyScalar(intensity);

uniforms.position.setFromMatrixPosition(light.matrixWorld);
uniforms.position.applyMatrix4(viewMatrix);

// extract local rotation of light to derive width/height half vectors
matrix42.identity();
matrix4.copy(light.matrixWorld);
matrix4.premultiply(viewMatrix);
matrix42.extractRotation(matrix4);

uniforms.halfWidth.set(light.width*0.5,0.0,0.0);
uniforms.halfHeight.set(0.0,light.height*0.5,0.0);

uniforms.halfWidth.applyMatrix4(matrix42);
uniforms.halfHeight.applyMatrix4(matrix42);

// TODO (abelnation): RectAreaLight distance?
// uniforms.distance = distance;

state.rectArea[rectAreaLength]=uniforms;

rectAreaLength++;

}else if(light.isPointLight){

var uniforms=cache.get(light);

uniforms.position.setFromMatrixPosition(light.matrixWorld);
uniforms.position.applyMatrix4(viewMatrix);

uniforms.color.copy(light.color).multiplyScalar(light.intensity);
uniforms.distance=light.distance;
uniforms.decay=light.decay;

uniforms.shadow=light.castShadow;

if(light.castShadow){

var shadow=light.shadow;

uniforms.shadowBias=shadow.bias;
uniforms.shadowRadius=shadow.radius;
uniforms.shadowMapSize=shadow.mapSize;
uniforms.shadowCameraNear=shadow.camera.near;
uniforms.shadowCameraFar=shadow.camera.far;

}

state.pointShadowMap[pointLength]=shadowMap;
state.pointShadowMatrix[pointLength]=light.shadow.matrix;
state.point[pointLength]=uniforms;

pointLength++;

}else if(light.isHemisphereLight){

var uniforms=cache.get(light);

uniforms.direction.setFromMatrixPosition(light.matrixWorld);
uniforms.direction.transformDirection(viewMatrix);
uniforms.direction.normalize();

uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

state.hemi[hemiLength]=uniforms;

hemiLength++;

}

}

state.ambient[0]=r;
state.ambient[1]=g;
state.ambient[2]=b;

state.directional.length=directionalLength;
state.spot.length=spotLength;
state.rectArea.length=rectAreaLength;
state.point.length=pointLength;
state.hemi.length=hemiLength;

state.hash.stateID=state.id;
state.hash.directionalLength=directionalLength;
state.hash.pointLength=pointLength;
state.hash.spotLength=spotLength;
state.hash.rectAreaLength=rectAreaLength;
state.hash.hemiLength=hemiLength;
state.hash.shadowsLength=shadows.length;

}

return{
setup:setup,
state:state};


}

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebGLRenderState(){

var lights=new WebGLLights();

var lightsArray=[];
var shadowsArray=[];

function init(){

lightsArray.length=0;
shadowsArray.length=0;

}

function pushLight(light){

lightsArray.push(light);

}

function pushShadow(shadowLight){

shadowsArray.push(shadowLight);

}

function setupLights(camera){

lights.setup(lightsArray,shadowsArray,camera);

}

var state={
lightsArray:lightsArray,
shadowsArray:shadowsArray,

lights:lights};


return{
init:init,
state:state,
setupLights:setupLights,

pushLight:pushLight,
pushShadow:pushShadow};


}

function WebGLRenderStates(){

var renderStates={};

function onSceneDispose(event){

var scene=event.target;

scene.removeEventListener('dispose',onSceneDispose);

delete renderStates[scene.id];

}

function get(scene,camera){

var renderState;

if(renderStates[scene.id]===undefined){

renderState=new WebGLRenderState();
renderStates[scene.id]={};
renderStates[scene.id][camera.id]=renderState;

scene.addEventListener('dispose',onSceneDispose);

}else{

if(renderStates[scene.id][camera.id]===undefined){

renderState=new WebGLRenderState();
renderStates[scene.id][camera.id]=renderState;

}else{

renderState=renderStates[scene.id][camera.id];

}

}

return renderState;

}

function dispose(){

renderStates={};

}

return{
get:get,
dispose:dispose};


}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial(parameters){

Material.call(this);

this.type='MeshDepthMaterial';

this.depthPacking=BasicDepthPacking;

this.skinning=false;
this.morphTargets=false;

this.map=null;

this.alphaMap=null;

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.wireframe=false;
this.wireframeLinewidth=1;

this.fog=false;
this.lights=false;

this.setValues(parameters);

}

MeshDepthMaterial.prototype=Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial=true;

MeshDepthMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.depthPacking=source.depthPacking;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;

this.map=source.map;

this.alphaMap=source.alphaMap;

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;

return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

function MeshDistanceMaterial(parameters){

Material.call(this);

this.type='MeshDistanceMaterial';

this.referencePosition=new Vector3();
this.nearDistance=1;
this.farDistance=1000;

this.skinning=false;
this.morphTargets=false;

this.map=null;

this.alphaMap=null;

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.fog=false;
this.lights=false;

this.setValues(parameters);

}

MeshDistanceMaterial.prototype=Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial;

MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;

MeshDistanceMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.referencePosition.copy(source.referencePosition);
this.nearDistance=source.nearDistance;
this.farDistance=source.farDistance;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;

this.map=source.map;

this.alphaMap=source.alphaMap;

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap(_renderer,_objects,maxTextureSize){

var _frustum=new Frustum(),
_projScreenMatrix=new Matrix4(),

_shadowMapSize=new Vector2(),
_maxShadowMapSize=new Vector2(maxTextureSize,maxTextureSize),

_lookTarget=new Vector3(),
_lightPositionWorld=new Vector3(),

_MorphingFlag=1,
_SkinningFlag=2,

_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,

_depthMaterials=new Array(_NumberOfMaterialVariants),
_distanceMaterials=new Array(_NumberOfMaterialVariants),

_materialCache={};

var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};

var cubeDirections=[
new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),
new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];


var cubeUps=[
new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),
new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];


var cube2DViewPorts=[
new Vector4(),new Vector4(),new Vector4(),
new Vector4(),new Vector4(),new Vector4()];


// init

for(var i=0;i!==_NumberOfMaterialVariants;++i){

var useMorphing=(i&_MorphingFlag)!==0;
var useSkinning=(i&_SkinningFlag)!==0;

var depthMaterial=new MeshDepthMaterial({

depthPacking:RGBADepthPacking,

morphTargets:useMorphing,
skinning:useSkinning});



_depthMaterials[i]=depthMaterial;

//

var distanceMaterial=new MeshDistanceMaterial({

morphTargets:useMorphing,
skinning:useSkinning});



_distanceMaterials[i]=distanceMaterial;

}

//

var scope=this;

this.enabled=false;

this.autoUpdate=true;
this.needsUpdate=false;

this.type=PCFShadowMap;

this.render=function(lights,scene,camera){

if(scope.enabled===false)return;
if(scope.autoUpdate===false&&scope.needsUpdate===false)return;

if(lights.length===0)return;

var currentRenderTarget=_renderer.getRenderTarget();
var activeCubeFace=_renderer.getActiveCubeFace();
var activeMipMapLevel=_renderer.getActiveMipMapLevel();

var _state=_renderer.state;

// Set GL state for depth map.
_state.setBlending(NoBlending);
_state.buffers.color.setClear(1,1,1,1);
_state.buffers.depth.setTest(true);
_state.setScissorTest(false);

// render depth map

var faceCount;

for(var i=0,il=lights.length;i<il;i++){

var light=lights[i];
var shadow=light.shadow;
var isPointLight=light&&light.isPointLight;

if(shadow===undefined){

console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');
continue;

}

var shadowCamera=shadow.camera;

_shadowMapSize.copy(shadow.mapSize);
_shadowMapSize.min(_maxShadowMapSize);

if(isPointLight){

var vpWidth=_shadowMapSize.x;
var vpHeight=_shadowMapSize.y;

// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction

// positive X
cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);
// negative X
cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);
// positive Z
cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);
// negative Z
cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);
// positive Y
cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);
// negative Y
cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);

_shadowMapSize.x*=4.0;
_shadowMapSize.y*=2.0;

}

if(shadow.map===null){

var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};

shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);
shadow.map.texture.name=light.name+".shadowMap";

shadowCamera.updateProjectionMatrix();

}

if(shadow.isSpotLightShadow){

shadow.update(light);

}

var shadowMap=shadow.map;
var shadowMatrix=shadow.matrix;

_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
shadowCamera.position.copy(_lightPositionWorld);

if(isPointLight){

faceCount=6;

// for point lights we set the shadow matrix to be a translation-only matrix
// equal to inverse of the light's position

shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);

}else{

faceCount=1;

_lookTarget.setFromMatrixPosition(light.target.matrixWorld);
shadowCamera.lookAt(_lookTarget);
shadowCamera.updateMatrixWorld();

// compute shadow matrix

shadowMatrix.set(
0.5,0.0,0.0,0.5,
0.0,0.5,0.0,0.5,
0.0,0.0,0.5,0.5,
0.0,0.0,0.0,1.0);


shadowMatrix.multiply(shadowCamera.projectionMatrix);
shadowMatrix.multiply(shadowCamera.matrixWorldInverse);

}

_renderer.setRenderTarget(shadowMap);
_renderer.clear();

// render shadow map for each cube face (if omni-directional) or
// run a single pass if not

for(var face=0;face<faceCount;face++){

if(isPointLight){

_lookTarget.copy(shadowCamera.position);
_lookTarget.add(cubeDirections[face]);
shadowCamera.up.copy(cubeUps[face]);
shadowCamera.lookAt(_lookTarget);
shadowCamera.updateMatrixWorld();

var vpDimensions=cube2DViewPorts[face];
_state.viewport(vpDimensions);

}

// update camera matrices and frustum

_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);
_frustum.setFromMatrix(_projScreenMatrix);

// set object matrices & frustum culling

renderObject(scene,camera,shadowCamera,isPointLight);

}

}

scope.needsUpdate=false;

_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipMapLevel);

};

function getDepthMaterial(object,material,isPointLight,lightPositionWorld,shadowCameraNear,shadowCameraFar){

var geometry=object.geometry;

var result=null;

var materialVariants=_depthMaterials;
var customMaterial=object.customDepthMaterial;

if(isPointLight){

materialVariants=_distanceMaterials;
customMaterial=object.customDistanceMaterial;

}

if(!customMaterial){

var useMorphing=false;

if(material.morphTargets){

if(geometry&&geometry.isBufferGeometry){

useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;

}else if(geometry&&geometry.isGeometry){

useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;

}

}

if(object.isSkinnedMesh&&material.skinning===false){

console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);

}

var useSkinning=object.isSkinnedMesh&&material.skinning;

var variantIndex=0;

if(useMorphing)variantIndex|=_MorphingFlag;
if(useSkinning)variantIndex|=_SkinningFlag;

result=materialVariants[variantIndex];

}else{

result=customMaterial;

}

if(_renderer.localClippingEnabled&&
material.clipShadows===true&&
material.clippingPlanes.length!==0){

// in this case we need a unique material instance reflecting the
// appropriate state

var keyA=result.uuid,keyB=material.uuid;

var materialsForVariant=_materialCache[keyA];

if(materialsForVariant===undefined){

materialsForVariant={};
_materialCache[keyA]=materialsForVariant;

}

var cachedMaterial=materialsForVariant[keyB];

if(cachedMaterial===undefined){

cachedMaterial=result.clone();
materialsForVariant[keyB]=cachedMaterial;

}

result=cachedMaterial;

}

result.visible=material.visible;
result.wireframe=material.wireframe;

result.side=material.shadowSide!=null?material.shadowSide:shadowSide[material.side];

result.clipShadows=material.clipShadows;
result.clippingPlanes=material.clippingPlanes;
result.clipIntersection=material.clipIntersection;

result.wireframeLinewidth=material.wireframeLinewidth;
result.linewidth=material.linewidth;

if(isPointLight&&result.isMeshDistanceMaterial){

result.referencePosition.copy(lightPositionWorld);
result.nearDistance=shadowCameraNear;
result.farDistance=shadowCameraFar;

}

return result;

}

function renderObject(object,camera,shadowCamera,isPointLight){

if(object.visible===false)return;

var visible=object.layers.test(camera.layers);

if(visible&&(object.isMesh||object.isLine||object.isPoints)){

if(object.castShadow&&(!object.frustumCulled||_frustum.intersectsObject(object))){

object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);

var geometry=_objects.update(object);
var material=object.material;

if(Array.isArray(material)){

var groups=geometry.groups;

for(var k=0,kl=groups.length;k<kl;k++){

var group=groups[k];
var groupMaterial=material[group.materialIndex];

if(groupMaterial&&groupMaterial.visible){

var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);
_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);

}

}

}else if(material.visible){

var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);
_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);

}

}

}

var children=object.children;

for(var i=0,l=children.length;i<l;i++){

renderObject(children[i],camera,shadowCamera,isPointLight);

}

}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState(gl,extensions,utils,capabilities){

function ColorBuffer(){

var locked=false;

var color=new Vector4();
var currentColorMask=null;
var currentColorClear=new Vector4(0,0,0,0);

return{

setMask:function setMask(colorMask){

if(currentColorMask!==colorMask&&!locked){

gl.colorMask(colorMask,colorMask,colorMask,colorMask);
currentColorMask=colorMask;

}

},

setLocked:function setLocked(lock){

locked=lock;

},

setClear:function setClear(r,g,b,a,premultipliedAlpha){

if(premultipliedAlpha===true){

r*=a;g*=a;b*=a;

}

color.set(r,g,b,a);

if(currentColorClear.equals(color)===false){

gl.clearColor(r,g,b,a);
currentColorClear.copy(color);

}

},

reset:function reset(){

locked=false;

currentColorMask=null;
currentColorClear.set(-1,0,0,0);// set to invalid state

}};



}

function DepthBuffer(){

var locked=false;

var currentDepthMask=null;
var currentDepthFunc=null;
var currentDepthClear=null;

return{

setTest:function setTest(depthTest){

if(depthTest){

enable(2929);

}else{

disable(2929);

}

},

setMask:function setMask(depthMask){

if(currentDepthMask!==depthMask&&!locked){

gl.depthMask(depthMask);
currentDepthMask=depthMask;

}

},

setFunc:function setFunc(depthFunc){

if(currentDepthFunc!==depthFunc){

if(depthFunc){

switch(depthFunc){

case NeverDepth:

gl.depthFunc(512);
break;

case AlwaysDepth:

gl.depthFunc(519);
break;

case LessDepth:

gl.depthFunc(513);
break;

case LessEqualDepth:

gl.depthFunc(515);
break;

case EqualDepth:

gl.depthFunc(514);
break;

case GreaterEqualDepth:

gl.depthFunc(518);
break;

case GreaterDepth:

gl.depthFunc(516);
break;

case NotEqualDepth:

gl.depthFunc(517);
break;

default:

gl.depthFunc(515);}



}else{

gl.depthFunc(515);

}

currentDepthFunc=depthFunc;

}

},

setLocked:function setLocked(lock){

locked=lock;

},

setClear:function setClear(depth){

if(currentDepthClear!==depth){

gl.clearDepth(depth);
currentDepthClear=depth;

}

},

reset:function reset(){

locked=false;

currentDepthMask=null;
currentDepthFunc=null;
currentDepthClear=null;

}};



}

function StencilBuffer(){

var locked=false;

var currentStencilMask=null;
var currentStencilFunc=null;
var currentStencilRef=null;
var currentStencilFuncMask=null;
var currentStencilFail=null;
var currentStencilZFail=null;
var currentStencilZPass=null;
var currentStencilClear=null;

return{

setTest:function setTest(stencilTest){

if(stencilTest){

enable(2960);

}else{

disable(2960);

}

},

setMask:function setMask(stencilMask){

if(currentStencilMask!==stencilMask&&!locked){

gl.stencilMask(stencilMask);
currentStencilMask=stencilMask;

}

},

setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){

if(currentStencilFunc!==stencilFunc||
currentStencilRef!==stencilRef||
currentStencilFuncMask!==stencilMask){

gl.stencilFunc(stencilFunc,stencilRef,stencilMask);

currentStencilFunc=stencilFunc;
currentStencilRef=stencilRef;
currentStencilFuncMask=stencilMask;

}

},

setOp:function setOp(stencilFail,stencilZFail,stencilZPass){

if(currentStencilFail!==stencilFail||
currentStencilZFail!==stencilZFail||
currentStencilZPass!==stencilZPass){

gl.stencilOp(stencilFail,stencilZFail,stencilZPass);

currentStencilFail=stencilFail;
currentStencilZFail=stencilZFail;
currentStencilZPass=stencilZPass;

}

},

setLocked:function setLocked(lock){

locked=lock;

},

setClear:function setClear(stencil){

if(currentStencilClear!==stencil){

gl.clearStencil(stencil);
currentStencilClear=stencil;

}

},

reset:function reset(){

locked=false;

currentStencilMask=null;
currentStencilFunc=null;
currentStencilRef=null;
currentStencilFuncMask=null;
currentStencilFail=null;
currentStencilZFail=null;
currentStencilZPass=null;
currentStencilClear=null;

}};



}

//

var colorBuffer=new ColorBuffer();
var depthBuffer=new DepthBuffer();
var stencilBuffer=new StencilBuffer();

var maxVertexAttributes=gl.getParameter(34921);
var newAttributes=new Uint8Array(maxVertexAttributes);
var enabledAttributes=new Uint8Array(maxVertexAttributes);
var attributeDivisors=new Uint8Array(maxVertexAttributes);

var enabledCapabilities={};

var compressedTextureFormats=null;

var currentProgram=null;

var currentBlendingEnabled=null;
var currentBlending=null;
var currentBlendEquation=null;
var currentBlendSrc=null;
var currentBlendDst=null;
var currentBlendEquationAlpha=null;
var currentBlendSrcAlpha=null;
var currentBlendDstAlpha=null;
var currentPremultipledAlpha=false;

var currentFlipSided=null;
var currentCullFace=null;

var currentLineWidth=null;

var currentPolygonOffsetFactor=null;
var currentPolygonOffsetUnits=null;

var maxTextures=gl.getParameter(35661);

var lineWidthAvailable=false;
var version=0;
var glVersion=gl.getParameter(7938);

if(glVersion.indexOf('WebGL')!==-1){

version=parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
lineWidthAvailable=version>=1.0;

}else if(glVersion.indexOf('OpenGL ES')!==-1){

version=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
lineWidthAvailable=version>=2.0;

}

var currentTextureSlot=null;
var currentBoundTextures={};

var currentScissor=new Vector4();
var currentViewport=new Vector4();

function createTexture(type,target,count){

var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
var texture=gl.createTexture();

gl.bindTexture(type,texture);
gl.texParameteri(type,10241,9728);
gl.texParameteri(type,10240,9728);

for(var i=0;i<count;i++){

gl.texImage2D(target+i,0,6408,1,1,0,6408,5121,data);

}

return texture;

}

var emptyTextures={};
emptyTextures[3553]=createTexture(3553,3553,1);
emptyTextures[34067]=createTexture(34067,34069,6);

// init

colorBuffer.setClear(0,0,0,1);
depthBuffer.setClear(1);
stencilBuffer.setClear(0);

enable(2929);
depthBuffer.setFunc(LessEqualDepth);

setFlipSided(false);
setCullFace(CullFaceBack);
enable(2884);

setBlending(NoBlending);

//

function initAttributes(){

for(var i=0,l=newAttributes.length;i<l;i++){

newAttributes[i]=0;

}

}

function enableAttribute(attribute){

enableAttributeAndDivisor(attribute,0);

}

function enableAttributeAndDivisor(attribute,meshPerAttribute){

newAttributes[attribute]=1;

if(enabledAttributes[attribute]===0){

gl.enableVertexAttribArray(attribute);
enabledAttributes[attribute]=1;

}

if(attributeDivisors[attribute]!==meshPerAttribute){

var extension=capabilities.isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');

extension[capabilities.isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);
attributeDivisors[attribute]=meshPerAttribute;

}

}

function disableUnusedAttributes(){

for(var i=0,l=enabledAttributes.length;i!==l;++i){

if(enabledAttributes[i]!==newAttributes[i]){

gl.disableVertexAttribArray(i);
enabledAttributes[i]=0;

}

}

}

function enable(id){

if(enabledCapabilities[id]!==true){

gl.enable(id);
enabledCapabilities[id]=true;

}

}

function disable(id){

if(enabledCapabilities[id]!==false){

gl.disable(id);
enabledCapabilities[id]=false;

}

}

function getCompressedTextureFormats(){

if(compressedTextureFormats===null){

compressedTextureFormats=[];

if(extensions.get('WEBGL_compressed_texture_pvrtc')||
extensions.get('WEBGL_compressed_texture_s3tc')||
extensions.get('WEBGL_compressed_texture_etc1')||
extensions.get('WEBGL_compressed_texture_astc')){

var formats=gl.getParameter(34467);

for(var i=0;i<formats.length;i++){

compressedTextureFormats.push(formats[i]);

}

}

}

return compressedTextureFormats;

}

function useProgram(program){

if(currentProgram!==program){

gl.useProgram(program);

currentProgram=program;

return true;

}

return false;

}

function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){

if(blending===NoBlending){

if(currentBlendingEnabled){

disable(3042);
currentBlendingEnabled=false;

}

return;

}

if(!currentBlendingEnabled){

enable(3042);
currentBlendingEnabled=true;

}

if(blending!==CustomBlending){

if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){

if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){

gl.blendEquation(32774);

currentBlendEquation=AddEquation;
currentBlendEquationAlpha=AddEquation;

}

if(premultipliedAlpha){

switch(blending){

case NormalBlending:
gl.blendFuncSeparate(1,771,1,771);
break;

case AdditiveBlending:
gl.blendFunc(1,1);
break;

case SubtractiveBlending:
gl.blendFuncSeparate(0,0,769,771);
break;

case MultiplyBlending:
gl.blendFuncSeparate(0,768,0,770);
break;

default:
console.error('THREE.WebGLState: Invalid blending: ',blending);
break;}



}else{

switch(blending){

case NormalBlending:
gl.blendFuncSeparate(770,771,1,771);
break;

case AdditiveBlending:
gl.blendFunc(770,1);
break;

case SubtractiveBlending:
gl.blendFunc(0,769);
break;

case MultiplyBlending:
gl.blendFunc(0,768);
break;

default:
console.error('THREE.WebGLState: Invalid blending: ',blending);
break;}



}

currentBlendSrc=null;
currentBlendDst=null;
currentBlendSrcAlpha=null;
currentBlendDstAlpha=null;

currentBlending=blending;
currentPremultipledAlpha=premultipliedAlpha;

}

return;

}

// custom blending

blendEquationAlpha=blendEquationAlpha||blendEquation;
blendSrcAlpha=blendSrcAlpha||blendSrc;
blendDstAlpha=blendDstAlpha||blendDst;

if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){

gl.blendEquationSeparate(utils.convert(blendEquation),utils.convert(blendEquationAlpha));

currentBlendEquation=blendEquation;
currentBlendEquationAlpha=blendEquationAlpha;

}

if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){

gl.blendFuncSeparate(utils.convert(blendSrc),utils.convert(blendDst),utils.convert(blendSrcAlpha),utils.convert(blendDstAlpha));

currentBlendSrc=blendSrc;
currentBlendDst=blendDst;
currentBlendSrcAlpha=blendSrcAlpha;
currentBlendDstAlpha=blendDstAlpha;

}

currentBlending=blending;
currentPremultipledAlpha=null;

}

function setMaterial(material,frontFaceCW){

material.side===DoubleSide?
disable(2884):
enable(2884);

var flipSided=material.side===BackSide;
if(frontFaceCW)flipSided=!flipSided;

setFlipSided(flipSided);

material.blending===NormalBlending&&material.transparent===false?
setBlending(NoBlending):
setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);

depthBuffer.setFunc(material.depthFunc);
depthBuffer.setTest(material.depthTest);
depthBuffer.setMask(material.depthWrite);
colorBuffer.setMask(material.colorWrite);

setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);

}

//

function setFlipSided(flipSided){

if(currentFlipSided!==flipSided){

if(flipSided){

gl.frontFace(2304);

}else{

gl.frontFace(2305);

}

currentFlipSided=flipSided;

}

}

function setCullFace(cullFace){

if(cullFace!==CullFaceNone){

enable(2884);

if(cullFace!==currentCullFace){

if(cullFace===CullFaceBack){

gl.cullFace(1029);

}else if(cullFace===CullFaceFront){

gl.cullFace(1028);

}else{

gl.cullFace(1032);

}

}

}else{

disable(2884);

}

currentCullFace=cullFace;

}

function setLineWidth(width){

if(width!==currentLineWidth){

if(lineWidthAvailable)gl.lineWidth(width);

currentLineWidth=width;

}

}

function setPolygonOffset(polygonOffset,factor,units){

if(polygonOffset){

enable(32823);

if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){

gl.polygonOffset(factor,units);

currentPolygonOffsetFactor=factor;
currentPolygonOffsetUnits=units;

}

}else{

disable(32823);

}

}

function setScissorTest(scissorTest){

if(scissorTest){

enable(3089);

}else{

disable(3089);

}

}

// texture

function activeTexture(webglSlot){

if(webglSlot===undefined)webglSlot=33984+maxTextures-1;

if(currentTextureSlot!==webglSlot){

gl.activeTexture(webglSlot);
currentTextureSlot=webglSlot;

}

}

function bindTexture(webglType,webglTexture){

if(currentTextureSlot===null){

activeTexture();

}

var boundTexture=currentBoundTextures[currentTextureSlot];

if(boundTexture===undefined){

boundTexture={type:undefined,texture:undefined};
currentBoundTextures[currentTextureSlot]=boundTexture;

}

if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){

gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);

boundTexture.type=webglType;
boundTexture.texture=webglTexture;

}

}

function compressedTexImage2D(){

try{

gl.compressedTexImage2D.apply(gl,arguments);

}catch(error){

console.error('THREE.WebGLState:',error);

}

}

function texImage2D(){

try{

gl.texImage2D.apply(gl,arguments);

}catch(error){

console.error('THREE.WebGLState:',error);

}

}

function texImage3D(){

try{

gl.texImage3D.apply(gl,arguments);

}catch(error){

console.error('THREE.WebGLState:',error);

}

}

//

function scissor(scissor){

if(currentScissor.equals(scissor)===false){

gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);
currentScissor.copy(scissor);

}

}

function viewport(viewport){

if(currentViewport.equals(viewport)===false){

gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);
currentViewport.copy(viewport);

}

}

//

function reset(){

for(var i=0;i<enabledAttributes.length;i++){

if(enabledAttributes[i]===1){

gl.disableVertexAttribArray(i);
enabledAttributes[i]=0;

}

}

enabledCapabilities={};

compressedTextureFormats=null;

currentTextureSlot=null;
currentBoundTextures={};

currentProgram=null;

currentBlending=null;

currentFlipSided=null;
currentCullFace=null;

colorBuffer.reset();
depthBuffer.reset();
stencilBuffer.reset();

}

return{

buffers:{
color:colorBuffer,
depth:depthBuffer,
stencil:stencilBuffer},


initAttributes:initAttributes,
enableAttribute:enableAttribute,
enableAttributeAndDivisor:enableAttributeAndDivisor,
disableUnusedAttributes:disableUnusedAttributes,
enable:enable,
disable:disable,
getCompressedTextureFormats:getCompressedTextureFormats,

useProgram:useProgram,

setBlending:setBlending,
setMaterial:setMaterial,

setFlipSided:setFlipSided,
setCullFace:setCullFace,

setLineWidth:setLineWidth,
setPolygonOffset:setPolygonOffset,

setScissorTest:setScissorTest,

activeTexture:activeTexture,
bindTexture:bindTexture,
compressedTexImage2D:compressedTexImage2D,
texImage2D:texImage2D,
texImage3D:texImage3D,

scissor:scissor,
viewport:viewport,

reset:reset};



}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){

var _videoTextures={};
var _canvas;

//

var useOffscreenCanvas=typeof OffscreenCanvas!=='undefined';

function createCanvas(width,height){

// Use OffscreenCanvas when available. Specially needed in web workers

return useOffscreenCanvas?
new OffscreenCanvas(width,height):
document.createElementNS('http://www.w3.org/1999/xhtml','canvas');

}

function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){

var scale=1;

// handle case if texture exceeds max size

if(image.width>maxSize||image.height>maxSize){

scale=maxSize/Math.max(image.width,image.height);

}

// only perform resize if necessary

if(scale<1||needsPowerOfTwo===true){

// only perform resize for certain image types

if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||
typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||
typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){

var floor=needsPowerOfTwo?_Math.floorPowerOfTwo:Math.floor;

var width=floor(scale*image.width);
var height=floor(scale*image.height);

if(_canvas===undefined)_canvas=createCanvas(width,height);

// cube textures can't reuse the same canvas

var canvas=needsNewCanvas?createCanvas(width,height):_canvas;

canvas.width=width;
canvas.height=height;

var context=canvas.getContext('2d');
context.drawImage(image,0,0,width,height);

console.warn('THREE.WebGLRenderer: Texture has been resized from ('+image.width+'x'+image.height+') to ('+width+'x'+height+').');

return canvas;

}else{

if('data'in image){

console.warn('THREE.WebGLRenderer: Image in DataTexture is too big ('+image.width+'x'+image.height+').');

}

return image;

}

}

return image;

}

function isPowerOfTwo(image){

return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);

}

function textureNeedsPowerOfTwo(texture){

if(capabilities.isWebGL2)return false;

return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||
texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;

}

function textureNeedsGenerateMipmaps(texture,supportsMips){

return texture.generateMipmaps&&supportsMips&&
texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;

}

function generateMipmap(target,texture,width,height){

_gl.generateMipmap(target);

var textureProperties=properties.get(texture);

// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
textureProperties.__maxMipLevel=Math.log(Math.max(width,height))*Math.LOG2E;

}

function getInternalFormat(glFormat,glType){

if(!capabilities.isWebGL2)return glFormat;

var internalFormat=glFormat;

if(glFormat===6403){

if(glType===5126)internalFormat=33326;
if(glType===5131)internalFormat=33325;
if(glType===5121)internalFormat=33321;

}

if(glFormat===6407){

if(glType===5126)internalFormat=34837;
if(glType===5131)internalFormat=34843;
if(glType===5121)internalFormat=32849;

}

if(glFormat===6408){

if(glType===5126)internalFormat=34836;
if(glType===5131)internalFormat=34842;
if(glType===5121)internalFormat=32856;

}

if(internalFormat===33325||internalFormat===33326||
internalFormat===34842||internalFormat===34836){

extensions.get('EXT_color_buffer_float');

}else if(internalFormat===34843||internalFormat===34837){

console.warn('THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.');

}

return internalFormat;

}

// Fallback filters for non-power-of-2 textures

function filterFallback(f){

if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){

return 9728;

}

return 9729;

}

//

function onTextureDispose(event){

var texture=event.target;

texture.removeEventListener('dispose',onTextureDispose);

deallocateTexture(texture);

if(texture.isVideoTexture){

delete _videoTextures[texture.id];

}

info.memory.textures--;

}

function onRenderTargetDispose(event){

var renderTarget=event.target;

renderTarget.removeEventListener('dispose',onRenderTargetDispose);

deallocateRenderTarget(renderTarget);

info.memory.textures--;

}

//

function deallocateTexture(texture){

var textureProperties=properties.get(texture);

if(textureProperties.__webglInit===undefined)return;

_gl.deleteTexture(textureProperties.__webglTexture);

properties.remove(texture);

}

function deallocateRenderTarget(renderTarget){

var renderTargetProperties=properties.get(renderTarget);
var textureProperties=properties.get(renderTarget.texture);

if(!renderTarget)return;

if(textureProperties.__webglTexture!==undefined){

_gl.deleteTexture(textureProperties.__webglTexture);

}

if(renderTarget.depthTexture){

renderTarget.depthTexture.dispose();

}

if(renderTarget.isWebGLRenderTargetCube){

for(var i=0;i<6;i++){

_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);

}

}else{

_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);

}

properties.remove(renderTarget.texture);
properties.remove(renderTarget);

}

//

var textureUnits=0;

function resetTextureUnits(){

textureUnits=0;

}

function allocateTextureUnit(){

var textureUnit=textureUnits;

if(textureUnit>=capabilities.maxTextures){

console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);

}

textureUnits+=1;

return textureUnit;

}

//

function setTexture2D(texture,slot){

var textureProperties=properties.get(texture);

if(texture.isVideoTexture)updateVideoTexture(texture);

if(texture.version>0&&textureProperties.__version!==texture.version){

var image=texture.image;

if(image===undefined){

console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');

}else if(image.complete===false){

console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');

}else{

uploadTexture(textureProperties,texture,slot);
return;

}

}

state.activeTexture(33984+slot);
state.bindTexture(3553,textureProperties.__webglTexture);

}

function setTexture2DArray(texture,slot){

var textureProperties=properties.get(texture);

if(texture.version>0&&textureProperties.__version!==texture.version){

uploadTexture(textureProperties,texture,slot);
return;

}

state.activeTexture(33984+slot);
state.bindTexture(35866,textureProperties.__webglTexture);

}

function setTexture3D(texture,slot){

var textureProperties=properties.get(texture);

if(texture.version>0&&textureProperties.__version!==texture.version){

uploadTexture(textureProperties,texture,slot);
return;

}

state.activeTexture(33984+slot);
state.bindTexture(32879,textureProperties.__webglTexture);

}

function setTextureCube(texture,slot){

var textureProperties=properties.get(texture);

if(texture.image.length===6){

if(texture.version>0&&textureProperties.__version!==texture.version){

initTexture(textureProperties,texture);

state.activeTexture(33984+slot);
state.bindTexture(34067,textureProperties.__webglTexture);

_gl.pixelStorei(37440,texture.flipY);

var isCompressed=texture&&texture.isCompressedTexture;
var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;

var cubeImage=[];

for(var i=0;i<6;i++){

if(!isCompressed&&!isDataTexture){

cubeImage[i]=resizeImage(texture.image[i],false,true,capabilities.maxCubemapSize);

}else{

cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];

}

}

var image=cubeImage[0],
supportsMips=isPowerOfTwo(image)||capabilities.isWebGL2,
glFormat=utils.convert(texture.format),
glType=utils.convert(texture.type),
glInternalFormat=getInternalFormat(glFormat,glType);

setTextureParameters(34067,texture,supportsMips);

for(var i=0;i<6;i++){

if(!isCompressed){

if(isDataTexture){

state.texImage2D(34069+i,0,glInternalFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);

}else{

state.texImage2D(34069+i,0,glInternalFormat,glFormat,glType,cubeImage[i]);

}

}else{

var mipmap,mipmaps=cubeImage[i].mipmaps;

for(var j=0,jl=mipmaps.length;j<jl;j++){

mipmap=mipmaps[j];

if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){

if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){

state.compressedTexImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);

}else{

console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');

}

}else{

state.texImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);

}

}

}

}

if(!isCompressed){

textureProperties.__maxMipLevel=0;

}else{

textureProperties.__maxMipLevel=mipmaps.length-1;

}

if(textureNeedsGenerateMipmaps(texture,supportsMips)){

// We assume images for cube map have the same size.
generateMipmap(34067,texture,image.width,image.height);

}

textureProperties.__version=texture.version;

if(texture.onUpdate)texture.onUpdate(texture);

}else{

state.activeTexture(33984+slot);
state.bindTexture(34067,textureProperties.__webglTexture);

}

}

}

function setTextureCubeDynamic(texture,slot){

state.activeTexture(33984+slot);
state.bindTexture(34067,properties.get(texture).__webglTexture);

}

function setTextureParameters(textureType,texture,supportsMips){

var extension;

if(supportsMips){

_gl.texParameteri(textureType,10242,utils.convert(texture.wrapS));
_gl.texParameteri(textureType,10243,utils.convert(texture.wrapT));

if(textureType===32879||textureType===35866){

_gl.texParameteri(textureType,32882,utils.convert(texture.wrapR));

}

_gl.texParameteri(textureType,10240,utils.convert(texture.magFilter));
_gl.texParameteri(textureType,10241,utils.convert(texture.minFilter));

}else{

_gl.texParameteri(textureType,10242,33071);
_gl.texParameteri(textureType,10243,33071);

if(textureType===32879||textureType===35866){

_gl.texParameteri(textureType,32882,33071);

}

if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){

console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');

}

_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));
_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));

if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){

console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');

}

}

extension=extensions.get('EXT_texture_filter_anisotropic');

if(extension){

if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;
if(texture.type===HalfFloatType&&(capabilities.isWebGL2||extensions.get('OES_texture_half_float_linear'))===null)return;

if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){

_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));
properties.get(texture).__currentAnisotropy=texture.anisotropy;

}

}

}

function initTexture(textureProperties,texture){

if(textureProperties.__webglInit===undefined){

textureProperties.__webglInit=true;

texture.addEventListener('dispose',onTextureDispose);

textureProperties.__webglTexture=_gl.createTexture();

info.memory.textures++;

}

}

function uploadTexture(textureProperties,texture,slot){

var textureType=3553;

if(texture.isDataTexture2DArray)textureType=35866;
if(texture.isDataTexture3D)textureType=32879;

initTexture(textureProperties,texture);

state.activeTexture(33984+slot);
state.bindTexture(textureType,textureProperties.__webglTexture);

_gl.pixelStorei(37440,texture.flipY);
_gl.pixelStorei(37441,texture.premultiplyAlpha);
_gl.pixelStorei(3317,texture.unpackAlignment);

var needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(texture.image)===false;
var image=resizeImage(texture.image,needsPowerOfTwo,false,capabilities.maxTextureSize);

var supportsMips=isPowerOfTwo(image)||capabilities.isWebGL2,
glFormat=utils.convert(texture.format),
glType=utils.convert(texture.type),
glInternalFormat=getInternalFormat(glFormat,glType);

setTextureParameters(textureType,texture,supportsMips);

var mipmap,mipmaps=texture.mipmaps;

if(texture.isDepthTexture){

// populate depth texture with dummy data

glInternalFormat=6402;

if(texture.type===FloatType){

if(!capabilities.isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');
glInternalFormat=36012;

}else if(capabilities.isWebGL2){

// WebGL 2.0 requires signed internalformat for glTexImage2D
glInternalFormat=33189;

}

if(texture.format===DepthFormat&&glInternalFormat===6402){

// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){

console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

texture.type=UnsignedShortType;
glType=utils.convert(texture.type);

}

}

// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.format===DepthStencilFormat){

glInternalFormat=34041;

// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){

console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

texture.type=UnsignedInt248Type;
glType=utils.convert(texture.type);

}

}

state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);

}else if(texture.isDataTexture){

// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels

if(mipmaps.length>0&&supportsMips){

for(var i=0,il=mipmaps.length;i<il;i++){

mipmap=mipmaps[i];
state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);

}

texture.generateMipmaps=false;
textureProperties.__maxMipLevel=mipmaps.length-1;

}else{

state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);
textureProperties.__maxMipLevel=0;

}

}else if(texture.isCompressedTexture){

for(var i=0,il=mipmaps.length;i<il;i++){

mipmap=mipmaps[i];

if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){

if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){

state.compressedTexImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);

}else{

console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');

}

}else{

state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);

}

}

textureProperties.__maxMipLevel=mipmaps.length-1;

}else if(texture.isDataTexture2DArray){

state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);
textureProperties.__maxMipLevel=0;

}else if(texture.isDataTexture3D){

state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);
textureProperties.__maxMipLevel=0;

}else{

// regular Texture (image, video, canvas)

// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels

if(mipmaps.length>0&&supportsMips){

for(var i=0,il=mipmaps.length;i<il;i++){

mipmap=mipmaps[i];
state.texImage2D(3553,i,glInternalFormat,glFormat,glType,mipmap);

}

texture.generateMipmaps=false;
textureProperties.__maxMipLevel=mipmaps.length-1;

}else{

state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);
textureProperties.__maxMipLevel=0;

}

}

if(textureNeedsGenerateMipmaps(texture,supportsMips)){

generateMipmap(3553,texture,image.width,image.height);

}

textureProperties.__version=texture.version;

if(texture.onUpdate)texture.onUpdate(texture);

}

// Render targets

// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){

var glFormat=utils.convert(renderTarget.texture.format);
var glType=utils.convert(renderTarget.texture.type);
var glInternalFormat=getInternalFormat(glFormat,glType);
state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);
_gl.bindFramebuffer(36160,framebuffer);
_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);
_gl.bindFramebuffer(36160,null);

}

// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){

_gl.bindRenderbuffer(36161,renderbuffer);

if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){

if(isMultisample){

var samples=getRenderTargetSamples(renderTarget);

_gl.renderbufferStorageMultisample(36161,samples,33189,renderTarget.width,renderTarget.height);

}else{

_gl.renderbufferStorage(36161,33189,renderTarget.width,renderTarget.height);

}

_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);

}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){

if(isMultisample){

var samples=getRenderTargetSamples(renderTarget);

_gl.renderbufferStorageMultisample(36161,samples,34041,renderTarget.width,renderTarget.height);

}else{

_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);

}


_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);

}else{

var glFormat=utils.convert(renderTarget.texture.format);
var glType=utils.convert(renderTarget.texture.type);
var glInternalFormat=getInternalFormat(glFormat,glType);

if(isMultisample){

var samples=getRenderTargetSamples(renderTarget);

_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);

}else{

_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);

}

}

_gl.bindRenderbuffer(36161,null);

}

// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){

var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;
if(isCube)throw new Error('Depth Texture with cube render targets is not supported');

_gl.bindFramebuffer(36160,framebuffer);

if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){

throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

}

// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||
renderTarget.depthTexture.image.width!==renderTarget.width||
renderTarget.depthTexture.image.height!==renderTarget.height){

renderTarget.depthTexture.image.width=renderTarget.width;
renderTarget.depthTexture.image.height=renderTarget.height;
renderTarget.depthTexture.needsUpdate=true;

}

setTexture2D(renderTarget.depthTexture,0);

var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;

if(renderTarget.depthTexture.format===DepthFormat){

_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);

}else if(renderTarget.depthTexture.format===DepthStencilFormat){

_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);

}else{

throw new Error('Unknown depthTexture format');

}

}

// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){

var renderTargetProperties=properties.get(renderTarget);

var isCube=renderTarget.isWebGLRenderTargetCube===true;

if(renderTarget.depthTexture){

if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');

setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);

}else{

if(isCube){

renderTargetProperties.__webglDepthbuffer=[];

for(var i=0;i<6;i++){

_gl.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[i]);
renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();
setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);

}

}else{

_gl.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);
renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();
setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);

}

}

_gl.bindFramebuffer(36160,null);

}

// Set up GL resources for the render target
function setupRenderTarget(renderTarget){

var renderTargetProperties=properties.get(renderTarget);
var textureProperties=properties.get(renderTarget.texture);

renderTarget.addEventListener('dispose',onRenderTargetDispose);

textureProperties.__webglTexture=_gl.createTexture();

info.memory.textures++;

var isCube=renderTarget.isWebGLRenderTargetCube===true;
var isMultisample=renderTarget.isWebGLMultisampleRenderTarget===true;
var supportsMips=isPowerOfTwo(renderTarget)||capabilities.isWebGL2;

// Setup framebuffer

if(isCube){

renderTargetProperties.__webglFramebuffer=[];

for(var i=0;i<6;i++){

renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();

}

}else{

renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();

if(isMultisample){

if(capabilities.isWebGL2){

renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();
renderTargetProperties.__webglColorRenderbuffer=_gl.createRenderbuffer();

_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer);
var glFormat=utils.convert(renderTarget.texture.format);
var glType=utils.convert(renderTarget.texture.type);
var glInternalFormat=getInternalFormat(glFormat,glType);
var samples=getRenderTargetSamples(renderTarget);
_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);

_gl.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);
_gl.framebufferRenderbuffer(36160,36064,36161,renderTargetProperties.__webglColorRenderbuffer);
_gl.bindRenderbuffer(36161,null);

if(renderTarget.depthBuffer){

renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();
setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);

}

_gl.bindFramebuffer(36160,null);


}else{

console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');

}

}

}

// Setup color buffer

if(isCube){

state.bindTexture(34067,textureProperties.__webglTexture);
setTextureParameters(34067,renderTarget.texture,supportsMips);

for(var i=0;i<6;i++){

setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,36064,34069+i);

}

if(textureNeedsGenerateMipmaps(renderTarget.texture,supportsMips)){

generateMipmap(34067,renderTarget.texture,renderTarget.width,renderTarget.height);

}

state.bindTexture(34067,null);

}else{

state.bindTexture(3553,textureProperties.__webglTexture);
setTextureParameters(3553,renderTarget.texture,supportsMips);
setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,36064,3553);

if(textureNeedsGenerateMipmaps(renderTarget.texture,supportsMips)){

generateMipmap(3553,renderTarget.texture,renderTarget.width,renderTarget.height);

}

state.bindTexture(3553,null);

}

// Setup depth and stencil buffers

if(renderTarget.depthBuffer){

setupDepthRenderbuffer(renderTarget);

}

}

function updateRenderTargetMipmap(renderTarget){

var texture=renderTarget.texture;
var supportsMips=isPowerOfTwo(renderTarget)||capabilities.isWebGL2;

if(textureNeedsGenerateMipmaps(texture,supportsMips)){

var target=renderTarget.isWebGLRenderTargetCube?34067:3553;
var webglTexture=properties.get(texture).__webglTexture;

state.bindTexture(target,webglTexture);
generateMipmap(target,texture,renderTarget.width,renderTarget.height);
state.bindTexture(target,null);

}

}

function updateMultisampleRenderTarget(renderTarget){

if(renderTarget.isWebGLMultisampleRenderTarget){

if(capabilities.isWebGL2){

var renderTargetProperties=properties.get(renderTarget);

_gl.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);
_gl.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);

var width=renderTarget.width;
var height=renderTarget.height;
var mask=16384;

if(renderTarget.depthBuffer)mask|=256;
if(renderTarget.stencilBuffer)mask|=1024;

_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);

}else{

console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');

}

}

}

function getRenderTargetSamples(renderTarget){

return capabilities.isWebGL2&&renderTarget.isWebGLMultisampleRenderTarget?
Math.min(capabilities.maxSamples,renderTarget.samples):0;

}

function updateVideoTexture(texture){

var id=texture.id;
var frame=info.render.frame;

// Check the last frame we updated the VideoTexture

if(_videoTextures[id]!==frame){

_videoTextures[id]=frame;
texture.update();

}

}

// backwards compatibility

var warnedTexture2D=false;
var warnedTextureCube=false;

function safeSetTexture2D(texture,slot){

if(texture&&texture.isWebGLRenderTarget){

if(warnedTexture2D===false){

console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
warnedTexture2D=true;

}

texture=texture.texture;

}

setTexture2D(texture,slot);

}

function safeSetTextureCube(texture,slot){

if(texture&&texture.isWebGLRenderTargetCube){

if(warnedTextureCube===false){

console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
warnedTextureCube=true;

}

texture=texture.texture;

}

// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
// TODO: unify these code paths
if(texture&&texture.isCubeTexture||
Array.isArray(texture.image)&&texture.image.length===6){

// CompressedTexture can have Array in image :/

// this function alone should take care of cube textures
setTextureCube(texture,slot);

}else{

// assumed: texture property of THREE.WebGLRenderTargetCube
setTextureCubeDynamic(texture,slot);

}

}

//

this.allocateTextureUnit=allocateTextureUnit;
this.resetTextureUnits=resetTextureUnits;

this.setTexture2D=setTexture2D;
this.setTexture2DArray=setTexture2DArray;
this.setTexture3D=setTexture3D;
this.setTextureCube=setTextureCube;
this.setTextureCubeDynamic=setTextureCubeDynamic;
this.setupRenderTarget=setupRenderTarget;
this.updateRenderTargetMipmap=updateRenderTargetMipmap;
this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;

this.safeSetTexture2D=safeSetTexture2D;
this.safeSetTextureCube=safeSetTextureCube;

}

/**
 * @author thespite / http://www.twitter.com/thespite
 */

function WebGLUtils(gl,extensions,capabilities){

function convert(p){

var extension;

if(p===RepeatWrapping)return 10497;
if(p===ClampToEdgeWrapping)return 33071;
if(p===MirroredRepeatWrapping)return 33648;

if(p===NearestFilter)return 9728;
if(p===NearestMipMapNearestFilter)return 9984;
if(p===NearestMipMapLinearFilter)return 9986;

if(p===LinearFilter)return 9729;
if(p===LinearMipMapNearestFilter)return 9985;
if(p===LinearMipMapLinearFilter)return 9987;

if(p===UnsignedByteType)return 5121;
if(p===UnsignedShort4444Type)return 32819;
if(p===UnsignedShort5551Type)return 32820;
if(p===UnsignedShort565Type)return 33635;

if(p===ByteType)return 5120;
if(p===ShortType)return 5122;
if(p===UnsignedShortType)return 5123;
if(p===IntType)return 5124;
if(p===UnsignedIntType)return 5125;
if(p===FloatType)return 5126;

if(p===HalfFloatType){

if(capabilities.isWebGL2)return 5131;

extension=extensions.get('OES_texture_half_float');

if(extension!==null)return extension.HALF_FLOAT_OES;

}

if(p===AlphaFormat)return 6406;
if(p===RGBFormat)return 6407;
if(p===RGBAFormat)return 6408;
if(p===LuminanceFormat)return 6409;
if(p===LuminanceAlphaFormat)return 6410;
if(p===DepthFormat)return 6402;
if(p===DepthStencilFormat)return 34041;
if(p===RedFormat)return 6403;

if(p===AddEquation)return 32774;
if(p===SubtractEquation)return 32778;
if(p===ReverseSubtractEquation)return 32779;

if(p===ZeroFactor)return 0;
if(p===OneFactor)return 1;
if(p===SrcColorFactor)return 768;
if(p===OneMinusSrcColorFactor)return 769;
if(p===SrcAlphaFactor)return 770;
if(p===OneMinusSrcAlphaFactor)return 771;
if(p===DstAlphaFactor)return 772;
if(p===OneMinusDstAlphaFactor)return 773;

if(p===DstColorFactor)return 774;
if(p===OneMinusDstColorFactor)return 775;
if(p===SrcAlphaSaturateFactor)return 776;

if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||
p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){

extension=extensions.get('WEBGL_compressed_texture_s3tc');

if(extension!==null){

if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

}

}

if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||
p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){

extension=extensions.get('WEBGL_compressed_texture_pvrtc');

if(extension!==null){

if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

}

}

if(p===RGB_ETC1_Format){

extension=extensions.get('WEBGL_compressed_texture_etc1');

if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;

}

if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||
p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||
p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||
p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||
p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format){

extension=extensions.get('WEBGL_compressed_texture_astc');

if(extension!==null){

return p;

}

}

if(p===MinEquation||p===MaxEquation){

if(capabilities.isWebGL2){

if(p===MinEquation)return 32775;
if(p===MaxEquation)return 32776;

}

extension=extensions.get('EXT_blend_minmax');

if(extension!==null){

if(p===MinEquation)return extension.MIN_EXT;
if(p===MaxEquation)return extension.MAX_EXT;

}

}

if(p===UnsignedInt248Type){

if(capabilities.isWebGL2)return 34042;

extension=extensions.get('WEBGL_depth_texture');

if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;

}

return 0;

}

return{convert:convert};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group(){

Object3D.call(this);

this.type='Group';

}

Group.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Group,

isGroup:true});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera(){

Object3D.call(this);

this.type='Camera';

this.matrixWorldInverse=new Matrix4();

this.projectionMatrix=new Matrix4();
this.projectionMatrixInverse=new Matrix4();

}

Camera.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Camera,

isCamera:true,

copy:function copy(source,recursive){

Object3D.prototype.copy.call(this,source,recursive);

this.matrixWorldInverse.copy(source.matrixWorldInverse);

this.projectionMatrix.copy(source.projectionMatrix);
this.projectionMatrixInverse.copy(source.projectionMatrixInverse);

return this;

},

getWorldDirection:function getWorldDirection(target){

if(target===undefined){

console.warn('THREE.Camera: .getWorldDirection() target is now required');
target=new Vector3();

}

this.updateMatrixWorld(true);

var e=this.matrixWorld.elements;

return target.set(-e[8],-e[9],-e[10]).normalize();

},

updateMatrixWorld:function updateMatrixWorld(force){

Object3D.prototype.updateMatrixWorld.call(this,force);

this.matrixWorldInverse.getInverse(this.matrixWorld);

},

clone:function clone(){

return new this.constructor().copy(this);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera(fov,aspect,near,far){

Camera.call(this);

this.type='PerspectiveCamera';

this.fov=fov!==undefined?fov:50;
this.zoom=1;

this.near=near!==undefined?near:0.1;
this.far=far!==undefined?far:2000;
this.focus=10;

this.aspect=aspect!==undefined?aspect:1;
this.view=null;

this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)

this.updateProjectionMatrix();

}

PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{

constructor:PerspectiveCamera,

isPerspectiveCamera:true,

copy:function copy(source,recursive){

Camera.prototype.copy.call(this,source,recursive);

this.fov=source.fov;
this.zoom=source.zoom;

this.near=source.near;
this.far=source.far;
this.focus=source.focus;

this.aspect=source.aspect;
this.view=source.view===null?null:Object.assign({},source.view);

this.filmGauge=source.filmGauge;
this.filmOffset=source.filmOffset;

return this;

},

/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
setFocalLength:function setFocalLength(focalLength){

// see http://www.bobatkins.com/photography/technical/field_of_view.html
var vExtentSlope=0.5*this.getFilmHeight()/focalLength;

this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);
this.updateProjectionMatrix();

},

/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
getFocalLength:function getFocalLength(){

var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);

return 0.5*this.getFilmHeight()/vExtentSlope;

},

getEffectiveFOV:function getEffectiveFOV(){

return _Math.RAD2DEG*2*Math.atan(
Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);

},

getFilmWidth:function getFilmWidth(){

// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);

},

getFilmHeight:function getFilmHeight(){

// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);

},

/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){

this.aspect=fullWidth/fullHeight;

if(this.view===null){

this.view={
enabled:true,
fullWidth:1,
fullHeight:1,
offsetX:0,
offsetY:0,
width:1,
height:1};


}

this.view.enabled=true;
this.view.fullWidth=fullWidth;
this.view.fullHeight=fullHeight;
this.view.offsetX=x;
this.view.offsetY=y;
this.view.width=width;
this.view.height=height;

this.updateProjectionMatrix();

},

clearViewOffset:function clearViewOffset(){

if(this.view!==null){

this.view.enabled=false;

}

this.updateProjectionMatrix();

},

updateProjectionMatrix:function updateProjectionMatrix(){

var near=this.near,
top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,
height=2*top,
width=this.aspect*height,
left=-0.5*width,
view=this.view;

if(this.view!==null&&this.view.enabled){

var fullWidth=view.fullWidth,
fullHeight=view.fullHeight;

left+=view.offsetX*width/fullWidth;
top-=view.offsetY*height/fullHeight;
width*=view.width/fullWidth;
height*=view.height/fullHeight;

}

var skew=this.filmOffset;
if(skew!==0)left+=near*skew/this.getFilmWidth();

this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);

this.projectionMatrixInverse.getInverse(this.projectionMatrix);

},

toJSON:function toJSON(meta){

var data=Object3D.prototype.toJSON.call(this,meta);

data.object.fov=this.fov;
data.object.zoom=this.zoom;

data.object.near=this.near;
data.object.far=this.far;
data.object.focus=this.focus;

data.object.aspect=this.aspect;

if(this.view!==null)data.object.view=Object.assign({},this.view);

data.object.filmGauge=this.filmGauge;
data.object.filmOffset=this.filmOffset;

return data;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function ArrayCamera(array){

PerspectiveCamera.call(this);

this.cameras=array||[];

}

ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{

constructor:ArrayCamera,

isArrayCamera:true});



/**
 * @author jsantell / https://www.jsantell.com/
 * @author mrdoob / http://mrdoob.com/
 */

var cameraLPos=new Vector3();
var cameraRPos=new Vector3();

/**
 * Assumes 2 cameras that are parallel and share an X-axis, and that
 * the cameras' projection and world matrices have already been set.
 * And that near and far planes are identical for both cameras.
 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
 */
function setProjectionFromUnion(camera,cameraL,cameraR){

cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);

var ipd=cameraLPos.distanceTo(cameraRPos);

var projL=cameraL.projectionMatrix.elements;
var projR=cameraR.projectionMatrix.elements;

// VR systems will have identical far and near planes, and
// most likely identical top and bottom frustum extents.
// Use the left camera for these values.
var near=projL[14]/(projL[10]-1);
var far=projL[14]/(projL[10]+1);
var topFov=(projL[9]+1)/projL[5];
var bottomFov=(projL[9]-1)/projL[5];

var leftFov=(projL[8]-1)/projL[0];
var rightFov=(projR[8]+1)/projR[0];
var left=near*leftFov;
var right=near*rightFov;

// Calculate the new camera's position offset from the
// left camera. xOffset should be roughly half `ipd`.
var zOffset=ipd/(-leftFov+rightFov);
var xOffset=zOffset*-leftFov;

// TODO: Better way to apply this offset?
cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);
camera.translateX(xOffset);
camera.translateZ(zOffset);
camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);
camera.matrixWorldInverse.getInverse(camera.matrixWorld);

// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
var near2=near+zOffset;
var far2=far+zOffset;
var left2=left-xOffset;
var right2=right+(ipd-xOffset);
var top2=topFov*far/far2*near2;
var bottom2=bottomFov*far/far2*near2;

camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebVRManager(renderer){

var renderWidth,renderHeight;
var scope=this;

var device=null;
var frameData=null;

var poseTarget=null;

var controllers=[];
var standingMatrix=new Matrix4();
var standingMatrixInverse=new Matrix4();

var framebufferScaleFactor=1.0;

var referenceSpaceType='local-floor';

if(typeof window!=='undefined'&&'VRFrameData'in window){

frameData=new window.VRFrameData();
window.addEventListener('vrdisplaypresentchange',onVRDisplayPresentChange,false);

}

var matrixWorldInverse=new Matrix4();
var tempQuaternion=new Quaternion();
var tempPosition=new Vector3();

var cameraL=new PerspectiveCamera();
cameraL.viewport=new Vector4();
cameraL.layers.enable(1);

var cameraR=new PerspectiveCamera();
cameraR.viewport=new Vector4();
cameraR.layers.enable(2);

var cameraVR=new ArrayCamera([cameraL,cameraR]);
cameraVR.layers.enable(1);
cameraVR.layers.enable(2);

//

function isPresenting(){

return device!==null&&device.isPresenting===true;

}

var currentSize=new Vector2(),currentPixelRatio;

function onVRDisplayPresentChange(){

if(isPresenting()){

var eyeParameters=device.getEyeParameters('left');
renderWidth=2*eyeParameters.renderWidth*framebufferScaleFactor;
renderHeight=eyeParameters.renderHeight*framebufferScaleFactor;

currentPixelRatio=renderer.getPixelRatio();
renderer.getSize(currentSize);

renderer.setDrawingBufferSize(renderWidth,renderHeight,1);

cameraL.viewport.set(0,0,renderWidth/2,renderHeight);
cameraR.viewport.set(renderWidth/2,0,renderWidth/2,renderHeight);

animation.start();

}else{

if(scope.enabled){

renderer.setDrawingBufferSize(currentSize.width,currentSize.height,currentPixelRatio);

}

animation.stop();

}

}

//

var triggers=[];

function findGamepad(id){

var gamepads=navigator.getGamepads&&navigator.getGamepads();

for(var i=0,j=0,l=gamepads.length;i<l;i++){

var gamepad=gamepads[i];

if(gamepad&&(gamepad.id==='Daydream Controller'||
gamepad.id==='Gear VR Controller'||gamepad.id==='Oculus Go Controller'||
gamepad.id==='OpenVR Gamepad'||gamepad.id.startsWith('Oculus Touch')||
gamepad.id.startsWith('Spatial Controller'))){

if(j===id)return gamepad;

j++;

}

}

}

function updateControllers(){

for(var i=0;i<controllers.length;i++){

var controller=controllers[i];

var gamepad=findGamepad(i);

if(gamepad!==undefined&&gamepad.pose!==undefined){

if(gamepad.pose===null)return;

// Pose

var pose=gamepad.pose;

if(pose.hasPosition===false)controller.position.set(0.2,-0.6,-0.05);

if(pose.position!==null)controller.position.fromArray(pose.position);
if(pose.orientation!==null)controller.quaternion.fromArray(pose.orientation);
controller.matrix.compose(controller.position,controller.quaternion,controller.scale);
controller.matrix.premultiply(standingMatrix);
controller.matrix.decompose(controller.position,controller.quaternion,controller.scale);
controller.matrixWorldNeedsUpdate=true;
controller.visible=true;

// Trigger

var buttonId=gamepad.id==='Daydream Controller'?0:1;

if(triggers[i]===undefined)triggers[i]=false;

if(triggers[i]!==gamepad.buttons[buttonId].pressed){

triggers[i]=gamepad.buttons[buttonId].pressed;

if(triggers[i]===true){

controller.dispatchEvent({type:'selectstart'});

}else{

controller.dispatchEvent({type:'selectend'});
controller.dispatchEvent({type:'select'});

}

}

}else{

controller.visible=false;

}

}

}

function updateViewportFromBounds(viewport,bounds){

if(bounds!==null&&bounds.length===4){

viewport.set(bounds[0]*renderWidth,bounds[1]*renderHeight,bounds[2]*renderWidth,bounds[3]*renderHeight);

}

}

//

this.enabled=false;

this.getController=function(id){

var controller=controllers[id];

if(controller===undefined){

controller=new Group();
controller.matrixAutoUpdate=false;
controller.visible=false;

controllers[id]=controller;

}

return controller;

};

this.getDevice=function(){

return device;

};

this.setDevice=function(value){

if(value!==undefined)device=value;

animation.setContext(value);

};

this.setFramebufferScaleFactor=function(value){

framebufferScaleFactor=value;

};

this.setReferenceSpaceType=function(value){

referenceSpaceType=value;

};

this.setPoseTarget=function(object){

if(object!==undefined)poseTarget=object;

};

this.getCamera=function(camera){

var userHeight=referenceSpaceType==='local-floor'?1.6:0;

if(isPresenting()===false){

camera.position.set(0,userHeight,0);
camera.rotation.set(0,0,0);

return camera;

}

device.depthNear=camera.near;
device.depthFar=camera.far;

device.getFrameData(frameData);

//

if(referenceSpaceType==='local-floor'){

var stageParameters=device.stageParameters;

if(stageParameters){

standingMatrix.fromArray(stageParameters.sittingToStandingTransform);

}else{

standingMatrix.makeTranslation(0,userHeight,0);

}

}


var pose=frameData.pose;
var poseObject=poseTarget!==null?poseTarget:camera;

// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
poseObject.matrix.copy(standingMatrix);
poseObject.matrix.decompose(poseObject.position,poseObject.quaternion,poseObject.scale);

if(pose.orientation!==null){

tempQuaternion.fromArray(pose.orientation);
poseObject.quaternion.multiply(tempQuaternion);

}

if(pose.position!==null){

tempQuaternion.setFromRotationMatrix(standingMatrix);
tempPosition.fromArray(pose.position);
tempPosition.applyQuaternion(tempQuaternion);
poseObject.position.add(tempPosition);

}

poseObject.updateMatrixWorld();

//

cameraL.near=camera.near;
cameraR.near=camera.near;

cameraL.far=camera.far;
cameraR.far=camera.far;

cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);

// TODO (mrdoob) Double check this code

standingMatrixInverse.getInverse(standingMatrix);

if(referenceSpaceType==='local-floor'){

cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
cameraR.matrixWorldInverse.multiply(standingMatrixInverse);

}

var parent=poseObject.parent;

if(parent!==null){

matrixWorldInverse.getInverse(parent.matrixWorld);

cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
cameraR.matrixWorldInverse.multiply(matrixWorldInverse);

}

// envMap and Mirror needs camera.matrixWorld

cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);

cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);

setProjectionFromUnion(cameraVR,cameraL,cameraR);

//

var layers=device.getLayers();

if(layers.length){

var layer=layers[0];

updateViewportFromBounds(cameraL.viewport,layer.leftBounds);
updateViewportFromBounds(cameraR.viewport,layer.rightBounds);

}

updateControllers();

return cameraVR;

};

this.getStandingMatrix=function(){

return standingMatrix;

};

this.isPresenting=isPresenting;

// Animation Loop

var animation=new WebGLAnimation();

this.setAnimationLoop=function(callback){

animation.setAnimationLoop(callback);

if(isPresenting())animation.start();

};

this.submitFrame=function(){

if(isPresenting())device.submitFrame();

};

this.dispose=function(){

if(typeof window!=='undefined'){

window.removeEventListener('vrdisplaypresentchange',onVRDisplayPresentChange);

}

};

// DEPRECATED

this.setFrameOfReferenceType=function(){

console.warn('THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.');

};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager(renderer){

var gl=renderer.context;

var session=null;

var referenceSpace=null;
var referenceSpaceType='local-floor';

var pose=null;

var controllers=[];
var inputSources=[];

function isPresenting(){

return session!==null&&referenceSpace!==null;

}

//

var cameraL=new PerspectiveCamera();
cameraL.layers.enable(1);
cameraL.viewport=new Vector4();

var cameraR=new PerspectiveCamera();
cameraR.layers.enable(2);
cameraR.viewport=new Vector4();

var cameraVR=new ArrayCamera([cameraL,cameraR]);
cameraVR.layers.enable(1);
cameraVR.layers.enable(2);

//

this.enabled=false;

this.getController=function(id){

var controller=controllers[id];

if(controller===undefined){

controller=new Group();
controller.matrixAutoUpdate=false;
controller.visible=false;

controllers[id]=controller;

}

return controller;

};

//

function onSessionEvent(event){

for(var i=0;i<controllers.length;i++){

if(inputSources[i]===event.inputSource){

controllers[i].dispatchEvent({type:event.type});

}

}

}

function onSessionEnd(){

renderer.setFramebuffer(null);
renderer.setRenderTarget(renderer.getRenderTarget());// Hack #15830
animation.stop();

}

function onRequestReferenceSpace(value){

referenceSpace=value;

animation.setContext(session);
animation.start();

}

this.setFramebufferScaleFactor=function(value){

};

this.setReferenceSpaceType=function(value){

referenceSpaceType=value;

};

this.getSession=function(){

return session;

};

this.setSession=function(value){

session=value;

if(session!==null){

session.addEventListener('select',onSessionEvent);
session.addEventListener('selectstart',onSessionEvent);
session.addEventListener('selectend',onSessionEvent);
session.addEventListener('end',onSessionEnd);

session.updateRenderState({baseLayer:new XRWebGLLayer(session,gl)});

session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);

//

inputSources=session.inputSources;

session.addEventListener('inputsourceschange',function(){

inputSources=session.inputSources;
console.log(inputSources);

for(var i=0;i<controllers.length;i++){

var controller=controllers[i];
controller.userData.inputSource=inputSources[i];

}

});

}

};

function updateCamera(camera,parent){

if(parent===null){

camera.matrixWorld.copy(camera.matrix);

}else{

camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);

}

camera.matrixWorldInverse.getInverse(camera.matrixWorld);

}

this.getCamera=function(camera){

if(isPresenting()){

var parent=camera.parent;
var cameras=cameraVR.cameras;

updateCamera(cameraVR,parent);

for(var i=0;i<cameras.length;i++){

updateCamera(cameras[i],parent);

}

// update camera and its children

camera.matrixWorld.copy(cameraVR.matrixWorld);

var children=camera.children;

for(var i=0,l=children.length;i<l;i++){

children[i].updateMatrixWorld(true);

}

setProjectionFromUnion(cameraVR,cameraL,cameraR);

return cameraVR;

}

return camera;

};

this.isPresenting=isPresenting;

// Animation Loop

var onAnimationFrameCallback=null;

function onAnimationFrame(time,frame){

pose=frame.getViewerPose(referenceSpace);

if(pose!==null){

var views=pose.views;
var baseLayer=session.renderState.baseLayer;

renderer.setFramebuffer(baseLayer.framebuffer);

for(var i=0;i<views.length;i++){

var view=views[i];
var viewport=baseLayer.getViewport(view);
var viewMatrix=view.transform.inverse.matrix;

var camera=cameraVR.cameras[i];
camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
camera.projectionMatrix.fromArray(view.projectionMatrix);
camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);

if(i===0){

cameraVR.matrix.copy(camera.matrix);

}

}

}

//

for(var i=0;i<controllers.length;i++){

var controller=controllers[i];

var inputSource=inputSources[i];

if(inputSource){

var inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);

if(inputPose!==null){

controller.matrix.fromArray(inputPose.transform.matrix);
controller.matrix.decompose(controller.position,controller.rotation,controller.scale);
controller.visible=true;

continue;

}

}

controller.visible=false;

}

if(onAnimationFrameCallback)onAnimationFrameCallback(time);

}

var animation=new WebGLAnimation();
animation.setAnimationLoop(onAnimationFrame);

this.setAnimationLoop=function(callback){

onAnimationFrameCallback=callback;

};

this.dispose=function(){};

// DEPRECATED

this.getStandingMatrix=function(){

console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
return new Matrix4();

};

this.getDevice=function(){

console.warn('THREE.WebXRManager: getDevice() has been deprecated.');

};

this.setDevice=function(){

console.warn('THREE.WebXRManager: setDevice() has been deprecated.');

};

this.setFrameOfReferenceType=function(){

console.warn('THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.');

};

this.submitFrame=function(){};

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer(parameters){

console.log('THREE.WebGLRenderer',REVISION);

parameters=parameters||{};

var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),
_context=parameters.context!==undefined?parameters.context:null,

_alpha=parameters.alpha!==undefined?parameters.alpha:false,
_depth=parameters.depth!==undefined?parameters.depth:true,
_stencil=parameters.stencil!==undefined?parameters.stencil:true,
_antialias=parameters.antialias!==undefined?parameters.antialias:false,
_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,
_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,
_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',
_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;

var currentRenderList=null;
var currentRenderState=null;

// public properties

this.domElement=_canvas;
this.context=null;

// Debug configuration container
this.debug={

/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
checkShaderErrors:true};


// clearing

this.autoClear=true;
this.autoClearColor=true;
this.autoClearDepth=true;
this.autoClearStencil=true;

// scene graph

this.sortObjects=true;

// user-defined clipping

this.clippingPlanes=[];
this.localClippingEnabled=false;

// physically based shading

this.gammaFactor=2.0;// for backwards compatibility
this.gammaInput=false;
this.gammaOutput=false;

// physical lights

this.physicallyCorrectLights=false;

// tone mapping

this.toneMapping=LinearToneMapping;
this.toneMappingExposure=1.0;
this.toneMappingWhitePoint=1.0;

// morphs

this.maxMorphTargets=8;
this.maxMorphNormals=4;

// internal properties

var _this=this,

_isContextLost=false,

// internal state cache

_framebuffer=null,

_currentActiveCubeFace=0,
_currentActiveMipmapLevel=0,
_currentRenderTarget=null,
_currentFramebuffer=null,
_currentMaterialId=-1,

// geometry and program caching

_currentGeometryProgram={
geometry:null,
program:null,
wireframe:false},


_currentCamera=null,
_currentArrayCamera=null,

_currentViewport=new Vector4(),
_currentScissor=new Vector4(),
_currentScissorTest=null,

//

_width=_canvas.width,
_height=_canvas.height,

_pixelRatio=1,

_viewport=new Vector4(0,0,_width,_height),
_scissor=new Vector4(0,0,_width,_height),
_scissorTest=false,

// frustum

_frustum=new Frustum(),

// clipping

_clipping=new WebGLClipping(),
_clippingEnabled=false,
_localClippingEnabled=false,

// camera matrices cache

_projScreenMatrix=new Matrix4(),

_vector3=new Vector3();

function getTargetPixelRatio(){

return _currentRenderTarget===null?_pixelRatio:1;

}

// initialize

var _gl;

try{

var contextAttributes={
alpha:_alpha,
depth:_depth,
stencil:_stencil,
antialias:_antialias,
premultipliedAlpha:_premultipliedAlpha,
preserveDrawingBuffer:_preserveDrawingBuffer,
powerPreference:_powerPreference,
failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat,
xrCompatible:true};


// event listeners must be registered before WebGL context is created, see #12753

_canvas.addEventListener('webglcontextlost',onContextLost,false);
_canvas.addEventListener('webglcontextrestored',onContextRestore,false);

_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);

if(_gl===null){

if(_canvas.getContext('webgl')!==null){

throw new Error('Error creating WebGL context with your selected attributes.');

}else{

throw new Error('Error creating WebGL context.');

}

}

// Some experimental-webgl implementations do not have getShaderPrecisionFormat

if(_gl.getShaderPrecisionFormat===undefined){

_gl.getShaderPrecisionFormat=function(){

return{'rangeMin':1,'rangeMax':1,'precision':1};

};

}

}catch(error){

console.error('THREE.WebGLRenderer: '+error.message);
throw error;

}

var extensions,capabilities,state,info;
var properties,textures,attributes,geometries,objects;
var programCache,renderLists,renderStates;

var background,morphtargets,bufferRenderer,indexedBufferRenderer;

var utils;

function initGLContext(){

extensions=new WebGLExtensions(_gl);

capabilities=new WebGLCapabilities(_gl,extensions,parameters);

if(!capabilities.isWebGL2){

extensions.get('WEBGL_depth_texture');
extensions.get('OES_texture_float');
extensions.get('OES_texture_half_float');
extensions.get('OES_texture_half_float_linear');
extensions.get('OES_standard_derivatives');
extensions.get('OES_element_index_uint');
extensions.get('ANGLE_instanced_arrays');

}

extensions.get('OES_texture_float_linear');

utils=new WebGLUtils(_gl,extensions,capabilities);

state=new WebGLState(_gl,extensions,utils,capabilities);
state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

info=new WebGLInfo(_gl);
properties=new WebGLProperties();
textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);
attributes=new WebGLAttributes(_gl);
geometries=new WebGLGeometries(_gl,attributes,info);
objects=new WebGLObjects(geometries,info);
morphtargets=new WebGLMorphtargets(_gl);
programCache=new WebGLPrograms(_this,extensions,capabilities,textures);
renderLists=new WebGLRenderLists();
renderStates=new WebGLRenderStates();

background=new WebGLBackground(_this,state,objects,_premultipliedAlpha);

bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);
indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);

info.programs=programCache.programs;

_this.context=_gl;
_this.capabilities=capabilities;
_this.extensions=extensions;
_this.properties=properties;
_this.renderLists=renderLists;
_this.state=state;
_this.info=info;

}

initGLContext();

// vr

var vr=typeof navigator!=='undefined'&&'xr'in navigator&&'supportsSession'in navigator.xr?new WebXRManager(_this):new WebVRManager(_this);

this.vr=vr;

// shadow map

var shadowMap=new WebGLShadowMap(_this,objects,capabilities.maxTextureSize);

this.shadowMap=shadowMap;

// API

this.getContext=function(){

return _gl;

};

this.getContextAttributes=function(){

return _gl.getContextAttributes();

};

this.forceContextLoss=function(){

var extension=extensions.get('WEBGL_lose_context');
if(extension)extension.loseContext();

};

this.forceContextRestore=function(){

var extension=extensions.get('WEBGL_lose_context');
if(extension)extension.restoreContext();

};

this.getPixelRatio=function(){

return _pixelRatio;

};

this.setPixelRatio=function(value){

if(value===undefined)return;

_pixelRatio=value;

this.setSize(_width,_height,false);

};

this.getSize=function(target){

if(target===undefined){

console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');

target=new Vector2();

}

return target.set(_width,_height);

};

this.setSize=function(width,height,updateStyle){

if(vr.isPresenting()){

console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
return;

}

_width=width;
_height=height;

_canvas.width=width*_pixelRatio;
_canvas.height=height*_pixelRatio;

if(updateStyle!==false){

_canvas.style.width=width+'px';
_canvas.style.height=height+'px';

}

this.setViewport(0,0,width,height);

};

this.getDrawingBufferSize=function(target){

if(target===undefined){

console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');

target=new Vector2();

}

return target.set(_width*_pixelRatio,_height*_pixelRatio);

};

this.setDrawingBufferSize=function(width,height,pixelRatio){

_width=width;
_height=height;

_pixelRatio=pixelRatio;

_canvas.width=width*pixelRatio;
_canvas.height=height*pixelRatio;

this.setViewport(0,0,width,height);

};

this.getCurrentViewport=function(target){

if(target===undefined){

console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');

target=new Vector4();

}

return target.copy(_currentViewport);

};

this.getViewport=function(target){

return target.copy(_viewport);

};

this.setViewport=function(x,y,width,height){

if(x.isVector4){

_viewport.set(x.x,x.y,x.z,x.w);

}else{

_viewport.set(x,y,width,height);

}

state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

};

this.getScissor=function(target){

return target.copy(_scissor);

};

this.setScissor=function(x,y,width,height){

if(x.isVector4){

_scissor.set(x.x,x.y,x.z,x.w);

}else{

_scissor.set(x,y,width,height);

}

state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));

};

this.getScissorTest=function(){

return _scissorTest;

};

this.setScissorTest=function(boolean){

state.setScissorTest(_scissorTest=boolean);

};

// Clearing

this.getClearColor=function(){

return background.getClearColor();

};

this.setClearColor=function(){

background.setClearColor.apply(background,arguments);

};

this.getClearAlpha=function(){

return background.getClearAlpha();

};

this.setClearAlpha=function(){

background.setClearAlpha.apply(background,arguments);

};

this.clear=function(color,depth,stencil){

var bits=0;

if(color===undefined||color)bits|=16384;
if(depth===undefined||depth)bits|=256;
if(stencil===undefined||stencil)bits|=1024;

_gl.clear(bits);

};

this.clearColor=function(){

this.clear(true,false,false);

};

this.clearDepth=function(){

this.clear(false,true,false);

};

this.clearStencil=function(){

this.clear(false,false,true);

};

//

this.dispose=function(){

_canvas.removeEventListener('webglcontextlost',onContextLost,false);
_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);

renderLists.dispose();
renderStates.dispose();
properties.dispose();
objects.dispose();

vr.dispose();

animation.stop();

};

// Events

function onContextLost(event){

event.preventDefault();

console.log('THREE.WebGLRenderer: Context Lost.');

_isContextLost=true;

}

function onContextRestore()/* event */{

console.log('THREE.WebGLRenderer: Context Restored.');

_isContextLost=false;

initGLContext();

}

function onMaterialDispose(event){

var material=event.target;

material.removeEventListener('dispose',onMaterialDispose);

deallocateMaterial(material);

}

// Buffer deallocation

function deallocateMaterial(material){

releaseMaterialProgramReference(material);

properties.remove(material);

}


function releaseMaterialProgramReference(material){

var programInfo=properties.get(material).program;

material.program=undefined;

if(programInfo!==undefined){

programCache.releaseProgram(programInfo);

}

}

// Buffer rendering

function renderObjectImmediate(object,program){

object.render(function(object){

_this.renderBufferImmediate(object,program);

});

}

this.renderBufferImmediate=function(object,program){

state.initAttributes();

var buffers=properties.get(object);

if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();
if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();
if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();
if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();

var programAttributes=program.getAttributes();

if(object.hasPositions){

_gl.bindBuffer(34962,buffers.position);
_gl.bufferData(34962,object.positionArray,35048);

state.enableAttribute(programAttributes.position);
_gl.vertexAttribPointer(programAttributes.position,3,5126,false,0,0);

}

if(object.hasNormals){

_gl.bindBuffer(34962,buffers.normal);
_gl.bufferData(34962,object.normalArray,35048);

state.enableAttribute(programAttributes.normal);
_gl.vertexAttribPointer(programAttributes.normal,3,5126,false,0,0);

}

if(object.hasUvs){

_gl.bindBuffer(34962,buffers.uv);
_gl.bufferData(34962,object.uvArray,35048);

state.enableAttribute(programAttributes.uv);
_gl.vertexAttribPointer(programAttributes.uv,2,5126,false,0,0);

}

if(object.hasColors){

_gl.bindBuffer(34962,buffers.color);
_gl.bufferData(34962,object.colorArray,35048);

state.enableAttribute(programAttributes.color);
_gl.vertexAttribPointer(programAttributes.color,3,5126,false,0,0);

}

state.disableUnusedAttributes();

_gl.drawArrays(4,0,object.count);

object.count=0;

};

this.renderBufferDirect=function(camera,fog,geometry,material,object,group){

var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;

state.setMaterial(material,frontFaceCW);

var program=setProgram(camera,fog,material,object);

var updateBuffers=false;

if(_currentGeometryProgram.geometry!==geometry.id||
_currentGeometryProgram.program!==program.id||
_currentGeometryProgram.wireframe!==(material.wireframe===true)){

_currentGeometryProgram.geometry=geometry.id;
_currentGeometryProgram.program=program.id;
_currentGeometryProgram.wireframe=material.wireframe===true;
updateBuffers=true;

}

if(object.morphTargetInfluences){

morphtargets.update(object,geometry,material,program);

updateBuffers=true;

}

//

var index=geometry.index;
var position=geometry.attributes.position;
var rangeFactor=1;

if(material.wireframe===true){

index=geometries.getWireframeAttribute(geometry);
rangeFactor=2;

}

var attribute;
var renderer=bufferRenderer;

if(index!==null){

attribute=attributes.get(index);

renderer=indexedBufferRenderer;
renderer.setIndex(attribute);

}

if(updateBuffers){

setupVertexAttributes(material,program,geometry);

if(index!==null){

_gl.bindBuffer(34963,attribute.buffer);

}

}

//

var dataCount=Infinity;

if(index!==null){

dataCount=index.count;

}else if(position!==undefined){

dataCount=position.count;

}

var rangeStart=geometry.drawRange.start*rangeFactor;
var rangeCount=geometry.drawRange.count*rangeFactor;

var groupStart=group!==null?group.start*rangeFactor:0;
var groupCount=group!==null?group.count*rangeFactor:Infinity;

var drawStart=Math.max(rangeStart,groupStart);
var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;

var drawCount=Math.max(0,drawEnd-drawStart+1);

if(drawCount===0)return;

//

if(object.isMesh){

if(material.wireframe===true){

state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());
renderer.setMode(1);

}else{

switch(object.drawMode){

case TrianglesDrawMode:
renderer.setMode(4);
break;

case TriangleStripDrawMode:
renderer.setMode(5);
break;

case TriangleFanDrawMode:
renderer.setMode(6);
break;}



}


}else if(object.isLine){

var lineWidth=material.linewidth;

if(lineWidth===undefined)lineWidth=1;// Not using Line*Material

state.setLineWidth(lineWidth*getTargetPixelRatio());

if(object.isLineSegments){

renderer.setMode(1);

}else if(object.isLineLoop){

renderer.setMode(2);

}else{

renderer.setMode(3);

}

}else if(object.isPoints){

renderer.setMode(0);

}else if(object.isSprite){

renderer.setMode(4);

}

if(geometry&&geometry.isInstancedBufferGeometry){

if(geometry.maxInstancedCount>0){

renderer.renderInstances(geometry,drawStart,drawCount);

}

}else{

renderer.render(drawStart,drawCount);

}

};

function setupVertexAttributes(material,program,geometry){

if(geometry&&geometry.isInstancedBufferGeometry&&!capabilities.isWebGL2){

if(extensions.get('ANGLE_instanced_arrays')===null){

console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
return;

}

}

state.initAttributes();

var geometryAttributes=geometry.attributes;

var programAttributes=program.getAttributes();

var materialDefaultAttributeValues=material.defaultAttributeValues;

for(var name in programAttributes){

var programAttribute=programAttributes[name];

if(programAttribute>=0){

var geometryAttribute=geometryAttributes[name];

if(geometryAttribute!==undefined){

var normalized=geometryAttribute.normalized;
var size=geometryAttribute.itemSize;

var attribute=attributes.get(geometryAttribute);

// TODO Attribute may not be available on context restore

if(attribute===undefined)continue;

var buffer=attribute.buffer;
var type=attribute.type;
var bytesPerElement=attribute.bytesPerElement;

if(geometryAttribute.isInterleavedBufferAttribute){

var data=geometryAttribute.data;
var stride=data.stride;
var offset=geometryAttribute.offset;

if(data&&data.isInstancedInterleavedBuffer){

state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);

if(geometry.maxInstancedCount===undefined){

geometry.maxInstancedCount=data.meshPerAttribute*data.count;

}

}else{

state.enableAttribute(programAttribute);

}

_gl.bindBuffer(34962,buffer);
_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,offset*bytesPerElement);

}else{

if(geometryAttribute.isInstancedBufferAttribute){

state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);

if(geometry.maxInstancedCount===undefined){

geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;

}

}else{

state.enableAttribute(programAttribute);

}

_gl.bindBuffer(34962,buffer);
_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,0);

}

}else if(materialDefaultAttributeValues!==undefined){

var value=materialDefaultAttributeValues[name];

if(value!==undefined){

switch(value.length){

case 2:
_gl.vertexAttrib2fv(programAttribute,value);
break;

case 3:
_gl.vertexAttrib3fv(programAttribute,value);
break;

case 4:
_gl.vertexAttrib4fv(programAttribute,value);
break;

default:
_gl.vertexAttrib1fv(programAttribute,value);}



}

}

}

}

state.disableUnusedAttributes();

}

// Compile

this.compile=function(scene,camera){

currentRenderState=renderStates.get(scene,camera);
currentRenderState.init();

scene.traverse(function(object){

if(object.isLight){

currentRenderState.pushLight(object);

if(object.castShadow){

currentRenderState.pushShadow(object);

}

}

});

currentRenderState.setupLights(camera);

scene.traverse(function(object){

if(object.material){

if(Array.isArray(object.material)){

for(var i=0;i<object.material.length;i++){

initMaterial(object.material[i],scene.fog,object);

}

}else{

initMaterial(object.material,scene.fog,object);

}

}

});

};

// Animation Loop

var onAnimationFrameCallback=null;

function onAnimationFrame(time){

if(vr.isPresenting())return;
if(onAnimationFrameCallback)onAnimationFrameCallback(time);

}

var animation=new WebGLAnimation();
animation.setAnimationLoop(onAnimationFrame);

if(typeof window!=='undefined')animation.setContext(window);

this.setAnimationLoop=function(callback){

onAnimationFrameCallback=callback;
vr.setAnimationLoop(callback);

animation.start();

};

// Rendering

this.render=function(scene,camera){

var renderTarget,forceClear;

if(arguments[2]!==undefined){

console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
renderTarget=arguments[2];

}

if(arguments[3]!==undefined){

console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
forceClear=arguments[3];

}

if(!(camera&&camera.isCamera)){

console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
return;

}

if(_isContextLost)return;

// reset caching for this frame

_currentGeometryProgram.geometry=null;
_currentGeometryProgram.program=null;
_currentGeometryProgram.wireframe=false;
_currentMaterialId=-1;
_currentCamera=null;

// update scene graph

if(scene.autoUpdate===true)scene.updateMatrixWorld();

// update camera matrices and frustum

if(camera.parent===null)camera.updateMatrixWorld();

if(vr.enabled){

camera=vr.getCamera(camera);

}

//

currentRenderState=renderStates.get(scene,camera);
currentRenderState.init();

scene.onBeforeRender(_this,scene,camera,renderTarget||_currentRenderTarget);

_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);
_frustum.setFromMatrix(_projScreenMatrix);

_localClippingEnabled=this.localClippingEnabled;
_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);

currentRenderList=renderLists.get(scene,camera);
currentRenderList.init();

projectObject(scene,camera,0,_this.sortObjects);

if(_this.sortObjects===true){

currentRenderList.sort();

}

//

if(_clippingEnabled)_clipping.beginShadows();

var shadowsArray=currentRenderState.state.shadowsArray;

shadowMap.render(shadowsArray,scene,camera);

currentRenderState.setupLights(camera);

if(_clippingEnabled)_clipping.endShadows();

//

if(this.info.autoReset)this.info.reset();

if(renderTarget!==undefined){

this.setRenderTarget(renderTarget);

}

//

background.render(currentRenderList,scene,camera,forceClear);

// render scene

var opaqueObjects=currentRenderList.opaque;
var transparentObjects=currentRenderList.transparent;

if(scene.overrideMaterial){

var overrideMaterial=scene.overrideMaterial;

if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);
if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);

}else{

// opaque pass (front-to-back order)

if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);

// transparent pass (back-to-front order)

if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);

}

//

scene.onAfterRender(_this,scene,camera);

//

if(_currentRenderTarget!==null){

// Generate mipmap if we're using any kind of mipmap filtering

textures.updateRenderTargetMipmap(_currentRenderTarget);

// resolve multisample renderbuffers to a single-sample texture if necessary

textures.updateMultisampleRenderTarget(_currentRenderTarget);

}

// Ensure depth buffer writing is enabled so it can be cleared on next render

state.buffers.depth.setTest(true);
state.buffers.depth.setMask(true);
state.buffers.color.setMask(true);

state.setPolygonOffset(false);

if(vr.enabled){

vr.submitFrame();

}

// _gl.finish();

currentRenderList=null;
currentRenderState=null;

};

function projectObject(object,camera,groupOrder,sortObjects){

if(object.visible===false)return;

var visible=object.layers.test(camera.layers);

if(visible){

if(object.isGroup){

groupOrder=object.renderOrder;

}else if(object.isLight){

currentRenderState.pushLight(object);

if(object.castShadow){

currentRenderState.pushShadow(object);

}

}else if(object.isSprite){

if(!object.frustumCulled||_frustum.intersectsSprite(object)){

if(sortObjects){

_vector3.setFromMatrixPosition(object.matrixWorld).
applyMatrix4(_projScreenMatrix);

}

var geometry=objects.update(object);
var material=object.material;

if(material.visible){

currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);

}

}

}else if(object.isImmediateRenderObject){

if(sortObjects){

_vector3.setFromMatrixPosition(object.matrixWorld).
applyMatrix4(_projScreenMatrix);

}

currentRenderList.push(object,null,object.material,groupOrder,_vector3.z,null);

}else if(object.isMesh||object.isLine||object.isPoints){

if(object.isSkinnedMesh){

object.skeleton.update();

}

if(!object.frustumCulled||_frustum.intersectsObject(object)){

if(sortObjects){

_vector3.setFromMatrixPosition(object.matrixWorld).
applyMatrix4(_projScreenMatrix);

}

var geometry=objects.update(object);
var material=object.material;

if(Array.isArray(material)){

var groups=geometry.groups;

for(var i=0,l=groups.length;i<l;i++){

var group=groups[i];
var groupMaterial=material[group.materialIndex];

if(groupMaterial&&groupMaterial.visible){

currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector3.z,group);

}

}

}else if(material.visible){

currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);

}

}

}

}

var children=object.children;

for(var i=0,l=children.length;i<l;i++){

projectObject(children[i],camera,groupOrder,sortObjects);

}

}

function renderObjects(renderList,scene,camera,overrideMaterial){

for(var i=0,l=renderList.length;i<l;i++){

var renderItem=renderList[i];

var object=renderItem.object;
var geometry=renderItem.geometry;
var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;
var group=renderItem.group;

if(camera.isArrayCamera){

_currentArrayCamera=camera;

var cameras=camera.cameras;

for(var j=0,jl=cameras.length;j<jl;j++){

var camera2=cameras[j];

if(object.layers.test(camera2.layers)){

state.viewport(_currentViewport.copy(camera2.viewport));

currentRenderState.setupLights(camera2);

renderObject(object,scene,camera2,geometry,material,group);

}

}

}else{

_currentArrayCamera=null;

renderObject(object,scene,camera,geometry,material,group);

}

}

}

function renderObject(object,scene,camera,geometry,material,group){

object.onBeforeRender(_this,scene,camera,geometry,material,group);
currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);

object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);
object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

if(object.isImmediateRenderObject){

state.setMaterial(material);

var program=setProgram(camera,scene.fog,material,object);

_currentGeometryProgram.geometry=null;
_currentGeometryProgram.program=null;
_currentGeometryProgram.wireframe=false;

renderObjectImmediate(object,program);

}else{

_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);

}

object.onAfterRender(_this,scene,camera,geometry,material,group);
currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);

}

function initMaterial(material,fog,object){

var materialProperties=properties.get(material);

var lights=currentRenderState.state.lights;
var shadowsArray=currentRenderState.state.shadowsArray;

var lightsHash=materialProperties.lightsHash;
var lightsStateHash=lights.state.hash;

var parameters=programCache.getParameters(
material,lights.state,shadowsArray,fog,_clipping.numPlanes,_clipping.numIntersection,object);

var code=programCache.getProgramCode(material,parameters);

var program=materialProperties.program;
var programChange=true;

if(program===undefined){

// new material
material.addEventListener('dispose',onMaterialDispose);

}else if(program.code!==code){

// changed glsl or parameters
releaseMaterialProgramReference(material);

}else if(lightsHash.stateID!==lightsStateHash.stateID||
lightsHash.directionalLength!==lightsStateHash.directionalLength||
lightsHash.pointLength!==lightsStateHash.pointLength||
lightsHash.spotLength!==lightsStateHash.spotLength||
lightsHash.rectAreaLength!==lightsStateHash.rectAreaLength||
lightsHash.hemiLength!==lightsStateHash.hemiLength||
lightsHash.shadowsLength!==lightsStateHash.shadowsLength){

lightsHash.stateID=lightsStateHash.stateID;
lightsHash.directionalLength=lightsStateHash.directionalLength;
lightsHash.pointLength=lightsStateHash.pointLength;
lightsHash.spotLength=lightsStateHash.spotLength;
lightsHash.rectAreaLength=lightsStateHash.rectAreaLength;
lightsHash.hemiLength=lightsStateHash.hemiLength;
lightsHash.shadowsLength=lightsStateHash.shadowsLength;

programChange=false;

}else if(parameters.shaderID!==undefined){

// same glsl and uniform list
return;

}else{

// only rebuild uniform list
programChange=false;

}

if(programChange){

if(parameters.shaderID){

var shader=ShaderLib[parameters.shaderID];

materialProperties.shader={
name:material.type,
uniforms:cloneUniforms(shader.uniforms),
vertexShader:shader.vertexShader,
fragmentShader:shader.fragmentShader};


}else{

materialProperties.shader={
name:material.type,
uniforms:material.uniforms,
vertexShader:material.vertexShader,
fragmentShader:material.fragmentShader};


}

material.onBeforeCompile(materialProperties.shader,_this);

// Computing code again as onBeforeCompile may have changed the shaders
code=programCache.getProgramCode(material,parameters);

program=programCache.acquireProgram(material,materialProperties.shader,parameters,code);

materialProperties.program=program;
material.program=program;

}

var programAttributes=program.getAttributes();

if(material.morphTargets){

material.numSupportedMorphTargets=0;

for(var i=0;i<_this.maxMorphTargets;i++){

if(programAttributes['morphTarget'+i]>=0){

material.numSupportedMorphTargets++;

}

}

}

if(material.morphNormals){

material.numSupportedMorphNormals=0;

for(var i=0;i<_this.maxMorphNormals;i++){

if(programAttributes['morphNormal'+i]>=0){

material.numSupportedMorphNormals++;

}

}

}

var uniforms=materialProperties.shader.uniforms;

if(!material.isShaderMaterial&&
!material.isRawShaderMaterial||
material.clipping===true){

materialProperties.numClippingPlanes=_clipping.numPlanes;
materialProperties.numIntersection=_clipping.numIntersection;
uniforms.clippingPlanes=_clipping.uniform;

}

materialProperties.fog=fog;

// store the light setup it was created for
if(lightsHash===undefined){

materialProperties.lightsHash=lightsHash={};

}

lightsHash.stateID=lightsStateHash.stateID;
lightsHash.directionalLength=lightsStateHash.directionalLength;
lightsHash.pointLength=lightsStateHash.pointLength;
lightsHash.spotLength=lightsStateHash.spotLength;
lightsHash.rectAreaLength=lightsStateHash.rectAreaLength;
lightsHash.hemiLength=lightsStateHash.hemiLength;
lightsHash.shadowsLength=lightsStateHash.shadowsLength;

if(material.lights){

// wire up the material to this renderer's lighting state

uniforms.ambientLightColor.value=lights.state.ambient;
uniforms.lightProbe.value=lights.state.probe;
uniforms.directionalLights.value=lights.state.directional;
uniforms.spotLights.value=lights.state.spot;
uniforms.rectAreaLights.value=lights.state.rectArea;
uniforms.pointLights.value=lights.state.point;
uniforms.hemisphereLights.value=lights.state.hemi;

uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;
uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;
uniforms.spotShadowMap.value=lights.state.spotShadowMap;
uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;
uniforms.pointShadowMap.value=lights.state.pointShadowMap;
uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;
// TODO (abelnation): add area lights shadow info to uniforms

}

var progUniforms=materialProperties.program.getUniforms(),
uniformsList=
WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);

materialProperties.uniformsList=uniformsList;

}

function setProgram(camera,fog,material,object){

textures.resetTextureUnits();

var materialProperties=properties.get(material);
var lights=currentRenderState.state.lights;

var lightsHash=materialProperties.lightsHash;
var lightsStateHash=lights.state.hash;

if(_clippingEnabled){

if(_localClippingEnabled||camera!==_currentCamera){

var useCache=
camera===_currentCamera&&
material.id===_currentMaterialId;

// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
_clipping.setState(
material.clippingPlanes,material.clipIntersection,material.clipShadows,
camera,materialProperties,useCache);

}

}

if(material.needsUpdate===false){

if(materialProperties.program===undefined){

material.needsUpdate=true;

}else if(material.fog&&materialProperties.fog!==fog){

material.needsUpdate=true;

}else if(material.lights&&(lightsHash.stateID!==lightsStateHash.stateID||
lightsHash.directionalLength!==lightsStateHash.directionalLength||
lightsHash.pointLength!==lightsStateHash.pointLength||
lightsHash.spotLength!==lightsStateHash.spotLength||
lightsHash.rectAreaLength!==lightsStateHash.rectAreaLength||
lightsHash.hemiLength!==lightsStateHash.hemiLength||
lightsHash.shadowsLength!==lightsStateHash.shadowsLength)){

material.needsUpdate=true;

}else if(materialProperties.numClippingPlanes!==undefined&&(
materialProperties.numClippingPlanes!==_clipping.numPlanes||
materialProperties.numIntersection!==_clipping.numIntersection)){

material.needsUpdate=true;

}

}

if(material.needsUpdate){

initMaterial(material,fog,object);
material.needsUpdate=false;

}

var refreshProgram=false;
var refreshMaterial=false;
var refreshLights=false;

var program=materialProperties.program,
p_uniforms=program.getUniforms(),
m_uniforms=materialProperties.shader.uniforms;

if(state.useProgram(program.program)){

refreshProgram=true;
refreshMaterial=true;
refreshLights=true;

}

if(material.id!==_currentMaterialId){

_currentMaterialId=material.id;

refreshMaterial=true;

}

if(refreshProgram||_currentCamera!==camera){

p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);

if(capabilities.logarithmicDepthBuffer){

p_uniforms.setValue(_gl,'logDepthBufFC',
2.0/(Math.log(camera.far+1.0)/Math.LN2));

}

if(_currentCamera!==camera){

_currentCamera=camera;

// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:

refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done

}

// load material specific uniforms
// (shader material also gets them for the sake of genericity)

if(material.isShaderMaterial||
material.isMeshPhongMaterial||
material.isMeshStandardMaterial||
material.envMap){

var uCamPos=p_uniforms.map.cameraPosition;

if(uCamPos!==undefined){

uCamPos.setValue(_gl,
_vector3.setFromMatrixPosition(camera.matrixWorld));

}

}

if(material.isMeshPhongMaterial||
material.isMeshLambertMaterial||
material.isMeshBasicMaterial||
material.isMeshStandardMaterial||
material.isShaderMaterial||
material.skinning){

p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);

}

}

// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// not sure why, but otherwise weird things happen

if(material.skinning){

p_uniforms.setOptional(_gl,object,'bindMatrix');
p_uniforms.setOptional(_gl,object,'bindMatrixInverse');

var skeleton=object.skeleton;

if(skeleton){

var bones=skeleton.bones;

if(capabilities.floatVertexTextures){

if(skeleton.boneTexture===undefined){

// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
size=_Math.ceilPowerOfTwo(size);
size=Math.max(size,4);

var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
boneMatrices.set(skeleton.boneMatrices);// copy current values

var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);
boneTexture.needsUpdate=true;

skeleton.boneMatrices=boneMatrices;
skeleton.boneTexture=boneTexture;
skeleton.boneTextureSize=size;

}

p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);
p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);

}else{

p_uniforms.setOptional(_gl,skeleton,'boneMatrices');

}

}

}

if(refreshMaterial){

p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);
p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);

if(material.lights){

// the current material requires lighting info

// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required

markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);

}

// refresh uniforms common to several materials

if(fog&&material.fog){

refreshUniformsFog(m_uniforms,fog);

}

if(material.isMeshBasicMaterial){

refreshUniformsCommon(m_uniforms,material);

}else if(material.isMeshLambertMaterial){

refreshUniformsCommon(m_uniforms,material);
refreshUniformsLambert(m_uniforms,material);

}else if(material.isMeshPhongMaterial){

refreshUniformsCommon(m_uniforms,material);

if(material.isMeshToonMaterial){

refreshUniformsToon(m_uniforms,material);

}else{

refreshUniformsPhong(m_uniforms,material);

}

}else if(material.isMeshStandardMaterial){

refreshUniformsCommon(m_uniforms,material);

if(material.isMeshPhysicalMaterial){

refreshUniformsPhysical(m_uniforms,material);

}else{

refreshUniformsStandard(m_uniforms,material);

}

}else if(material.isMeshMatcapMaterial){

refreshUniformsCommon(m_uniforms,material);

refreshUniformsMatcap(m_uniforms,material);

}else if(material.isMeshDepthMaterial){

refreshUniformsCommon(m_uniforms,material);
refreshUniformsDepth(m_uniforms,material);

}else if(material.isMeshDistanceMaterial){

refreshUniformsCommon(m_uniforms,material);
refreshUniformsDistance(m_uniforms,material);

}else if(material.isMeshNormalMaterial){

refreshUniformsCommon(m_uniforms,material);
refreshUniformsNormal(m_uniforms,material);

}else if(material.isLineBasicMaterial){

refreshUniformsLine(m_uniforms,material);

if(material.isLineDashedMaterial){

refreshUniformsDash(m_uniforms,material);

}

}else if(material.isPointsMaterial){

refreshUniformsPoints(m_uniforms,material);

}else if(material.isSpriteMaterial){

refreshUniformsSprites(m_uniforms,material);

}else if(material.isShadowMaterial){

m_uniforms.color.value.copy(material.color);
m_uniforms.opacity.value=material.opacity;

}

// RectAreaLight Texture
// TODO (mrdoob): Find a nicer implementation

if(m_uniforms.ltc_1!==undefined)m_uniforms.ltc_1.value=UniformsLib.LTC_1;
if(m_uniforms.ltc_2!==undefined)m_uniforms.ltc_2.value=UniformsLib.LTC_2;

WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);

}

if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){

WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);
material.uniformsNeedUpdate=false;

}

if(material.isSpriteMaterial){

p_uniforms.setValue(_gl,'center',object.center);

}

// common matrices

p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);
p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);
p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);

return program;

}

// Uniforms (refresh uniforms objects)

function refreshUniformsCommon(uniforms,material){

uniforms.opacity.value=material.opacity;

if(material.color){

uniforms.diffuse.value.copy(material.color);

}

if(material.emissive){

uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

}

if(material.map){

uniforms.map.value=material.map;

}

if(material.alphaMap){

uniforms.alphaMap.value=material.alphaMap;

}

if(material.specularMap){

uniforms.specularMap.value=material.specularMap;

}

if(material.envMap){

uniforms.envMap.value=material.envMap;

// don't flip CubeTexture envMaps, flip everything else:
//  WebGLRenderTargetCube will be flipped for backwards compatibility
//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
uniforms.flipEnvMap.value=material.envMap.isCubeTexture?-1:1;

uniforms.reflectivity.value=material.reflectivity;
uniforms.refractionRatio.value=material.refractionRatio;

uniforms.maxMipLevel.value=properties.get(material.envMap).__maxMipLevel;

}

if(material.lightMap){

uniforms.lightMap.value=material.lightMap;
uniforms.lightMapIntensity.value=material.lightMapIntensity;

}

if(material.aoMap){

uniforms.aoMap.value=material.aoMap;
uniforms.aoMapIntensity.value=material.aoMapIntensity;

}

// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map

var uvScaleMap;

if(material.map){

uvScaleMap=material.map;

}else if(material.specularMap){

uvScaleMap=material.specularMap;

}else if(material.displacementMap){

uvScaleMap=material.displacementMap;

}else if(material.normalMap){

uvScaleMap=material.normalMap;

}else if(material.bumpMap){

uvScaleMap=material.bumpMap;

}else if(material.roughnessMap){

uvScaleMap=material.roughnessMap;

}else if(material.metalnessMap){

uvScaleMap=material.metalnessMap;

}else if(material.alphaMap){

uvScaleMap=material.alphaMap;

}else if(material.emissiveMap){

uvScaleMap=material.emissiveMap;

}

if(uvScaleMap!==undefined){

// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){

uvScaleMap=uvScaleMap.texture;

}

if(uvScaleMap.matrixAutoUpdate===true){

uvScaleMap.updateMatrix();

}

uniforms.uvTransform.value.copy(uvScaleMap.matrix);

}

}

function refreshUniformsLine(uniforms,material){

uniforms.diffuse.value.copy(material.color);
uniforms.opacity.value=material.opacity;

}

function refreshUniformsDash(uniforms,material){

uniforms.dashSize.value=material.dashSize;
uniforms.totalSize.value=material.dashSize+material.gapSize;
uniforms.scale.value=material.scale;

}

function refreshUniformsPoints(uniforms,material){

uniforms.diffuse.value.copy(material.color);
uniforms.opacity.value=material.opacity;
uniforms.size.value=material.size*_pixelRatio;
uniforms.scale.value=_height*0.5;

uniforms.map.value=material.map;

if(material.map!==null){

if(material.map.matrixAutoUpdate===true){

material.map.updateMatrix();

}

uniforms.uvTransform.value.copy(material.map.matrix);

}

}

function refreshUniformsSprites(uniforms,material){

uniforms.diffuse.value.copy(material.color);
uniforms.opacity.value=material.opacity;
uniforms.rotation.value=material.rotation;
uniforms.map.value=material.map;

if(material.map!==null){

if(material.map.matrixAutoUpdate===true){

material.map.updateMatrix();

}

uniforms.uvTransform.value.copy(material.map.matrix);

}

}

function refreshUniformsFog(uniforms,fog){

uniforms.fogColor.value.copy(fog.color);

if(fog.isFog){

uniforms.fogNear.value=fog.near;
uniforms.fogFar.value=fog.far;

}else if(fog.isFogExp2){

uniforms.fogDensity.value=fog.density;

}

}

function refreshUniformsLambert(uniforms,material){

if(material.emissiveMap){

uniforms.emissiveMap.value=material.emissiveMap;

}

}

function refreshUniformsPhong(uniforms,material){

uniforms.specular.value.copy(material.specular);
uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )

if(material.emissiveMap){

uniforms.emissiveMap.value=material.emissiveMap;

}

if(material.bumpMap){

uniforms.bumpMap.value=material.bumpMap;
uniforms.bumpScale.value=material.bumpScale;
if(material.side===BackSide)uniforms.bumpScale.value*=-1;

}

if(material.normalMap){

uniforms.normalMap.value=material.normalMap;
uniforms.normalScale.value.copy(material.normalScale);
if(material.side===BackSide)uniforms.normalScale.value.negate();

}

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

}

function refreshUniformsToon(uniforms,material){

refreshUniformsPhong(uniforms,material);

if(material.gradientMap){

uniforms.gradientMap.value=material.gradientMap;

}

}

function refreshUniformsStandard(uniforms,material){

uniforms.roughness.value=material.roughness;
uniforms.metalness.value=material.metalness;

if(material.roughnessMap){

uniforms.roughnessMap.value=material.roughnessMap;

}

if(material.metalnessMap){

uniforms.metalnessMap.value=material.metalnessMap;

}

if(material.emissiveMap){

uniforms.emissiveMap.value=material.emissiveMap;

}

if(material.bumpMap){

uniforms.bumpMap.value=material.bumpMap;
uniforms.bumpScale.value=material.bumpScale;
if(material.side===BackSide)uniforms.bumpScale.value*=-1;

}

if(material.normalMap){

uniforms.normalMap.value=material.normalMap;
uniforms.normalScale.value.copy(material.normalScale);
if(material.side===BackSide)uniforms.normalScale.value.negate();

}

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

if(material.envMap){

//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;

}

}

function refreshUniformsPhysical(uniforms,material){

refreshUniformsStandard(uniforms,material);

uniforms.reflectivity.value=material.reflectivity;// also part of uniforms common

uniforms.clearCoat.value=material.clearCoat;
uniforms.clearCoatRoughness.value=material.clearCoatRoughness;

}

function refreshUniformsMatcap(uniforms,material){

if(material.matcap){

uniforms.matcap.value=material.matcap;

}

if(material.bumpMap){

uniforms.bumpMap.value=material.bumpMap;
uniforms.bumpScale.value=material.bumpScale;
if(material.side===BackSide)uniforms.bumpScale.value*=-1;

}

if(material.normalMap){

uniforms.normalMap.value=material.normalMap;
uniforms.normalScale.value.copy(material.normalScale);
if(material.side===BackSide)uniforms.normalScale.value.negate();

}

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

}

function refreshUniformsDepth(uniforms,material){

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

}

function refreshUniformsDistance(uniforms,material){

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

uniforms.referencePosition.value.copy(material.referencePosition);
uniforms.nearDistance.value=material.nearDistance;
uniforms.farDistance.value=material.farDistance;

}

function refreshUniformsNormal(uniforms,material){

if(material.bumpMap){

uniforms.bumpMap.value=material.bumpMap;
uniforms.bumpScale.value=material.bumpScale;
if(material.side===BackSide)uniforms.bumpScale.value*=-1;

}

if(material.normalMap){

uniforms.normalMap.value=material.normalMap;
uniforms.normalScale.value.copy(material.normalScale);
if(material.side===BackSide)uniforms.normalScale.value.negate();

}

if(material.displacementMap){

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

}

}

// If uniforms are marked as clean, they don't need to be loaded to the GPU.

function markUniformsLightsNeedsUpdate(uniforms,value){

uniforms.ambientLightColor.needsUpdate=value;
uniforms.lightProbe.needsUpdate=value;

uniforms.directionalLights.needsUpdate=value;
uniforms.pointLights.needsUpdate=value;
uniforms.spotLights.needsUpdate=value;
uniforms.rectAreaLights.needsUpdate=value;
uniforms.hemisphereLights.needsUpdate=value;

}

//
this.setFramebuffer=function(value){

if(_framebuffer!==value)_gl.bindFramebuffer(36160,value);

_framebuffer=value;

};

this.getActiveCubeFace=function(){

return _currentActiveCubeFace;

};

this.getActiveMipMapLevel=function(){

return _currentActiveMipmapLevel;

};

this.getRenderTarget=function(){

return _currentRenderTarget;

};

this.setRenderTarget=function(renderTarget,activeCubeFace,activeMipMapLevel){

_currentRenderTarget=renderTarget;
_currentActiveCubeFace=activeCubeFace;
_currentActiveMipmapLevel=activeMipMapLevel;

if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){

textures.setupRenderTarget(renderTarget);

}

var framebuffer=_framebuffer;
var isCube=false;

if(renderTarget){

var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;

if(renderTarget.isWebGLRenderTargetCube){

framebuffer=__webglFramebuffer[activeCubeFace||0];
isCube=true;

}else if(renderTarget.isWebGLMultisampleRenderTarget){

framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;

}else{

framebuffer=__webglFramebuffer;

}

_currentViewport.copy(renderTarget.viewport);
_currentScissor.copy(renderTarget.scissor);
_currentScissorTest=renderTarget.scissorTest;

}else{

_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
_currentScissorTest=_scissorTest;

}

if(_currentFramebuffer!==framebuffer){

_gl.bindFramebuffer(36160,framebuffer);
_currentFramebuffer=framebuffer;

}

state.viewport(_currentViewport);
state.scissor(_currentScissor);
state.setScissorTest(_currentScissorTest);

if(isCube){

var textureProperties=properties.get(renderTarget.texture);
_gl.framebufferTexture2D(36160,36064,34069+(activeCubeFace||0),textureProperties.__webglTexture,activeMipMapLevel||0);

}

};

this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){

if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){

console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
return;

}

var framebuffer=properties.get(renderTarget).__webglFramebuffer;

if(renderTarget.isWebGLRenderTargetCube&&activeCubeFaceIndex!==undefined){

framebuffer=framebuffer[activeCubeFaceIndex];

}

if(framebuffer){

var restore=false;

if(framebuffer!==_currentFramebuffer){

_gl.bindFramebuffer(36160,framebuffer);

restore=true;

}

try{

var texture=renderTarget.texture;
var textureFormat=texture.format;
var textureType=texture.type;

if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){

console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
return;

}

if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// IE11, Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(capabilities.isWebGL2||extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!(textureType===HalfFloatType&&(capabilities.isWebGL2?extensions.get('EXT_color_buffer_float'):extensions.get('EXT_color_buffer_half_float')))){

console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
return;

}

if(_gl.checkFramebufferStatus(36160)===36053){

// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){

_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);

}

}else{

console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');

}

}finally{

if(restore){

_gl.bindFramebuffer(36160,_currentFramebuffer);

}

}

}

};

this.copyFramebufferToTexture=function(position,texture,level){

var width=texture.image.width;
var height=texture.image.height;
var glFormat=utils.convert(texture.format);

textures.setTexture2D(texture,0);

_gl.copyTexImage2D(3553,level||0,glFormat,position.x,position.y,width,height,0);

};

this.copyTextureToTexture=function(position,srcTexture,dstTexture,level){

var width=srcTexture.image.width;
var height=srcTexture.image.height;
var glFormat=utils.convert(dstTexture.format);
var glType=utils.convert(dstTexture.type);

textures.setTexture2D(dstTexture,0);

if(srcTexture.isDataTexture){

_gl.texSubImage2D(3553,level||0,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);

}else{

_gl.texSubImage2D(3553,level||0,position.x,position.y,glFormat,glType,srcTexture.image);

}

};

/*
	if ( typeof __THREE_DEVTOOLS__ !== undefined ) {
		__THREE_DEVTOOLS__.dispatchEvent( { type: 'renderer', value: this } );
	}
	*/

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2(color,density){

this.name='';

this.color=new Color(color);
this.density=density!==undefined?density:0.00025;

}

Object.assign(FogExp2.prototype,{

isFogExp2:true,

clone:function clone(){

return new FogExp2(this.color,this.density);

},

toJSON:function toJSON()/* meta */{

return{
type:'FogExp2',
color:this.color.getHex(),
density:this.density};


}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog(color,near,far){

this.name='';

this.color=new Color(color);

this.near=near!==undefined?near:1;
this.far=far!==undefined?far:1000;

}

Object.assign(Fog.prototype,{

isFog:true,

clone:function clone(){

return new Fog(this.color,this.near,this.far);

},

toJSON:function toJSON()/* meta */{

return{
type:'Fog',
color:this.color.getHex(),
near:this.near,
far:this.far};


}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene(){

Object3D.call(this);

this.type='Scene';

this.background=null;
this.fog=null;
this.overrideMaterial=null;

this.autoUpdate=true;// checked by the renderer

/*
	if ( typeof __THREE_DEVTOOLS__ !== undefined ) {
		__THREE_DEVTOOLS__.dispatchEvent( { type: 'scene', value: this } );
	}
	*/

}

Scene.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Scene,

isScene:true,

copy:function copy(source,recursive){

Object3D.prototype.copy.call(this,source,recursive);

if(source.background!==null)this.background=source.background.clone();
if(source.fog!==null)this.fog=source.fog.clone();
if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();

this.autoUpdate=source.autoUpdate;
this.matrixAutoUpdate=source.matrixAutoUpdate;

return this;

},

toJSON:function toJSON(meta){

var data=Object3D.prototype.toJSON.call(this,meta);

if(this.background!==null)data.object.background=this.background.toJSON(meta);
if(this.fog!==null)data.object.fog=this.fog.toJSON();

return data;

},

dispose:function dispose(){

this.dispatchEvent({type:'dispose'});

}});



/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer(array,stride){

this.array=array;
this.stride=stride;
this.count=array!==undefined?array.length/stride:0;

this.dynamic=false;
this.updateRange={offset:0,count:-1};

this.version=0;

}

Object.defineProperty(InterleavedBuffer.prototype,'needsUpdate',{

set:function set(value){

if(value===true)this.version++;

}});



Object.assign(InterleavedBuffer.prototype,{

isInterleavedBuffer:true,

onUploadCallback:function onUploadCallback(){},

setArray:function setArray(array){

if(Array.isArray(array)){

throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

}

this.count=array!==undefined?array.length/this.stride:0;
this.array=array;

return this;

},

setDynamic:function setDynamic(value){

this.dynamic=value;

return this;

},

copy:function copy(source){

this.array=new source.array.constructor(source.array);
this.count=source.count;
this.stride=source.stride;
this.dynamic=source.dynamic;

return this;

},

copyAt:function copyAt(index1,attribute,index2){

index1*=this.stride;
index2*=attribute.stride;

for(var i=0,l=this.stride;i<l;i++){

this.array[index1+i]=attribute.array[index2+i];

}

return this;

},

set:function set(value,offset){

if(offset===undefined)offset=0;

this.array.set(value,offset);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

onUpload:function onUpload(callback){

this.onUploadCallback=callback;

return this;

}});



/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){

this.data=interleavedBuffer;
this.itemSize=itemSize;
this.offset=offset;

this.normalized=normalized===true;

}

Object.defineProperties(InterleavedBufferAttribute.prototype,{

count:{

get:function get(){

return this.data.count;

}},



array:{

get:function get(){

return this.data.array;

}}});





Object.assign(InterleavedBufferAttribute.prototype,{

isInterleavedBufferAttribute:true,

setX:function setX(index,x){

this.data.array[index*this.data.stride+this.offset]=x;

return this;

},

setY:function setY(index,y){

this.data.array[index*this.data.stride+this.offset+1]=y;

return this;

},

setZ:function setZ(index,z){

this.data.array[index*this.data.stride+this.offset+2]=z;

return this;

},

setW:function setW(index,w){

this.data.array[index*this.data.stride+this.offset+3]=w;

return this;

},

getX:function getX(index){

return this.data.array[index*this.data.stride+this.offset];

},

getY:function getY(index){

return this.data.array[index*this.data.stride+this.offset+1];

},

getZ:function getZ(index){

return this.data.array[index*this.data.stride+this.offset+2];

},

getW:function getW(index){

return this.data.array[index*this.data.stride+this.offset+3];

},

setXY:function setXY(index,x,y){

index=index*this.data.stride+this.offset;

this.data.array[index+0]=x;
this.data.array[index+1]=y;

return this;

},

setXYZ:function setXYZ(index,x,y,z){

index=index*this.data.stride+this.offset;

this.data.array[index+0]=x;
this.data.array[index+1]=y;
this.data.array[index+2]=z;

return this;

},

setXYZW:function setXYZW(index,x,y,z,w){

index=index*this.data.stride+this.offset;

this.data.array[index+0]=x;
this.data.array[index+1]=y;
this.data.array[index+2]=z;
this.data.array[index+3]=w;

return this;

}});



/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters){

Material.call(this);

this.type='SpriteMaterial';

this.color=new Color(0xffffff);
this.map=null;

this.rotation=0;

this.sizeAttenuation=true;

this.lights=false;
this.transparent=true;

this.setValues(parameters);

}

SpriteMaterial.prototype=Object.create(Material.prototype);
SpriteMaterial.prototype.constructor=SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial=true;

SpriteMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);
this.map=source.map;

this.rotation=source.rotation;

this.sizeAttenuation=source.sizeAttenuation;

return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

var three_module_geometry;

function Sprite(material){

Object3D.call(this);

this.type='Sprite';

if(three_module_geometry===undefined){

three_module_geometry=new BufferGeometry();

var float32Array=new Float32Array([
-0.5,-0.5,0,0,0,
0.5,-0.5,0,1,0,
0.5,0.5,0,1,1,
-0.5,0.5,0,0,1]);


var interleavedBuffer=new InterleavedBuffer(float32Array,5);

three_module_geometry.setIndex([0,1,2,0,2,3]);
three_module_geometry.addAttribute('position',new InterleavedBufferAttribute(interleavedBuffer,3,0,false));
three_module_geometry.addAttribute('uv',new InterleavedBufferAttribute(interleavedBuffer,2,3,false));

}

this.geometry=three_module_geometry;
this.material=material!==undefined?material:new SpriteMaterial();

this.center=new Vector2(0.5,0.5);

}

Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Sprite,

isSprite:true,

raycast:function(){

var intersectPoint=new Vector3();
var worldScale=new Vector3();
var mvPosition=new Vector3();

var alignedPosition=new Vector2();
var rotatedPosition=new Vector2();
var viewWorldMatrix=new Matrix4();

var vA=new Vector3();
var vB=new Vector3();
var vC=new Vector3();

var uvA=new Vector2();
var uvB=new Vector2();
var uvC=new Vector2();

function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){

// compute position in camera space
alignedPosition.subVectors(vertexPosition,center).addScalar(0.5).multiply(scale);

// to check if rotation is not zero
if(sin!==undefined){

rotatedPosition.x=cos*alignedPosition.x-sin*alignedPosition.y;
rotatedPosition.y=sin*alignedPosition.x+cos*alignedPosition.y;

}else{

rotatedPosition.copy(alignedPosition);

}


vertexPosition.copy(mvPosition);
vertexPosition.x+=rotatedPosition.x;
vertexPosition.y+=rotatedPosition.y;

// transform to world space
vertexPosition.applyMatrix4(viewWorldMatrix);

}

return function raycast(raycaster,intersects){

worldScale.setFromMatrixScale(this.matrixWorld);
viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
mvPosition.setFromMatrixPosition(this.modelViewMatrix);

var rotation=this.material.rotation;
var sin,cos;
if(rotation!==0){

cos=Math.cos(rotation);
sin=Math.sin(rotation);

}

var center=this.center;

transformVertex(vA.set(-0.5,-0.5,0),mvPosition,center,worldScale,sin,cos);
transformVertex(vB.set(0.5,-0.5,0),mvPosition,center,worldScale,sin,cos);
transformVertex(vC.set(0.5,0.5,0),mvPosition,center,worldScale,sin,cos);

uvA.set(0,0);
uvB.set(1,0);
uvC.set(1,1);

// check first triangle
var intersect=raycaster.ray.intersectTriangle(vA,vB,vC,false,intersectPoint);

if(intersect===null){

// check second triangle
transformVertex(vB.set(-0.5,0.5,0),mvPosition,center,worldScale,sin,cos);
uvB.set(0,1);

intersect=raycaster.ray.intersectTriangle(vA,vC,vB,false,intersectPoint);
if(intersect===null){

return;

}

}

var distance=raycaster.ray.origin.distanceTo(intersectPoint);

if(distance<raycaster.near||distance>raycaster.far)return;

intersects.push({

distance:distance,
point:intersectPoint.clone(),
uv:Triangle.getUV(intersectPoint,vA,vB,vC,uvA,uvB,uvC,new Vector2()),
face:null,
object:this});



};

}(),

clone:function clone(){

return new this.constructor(this.material).copy(this);

},

copy:function copy(source){

Object3D.prototype.copy.call(this,source);

if(source.center!==undefined)this.center.copy(source.center);

return this;

}});




/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function LOD(){

Object3D.call(this);

this.type='LOD';

Object.defineProperties(this,{
levels:{
enumerable:true,
value:[]}});



}

LOD.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:LOD,

isLOD:true,

copy:function copy(source){

Object3D.prototype.copy.call(this,source,false);

var levels=source.levels;

for(var i=0,l=levels.length;i<l;i++){

var level=levels[i];

this.addLevel(level.object.clone(),level.distance);

}

return this;

},

addLevel:function addLevel(object,distance){

if(distance===undefined)distance=0;

distance=Math.abs(distance);

var levels=this.levels;

for(var l=0;l<levels.length;l++){

if(distance<levels[l].distance){

break;

}

}

levels.splice(l,0,{distance:distance,object:object});

this.add(object);

return this;

},

getObjectForDistance:function getObjectForDistance(distance){

var levels=this.levels;

for(var i=1,l=levels.length;i<l;i++){

if(distance<levels[i].distance){

break;

}

}

return levels[i-1].object;

},

raycast:function(){

var matrixPosition=new Vector3();

return function raycast(raycaster,intersects){

matrixPosition.setFromMatrixPosition(this.matrixWorld);

var distance=raycaster.ray.origin.distanceTo(matrixPosition);

this.getObjectForDistance(distance).raycast(raycaster,intersects);

};

}(),

update:function(){

var v1=new Vector3();
var v2=new Vector3();

return function update(camera){

var levels=this.levels;

if(levels.length>1){

v1.setFromMatrixPosition(camera.matrixWorld);
v2.setFromMatrixPosition(this.matrixWorld);

var distance=v1.distanceTo(v2);

levels[0].object.visible=true;

for(var i=1,l=levels.length;i<l;i++){

if(distance>=levels[i].distance){

levels[i-1].object.visible=false;
levels[i].object.visible=true;

}else{

break;

}

}

for(;i<l;i++){

levels[i].object.visible=false;

}

}

};

}(),

toJSON:function toJSON(meta){

var data=Object3D.prototype.toJSON.call(this,meta);

data.object.levels=[];

var levels=this.levels;

for(var i=0,l=levels.length;i<l;i++){

var level=levels[i];

data.object.levels.push({
object:level.object.uuid,
distance:level.distance});


}

return data;

}});



/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh(geometry,material){

if(geometry&&geometry.isGeometry){

console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');

}

Mesh.call(this,geometry,material);

this.type='SkinnedMesh';

this.bindMode='attached';
this.bindMatrix=new Matrix4();
this.bindMatrixInverse=new Matrix4();

}

SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{

constructor:SkinnedMesh,

isSkinnedMesh:true,

bind:function bind(skeleton,bindMatrix){

this.skeleton=skeleton;

if(bindMatrix===undefined){

this.updateMatrixWorld(true);

this.skeleton.calculateInverses();

bindMatrix=this.matrixWorld;

}

this.bindMatrix.copy(bindMatrix);
this.bindMatrixInverse.getInverse(bindMatrix);

},

pose:function pose(){

this.skeleton.pose();

},

normalizeSkinWeights:function normalizeSkinWeights(){

var vector=new Vector4();

var skinWeight=this.geometry.attributes.skinWeight;

for(var i=0,l=skinWeight.count;i<l;i++){

vector.x=skinWeight.getX(i);
vector.y=skinWeight.getY(i);
vector.z=skinWeight.getZ(i);
vector.w=skinWeight.getW(i);

var scale=1.0/vector.manhattanLength();

if(scale!==Infinity){

vector.multiplyScalar(scale);

}else{

vector.set(1,0,0,0);// do something reasonable

}

skinWeight.setXYZW(i,vector.x,vector.y,vector.z,vector.w);

}

},

updateMatrixWorld:function updateMatrixWorld(force){

Mesh.prototype.updateMatrixWorld.call(this,force);

if(this.bindMode==='attached'){

this.bindMatrixInverse.getInverse(this.matrixWorld);

}else if(this.bindMode==='detached'){

this.bindMatrixInverse.getInverse(this.bindMatrix);

}else{

console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);

}

},

clone:function clone(){

return new this.constructor(this.geometry,this.material).copy(this);

}});



/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

function Skeleton(bones,boneInverses){

// copy the bone array

bones=bones||[];

this.bones=bones.slice(0);
this.boneMatrices=new Float32Array(this.bones.length*16);

// use the supplied bone inverses or calculate the inverses

if(boneInverses===undefined){

this.calculateInverses();

}else{

if(this.bones.length===boneInverses.length){

this.boneInverses=boneInverses.slice(0);

}else{

console.warn('THREE.Skeleton boneInverses is the wrong length.');

this.boneInverses=[];

for(var i=0,il=this.bones.length;i<il;i++){

this.boneInverses.push(new Matrix4());

}

}

}

}

Object.assign(Skeleton.prototype,{

calculateInverses:function calculateInverses(){

this.boneInverses=[];

for(var i=0,il=this.bones.length;i<il;i++){

var inverse=new Matrix4();

if(this.bones[i]){

inverse.getInverse(this.bones[i].matrixWorld);

}

this.boneInverses.push(inverse);

}

},

pose:function pose(){

var bone,i,il;

// recover the bind-time world matrices

for(i=0,il=this.bones.length;i<il;i++){

bone=this.bones[i];

if(bone){

bone.matrixWorld.getInverse(this.boneInverses[i]);

}

}

// compute the local matrices, positions, rotations and scales

for(i=0,il=this.bones.length;i<il;i++){

bone=this.bones[i];

if(bone){

if(bone.parent&&bone.parent.isBone){

bone.matrix.getInverse(bone.parent.matrixWorld);
bone.matrix.multiply(bone.matrixWorld);

}else{

bone.matrix.copy(bone.matrixWorld);

}

bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);

}

}

},

update:function(){

var offsetMatrix=new Matrix4();
var identityMatrix=new Matrix4();

return function update(){

var bones=this.bones;
var boneInverses=this.boneInverses;
var boneMatrices=this.boneMatrices;
var boneTexture=this.boneTexture;

// flatten bone matrices to array

for(var i=0,il=bones.length;i<il;i++){

// compute the offset between the current and the original transform

var matrix=bones[i]?bones[i].matrixWorld:identityMatrix;

offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);
offsetMatrix.toArray(boneMatrices,i*16);

}

if(boneTexture!==undefined){

boneTexture.needsUpdate=true;

}

};

}(),

clone:function clone(){

return new Skeleton(this.bones,this.boneInverses);

},

getBoneByName:function getBoneByName(name){

for(var i=0,il=this.bones.length;i<il;i++){

var bone=this.bones[i];

if(bone.name===name){

return bone;

}

}

return undefined;

}});



/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone(){

Object3D.call(this);

this.type='Bone';

}

Bone.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Bone,

isBone:true});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters){

Material.call(this);

this.type='LineBasicMaterial';

this.color=new Color(0xffffff);

this.linewidth=1;
this.linecap='round';
this.linejoin='round';

this.lights=false;

this.setValues(parameters);

}

LineBasicMaterial.prototype=Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor=LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial=true;

LineBasicMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);

this.linewidth=source.linewidth;
this.linecap=source.linecap;
this.linejoin=source.linejoin;

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line(geometry,material,mode){

if(mode===1){

console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');

}

Object3D.call(this);

this.type='Line';

this.geometry=geometry!==undefined?geometry:new BufferGeometry();
this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});

}

Line.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Line,

isLine:true,

computeLineDistances:function(){

var start=new Vector3();
var end=new Vector3();

return function computeLineDistances(){

var geometry=this.geometry;

if(geometry.isBufferGeometry){

// we assume non-indexed geometry

if(geometry.index===null){

var positionAttribute=geometry.attributes.position;
var lineDistances=[0];

for(var i=1,l=positionAttribute.count;i<l;i++){

start.fromBufferAttribute(positionAttribute,i-1);
end.fromBufferAttribute(positionAttribute,i);

lineDistances[i]=lineDistances[i-1];
lineDistances[i]+=start.distanceTo(end);

}

geometry.addAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));

}else{

console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');

}

}else if(geometry.isGeometry){

var vertices=geometry.vertices;
var lineDistances=geometry.lineDistances;

lineDistances[0]=0;

for(var i=1,l=vertices.length;i<l;i++){

lineDistances[i]=lineDistances[i-1];
lineDistances[i]+=vertices[i-1].distanceTo(vertices[i]);

}

}

return this;

};

}(),

raycast:function(){

var inverseMatrix=new Matrix4();
var ray=new Ray();
var sphere=new Sphere();

return function raycast(raycaster,intersects){

var precision=raycaster.linePrecision;

var geometry=this.geometry;
var matrixWorld=this.matrixWorld;

// Checking boundingSphere distance to ray

if(geometry.boundingSphere===null)geometry.computeBoundingSphere();

sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);
sphere.radius+=precision;

if(raycaster.ray.intersectsSphere(sphere)===false)return;

//

inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

var localPrecision=precision/((this.scale.x+this.scale.y+this.scale.z)/3);
var localPrecisionSq=localPrecision*localPrecision;

var vStart=new Vector3();
var vEnd=new Vector3();
var interSegment=new Vector3();
var interRay=new Vector3();
var step=this&&this.isLineSegments?2:1;

if(geometry.isBufferGeometry){

var index=geometry.index;
var attributes=geometry.attributes;
var positions=attributes.position.array;

if(index!==null){

var indices=index.array;

for(var i=0,l=indices.length-1;i<l;i+=step){

var a=indices[i];
var b=indices[i+1];

vStart.fromArray(positions,a*3);
vEnd.fromArray(positions,b*3);

var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);

if(distSq>localPrecisionSq)continue;

interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation

var distance=raycaster.ray.origin.distanceTo(interRay);

if(distance<raycaster.near||distance>raycaster.far)continue;

intersects.push({

distance:distance,
// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),
index:i,
face:null,
faceIndex:null,
object:this});



}

}else{

for(var i=0,l=positions.length/3-1;i<l;i+=step){

vStart.fromArray(positions,3*i);
vEnd.fromArray(positions,3*i+3);

var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);

if(distSq>localPrecisionSq)continue;

interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation

var distance=raycaster.ray.origin.distanceTo(interRay);

if(distance<raycaster.near||distance>raycaster.far)continue;

intersects.push({

distance:distance,
// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),
index:i,
face:null,
faceIndex:null,
object:this});



}

}

}else if(geometry.isGeometry){

var vertices=geometry.vertices;
var nbVertices=vertices.length;

for(var i=0;i<nbVertices-1;i+=step){

var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);

if(distSq>localPrecisionSq)continue;

interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation

var distance=raycaster.ray.origin.distanceTo(interRay);

if(distance<raycaster.near||distance>raycaster.far)continue;

intersects.push({

distance:distance,
// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),
index:i,
face:null,
faceIndex:null,
object:this});



}

}

};

}(),

clone:function clone(){

return new this.constructor(this.geometry,this.material).copy(this);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments(geometry,material){

Line.call(this,geometry,material);

this.type='LineSegments';

}

LineSegments.prototype=Object.assign(Object.create(Line.prototype),{

constructor:LineSegments,

isLineSegments:true,

computeLineDistances:function(){

var start=new Vector3();
var end=new Vector3();

return function computeLineDistances(){

var geometry=this.geometry;

if(geometry.isBufferGeometry){

// we assume non-indexed geometry

if(geometry.index===null){

var positionAttribute=geometry.attributes.position;
var lineDistances=[];

for(var i=0,l=positionAttribute.count;i<l;i+=2){

start.fromBufferAttribute(positionAttribute,i);
end.fromBufferAttribute(positionAttribute,i+1);

lineDistances[i]=i===0?0:lineDistances[i-1];
lineDistances[i+1]=lineDistances[i]+start.distanceTo(end);

}

geometry.addAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));

}else{

console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');

}

}else if(geometry.isGeometry){

var vertices=geometry.vertices;
var lineDistances=geometry.lineDistances;

for(var i=0,l=vertices.length;i<l;i+=2){

start.copy(vertices[i]);
end.copy(vertices[i+1]);

lineDistances[i]=i===0?0:lineDistances[i-1];
lineDistances[i+1]=lineDistances[i]+start.distanceTo(end);

}

}

return this;

};

}()});



/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop(geometry,material){

Line.call(this,geometry,material);

this.type='LineLoop';

}

LineLoop.prototype=Object.assign(Object.create(Line.prototype),{

constructor:LineLoop,

isLineLoop:true});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters){

Material.call(this);

this.type='PointsMaterial';

this.color=new Color(0xffffff);

this.map=null;

this.size=1;
this.sizeAttenuation=true;

this.morphTargets=false;

this.lights=false;

this.setValues(parameters);

}

PointsMaterial.prototype=Object.create(Material.prototype);
PointsMaterial.prototype.constructor=PointsMaterial;

PointsMaterial.prototype.isPointsMaterial=true;

PointsMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);

this.map=source.map;

this.size=source.size;
this.sizeAttenuation=source.sizeAttenuation;

this.morphTargets=source.morphTargets;

return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points(geometry,material){

Object3D.call(this);

this.type='Points';

this.geometry=geometry!==undefined?geometry:new BufferGeometry();
this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});

}

Points.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Points,

isPoints:true,

raycast:function(){

var inverseMatrix=new Matrix4();
var ray=new Ray();
var sphere=new Sphere();

return function raycast(raycaster,intersects){

var object=this;
var geometry=this.geometry;
var matrixWorld=this.matrixWorld;
var threshold=raycaster.params.Points.threshold;

// Checking boundingSphere distance to ray

if(geometry.boundingSphere===null)geometry.computeBoundingSphere();

sphere.copy(geometry.boundingSphere);
sphere.applyMatrix4(matrixWorld);
sphere.radius+=threshold;

if(raycaster.ray.intersectsSphere(sphere)===false)return;

//

inverseMatrix.getInverse(matrixWorld);
ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);
var localThresholdSq=localThreshold*localThreshold;
var position=new Vector3();
var intersectPoint=new Vector3();

function testPoint(point,index){

var rayPointDistanceSq=ray.distanceSqToPoint(point);

if(rayPointDistanceSq<localThresholdSq){

ray.closestPointToPoint(point,intersectPoint);
intersectPoint.applyMatrix4(matrixWorld);

var distance=raycaster.ray.origin.distanceTo(intersectPoint);

if(distance<raycaster.near||distance>raycaster.far)return;

intersects.push({

distance:distance,
distanceToRay:Math.sqrt(rayPointDistanceSq),
point:intersectPoint.clone(),
index:index,
face:null,
object:object});



}

}

if(geometry.isBufferGeometry){

var index=geometry.index;
var attributes=geometry.attributes;
var positions=attributes.position.array;

if(index!==null){

var indices=index.array;

for(var i=0,il=indices.length;i<il;i++){

var a=indices[i];

position.fromArray(positions,a*3);

testPoint(position,a);

}

}else{

for(var i=0,l=positions.length/3;i<l;i++){

position.fromArray(positions,i*3);

testPoint(position,i);

}

}

}else{

var vertices=geometry.vertices;

for(var i=0,l=vertices.length;i<l;i++){

testPoint(vertices[i],i);

}

}

};

}(),

clone:function clone(){

return new this.constructor(this.geometry,this.material).copy(this);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){

Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);

this.format=format!==undefined?format:RGBFormat;

this.minFilter=minFilter!==undefined?minFilter:LinearFilter;
this.magFilter=magFilter!==undefined?magFilter:LinearFilter;

this.generateMipmaps=false;

}

VideoTexture.prototype=Object.assign(Object.create(Texture.prototype),{

constructor:VideoTexture,

isVideoTexture:true,

update:function update(){

var video=this.image;

if(video.readyState>=video.HAVE_CURRENT_DATA){

this.needsUpdate=true;

}

}});



/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){

Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);

this.image={width:width,height:height};
this.mipmaps=mipmaps;

// no flipping for cube textures
// (also flipping doesn't work for compressed textures )

this.flipY=false;

// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files

this.generateMipmaps=false;

}

CompressedTexture.prototype=Object.create(Texture.prototype);
CompressedTexture.prototype.constructor=CompressedTexture;

CompressedTexture.prototype.isCompressedTexture=true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){

Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);

this.needsUpdate=true;

}

CanvasTexture.prototype=Object.create(Texture.prototype);
CanvasTexture.prototype.constructor=CanvasTexture;
CanvasTexture.prototype.isCanvasTexture=true;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){

format=format!==undefined?format:DepthFormat;

if(format!==DepthFormat&&format!==DepthStencilFormat){

throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');

}

if(type===undefined&&format===DepthFormat)type=UnsignedShortType;
if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;

Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);

this.image={width:width,height:height};

this.magFilter=magFilter!==undefined?magFilter:NearestFilter;
this.minFilter=minFilter!==undefined?minFilter:NearestFilter;

this.flipY=false;
this.generateMipmaps=false;

}

DepthTexture.prototype=Object.create(Texture.prototype);
DepthTexture.prototype.constructor=DepthTexture;
DepthTexture.prototype.isDepthTexture=true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry(geometry){

BufferGeometry.call(this);

this.type='WireframeGeometry';

// buffer

var vertices=[];

// helper variables

var i,j,l,o,ol;
var edge=[0,0],edges={},e,edge1,edge2;
var key,keys=['a','b','c'];
var vertex;

// different logic for Geometry and BufferGeometry

if(geometry&&geometry.isGeometry){

// create a data structure that contains all edges without duplicates

var faces=geometry.faces;

for(i=0,l=faces.length;i<l;i++){

var face=faces[i];

for(j=0;j<3;j++){

edge1=face[keys[j]];
edge2=face[keys[(j+1)%3]];
edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);

key=edge[0]+','+edge[1];

if(edges[key]===undefined){

edges[key]={index1:edge[0],index2:edge[1]};

}

}

}

// generate vertices

for(key in edges){

e=edges[key];

vertex=geometry.vertices[e.index1];
vertices.push(vertex.x,vertex.y,vertex.z);

vertex=geometry.vertices[e.index2];
vertices.push(vertex.x,vertex.y,vertex.z);

}

}else if(geometry&&geometry.isBufferGeometry){

var position,indices,groups;
var group,start,count;
var index1,index2;

vertex=new Vector3();

if(geometry.index!==null){

// indexed BufferGeometry

position=geometry.attributes.position;
indices=geometry.index;
groups=geometry.groups;

if(groups.length===0){

groups=[{start:0,count:indices.count,materialIndex:0}];

}

// create a data structure that contains all eges without duplicates

for(o=0,ol=groups.length;o<ol;++o){

group=groups[o];

start=group.start;
count=group.count;

for(i=start,l=start+count;i<l;i+=3){

for(j=0;j<3;j++){

edge1=indices.getX(i+j);
edge2=indices.getX(i+(j+1)%3);
edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);

key=edge[0]+','+edge[1];

if(edges[key]===undefined){

edges[key]={index1:edge[0],index2:edge[1]};

}

}

}

}

// generate vertices

for(key in edges){

e=edges[key];

vertex.fromBufferAttribute(position,e.index1);
vertices.push(vertex.x,vertex.y,vertex.z);

vertex.fromBufferAttribute(position,e.index2);
vertices.push(vertex.x,vertex.y,vertex.z);

}

}else{

// non-indexed BufferGeometry

position=geometry.attributes.position;

for(i=0,l=position.count/3;i<l;i++){

for(j=0;j<3;j++){

// three edges per triangle, an edge is represented as (index1, index2)
// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

index1=3*i+j;
vertex.fromBufferAttribute(position,index1);
vertices.push(vertex.x,vertex.y,vertex.z);

index2=3*i+(j+1)%3;
vertex.fromBufferAttribute(position,index2);
vertices.push(vertex.x,vertex.y,vertex.z);

}

}

}

}

// build geometry

this.addAttribute('position',new Float32BufferAttribute(vertices,3));

}

WireframeGeometry.prototype=Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor=WireframeGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

// ParametricGeometry

function ParametricGeometry(func,slices,stacks){

Geometry.call(this);

this.type='ParametricGeometry';

this.parameters={
func:func,
slices:slices,
stacks:stacks};


this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));
this.mergeVertices();

}

ParametricGeometry.prototype=Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor=ParametricGeometry;

// ParametricBufferGeometry

function ParametricBufferGeometry(func,slices,stacks){

BufferGeometry.call(this);

this.type='ParametricBufferGeometry';

this.parameters={
func:func,
slices:slices,
stacks:stacks};


// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

var EPS=0.00001;

var normal=new Vector3();

var p0=new Vector3(),p1=new Vector3();
var pu=new Vector3(),pv=new Vector3();

var i,j;

if(func.length<3){

console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');

}

// generate vertices, normals and uvs

var sliceCount=slices+1;

for(i=0;i<=stacks;i++){

var v=i/stacks;

for(j=0;j<=slices;j++){

var u=j/slices;

// vertex

func(u,v,p0);
vertices.push(p0.x,p0.y,p0.z);

// normal

// approximate tangent vectors via finite differences

if(u-EPS>=0){

func(u-EPS,v,p1);
pu.subVectors(p0,p1);

}else{

func(u+EPS,v,p1);
pu.subVectors(p1,p0);

}

if(v-EPS>=0){

func(u,v-EPS,p1);
pv.subVectors(p0,p1);

}else{

func(u,v+EPS,p1);
pv.subVectors(p1,p0);

}

// cross product of tangent vectors returns surface normal

normal.crossVectors(pu,pv).normalize();
normals.push(normal.x,normal.y,normal.z);

// uv

uvs.push(u,v);

}

}

// generate indices

for(i=0;i<stacks;i++){

for(j=0;j<slices;j++){

var a=i*sliceCount+j;
var b=i*sliceCount+j+1;
var c=(i+1)*sliceCount+j+1;
var d=(i+1)*sliceCount+j;

// faces one and two

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

// PolyhedronGeometry

function PolyhedronGeometry(vertices,indices,radius,detail){

Geometry.call(this);

this.type='PolyhedronGeometry';

this.parameters={
vertices:vertices,
indices:indices,
radius:radius,
detail:detail};


this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));
this.mergeVertices();

}

PolyhedronGeometry.prototype=Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;

// PolyhedronBufferGeometry

function PolyhedronBufferGeometry(vertices,indices,radius,detail){

BufferGeometry.call(this);

this.type='PolyhedronBufferGeometry';

this.parameters={
vertices:vertices,
indices:indices,
radius:radius,
detail:detail};


radius=radius||1;
detail=detail||0;

// default buffer data

var vertexBuffer=[];
var uvBuffer=[];

// the subdivision creates the vertex buffer data

subdivide(detail);

// all vertices should lie on a conceptual sphere with a given radius

appplyRadius(radius);

// finally, create the uv data

generateUVs();

// build non-indexed geometry

this.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));
this.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));
this.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));

if(detail===0){

this.computeVertexNormals();// flat normals

}else{

this.normalizeNormals();// smooth normals

}

// helper functions

function subdivide(detail){

var a=new Vector3();
var b=new Vector3();
var c=new Vector3();

// iterate over all faces and apply a subdivison with the given detail value

for(var i=0;i<indices.length;i+=3){

// get the vertices of the face

getVertexByIndex(indices[i+0],a);
getVertexByIndex(indices[i+1],b);
getVertexByIndex(indices[i+2],c);

// perform subdivision

subdivideFace(a,b,c,detail);

}

}

function subdivideFace(a,b,c,detail){

var cols=Math.pow(2,detail);

// we use this multidimensional array as a data structure for creating the subdivision

var v=[];

var i,j;

// construct all of the vertices for this subdivision

for(i=0;i<=cols;i++){

v[i]=[];

var aj=a.clone().lerp(c,i/cols);
var bj=b.clone().lerp(c,i/cols);

var rows=cols-i;

for(j=0;j<=rows;j++){

if(j===0&&i===cols){

v[i][j]=aj;

}else{

v[i][j]=aj.clone().lerp(bj,j/rows);

}

}

}

// construct all of the faces

for(i=0;i<cols;i++){

for(j=0;j<2*(cols-i)-1;j++){

var k=Math.floor(j/2);

if(j%2===0){

pushVertex(v[i][k+1]);
pushVertex(v[i+1][k]);
pushVertex(v[i][k]);

}else{

pushVertex(v[i][k+1]);
pushVertex(v[i+1][k+1]);
pushVertex(v[i+1][k]);

}

}

}

}

function appplyRadius(radius){

var vertex=new Vector3();

// iterate over the entire buffer and apply the radius to each vertex

for(var i=0;i<vertexBuffer.length;i+=3){

vertex.x=vertexBuffer[i+0];
vertex.y=vertexBuffer[i+1];
vertex.z=vertexBuffer[i+2];

vertex.normalize().multiplyScalar(radius);

vertexBuffer[i+0]=vertex.x;
vertexBuffer[i+1]=vertex.y;
vertexBuffer[i+2]=vertex.z;

}

}

function generateUVs(){

var vertex=new Vector3();

for(var i=0;i<vertexBuffer.length;i+=3){

vertex.x=vertexBuffer[i+0];
vertex.y=vertexBuffer[i+1];
vertex.z=vertexBuffer[i+2];

var u=azimuth(vertex)/2/Math.PI+0.5;
var v=inclination(vertex)/Math.PI+0.5;
uvBuffer.push(u,1-v);

}

correctUVs();

correctSeam();

}

function correctSeam(){

// handle case when face straddles the seam, see #3269

for(var i=0;i<uvBuffer.length;i+=6){

// uv data of a single face

var x0=uvBuffer[i+0];
var x1=uvBuffer[i+2];
var x2=uvBuffer[i+4];

var max=Math.max(x0,x1,x2);
var min=Math.min(x0,x1,x2);

// 0.9 is somewhat arbitrary

if(max>0.9&&min<0.1){

if(x0<0.2)uvBuffer[i+0]+=1;
if(x1<0.2)uvBuffer[i+2]+=1;
if(x2<0.2)uvBuffer[i+4]+=1;

}

}

}

function pushVertex(vertex){

vertexBuffer.push(vertex.x,vertex.y,vertex.z);

}

function getVertexByIndex(index,vertex){

var stride=index*3;

vertex.x=vertices[stride+0];
vertex.y=vertices[stride+1];
vertex.z=vertices[stride+2];

}

function correctUVs(){

var a=new Vector3();
var b=new Vector3();
var c=new Vector3();

var centroid=new Vector3();

var uvA=new Vector2();
var uvB=new Vector2();
var uvC=new Vector2();

for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){

a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);
b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);
c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);

uvA.set(uvBuffer[j+0],uvBuffer[j+1]);
uvB.set(uvBuffer[j+2],uvBuffer[j+3]);
uvC.set(uvBuffer[j+4],uvBuffer[j+5]);

centroid.copy(a).add(b).add(c).divideScalar(3);

var azi=azimuth(centroid);

correctUV(uvA,j+0,a,azi);
correctUV(uvB,j+2,b,azi);
correctUV(uvC,j+4,c,azi);

}

}

function correctUV(uv,stride,vector,azimuth){

if(azimuth<0&&uv.x===1){

uvBuffer[stride]=uv.x-1;

}

if(vector.x===0&&vector.z===0){

uvBuffer[stride]=azimuth/2/Math.PI+0.5;

}

}

// Angle around the Y axis, counter-clockwise when looking from above.

function azimuth(vector){

return Math.atan2(vector.z,-vector.x);

}


// Angle above the XZ plane.

function inclination(vector){

return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));

}

}

PolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// TetrahedronGeometry

function TetrahedronGeometry(radius,detail){

Geometry.call(this);

this.type='TetrahedronGeometry';

this.parameters={
radius:radius,
detail:detail};


this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));
this.mergeVertices();

}

TetrahedronGeometry.prototype=Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;

// TetrahedronBufferGeometry

function TetrahedronBufferGeometry(radius,detail){

var vertices=[
1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];


var indices=[
2,1,0,0,3,2,1,3,0,2,3,1];


PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);

this.type='TetrahedronBufferGeometry';

this.parameters={
radius:radius,
detail:detail};


}

TetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// OctahedronGeometry

function OctahedronGeometry(radius,detail){

Geometry.call(this);

this.type='OctahedronGeometry';

this.parameters={
radius:radius,
detail:detail};


this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));
this.mergeVertices();

}

OctahedronGeometry.prototype=Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor=OctahedronGeometry;

// OctahedronBufferGeometry

function OctahedronBufferGeometry(radius,detail){

var vertices=[
1,0,0,-1,0,0,0,1,0,
0,-1,0,0,0,1,0,0,-1];


var indices=[
0,2,4,0,4,3,0,3,5,
0,5,2,1,2,5,1,5,3,
1,3,4,1,4,2];


PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);

this.type='OctahedronBufferGeometry';

this.parameters={
radius:radius,
detail:detail};


}

OctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */

// IcosahedronGeometry

function IcosahedronGeometry(radius,detail){

Geometry.call(this);

this.type='IcosahedronGeometry';

this.parameters={
radius:radius,
detail:detail};


this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));
this.mergeVertices();

}

IcosahedronGeometry.prototype=Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;

// IcosahedronBufferGeometry

function IcosahedronBufferGeometry(radius,detail){

var t=(1+Math.sqrt(5))/2;

var vertices=[
-1,t,0,1,t,0,-1,-t,0,1,-t,0,
0,-1,t,0,1,t,0,-1,-t,0,1,-t,
t,0,-1,t,0,1,-t,0,-1,-t,0,1];


var indices=[
0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,
1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,
3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,
4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];


PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);

this.type='IcosahedronBufferGeometry';

this.parameters={
radius:radius,
detail:detail};


}

IcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// DodecahedronGeometry

function DodecahedronGeometry(radius,detail){

Geometry.call(this);

this.type='DodecahedronGeometry';

this.parameters={
radius:radius,
detail:detail};


this.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));
this.mergeVertices();

}

DodecahedronGeometry.prototype=Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor=DodecahedronGeometry;

// DodecahedronBufferGeometry

function DodecahedronBufferGeometry(radius,detail){

var t=(1+Math.sqrt(5))/2;
var r=1/t;

var vertices=[

// (±1, ±1, ±1)
-1,-1,-1,-1,-1,1,
-1,1,-1,-1,1,1,
1,-1,-1,1,-1,1,
1,1,-1,1,1,1,

// (0, ±1/φ, ±φ)
0,-r,-t,0,-r,t,
0,r,-t,0,r,t,

// (±1/φ, ±φ, 0)
-r,-t,0,-r,t,0,
r,-t,0,r,t,0,

// (±φ, 0, ±1/φ)
-t,0,-r,t,0,-r,
-t,0,r,t,0,r];


var indices=[
3,11,7,3,7,15,3,15,13,
7,19,17,7,17,6,7,6,15,
17,4,8,17,8,10,17,10,6,
8,0,16,8,16,2,8,2,10,
0,12,1,0,1,18,0,18,16,
6,10,2,6,2,13,6,13,15,
2,16,18,2,18,3,2,3,13,
18,1,9,18,9,11,18,11,3,
4,14,12,4,12,0,4,0,8,
11,9,5,11,5,19,11,19,7,
19,5,14,19,14,4,19,4,17,
1,12,14,1,14,5,1,5,9];


PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);

this.type='DodecahedronBufferGeometry';

this.parameters={
radius:radius,
detail:detail};


}

DodecahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */

// TubeGeometry

function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){

Geometry.call(this);

this.type='TubeGeometry';

this.parameters={
path:path,
tubularSegments:tubularSegments,
radius:radius,
radialSegments:radialSegments,
closed:closed};


if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');

var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);

// expose internals

this.tangents=bufferGeometry.tangents;
this.normals=bufferGeometry.normals;
this.binormals=bufferGeometry.binormals;

// create geometry

this.fromBufferGeometry(bufferGeometry);
this.mergeVertices();

}

TubeGeometry.prototype=Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor=TubeGeometry;

// TubeBufferGeometry

function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){

BufferGeometry.call(this);

this.type='TubeBufferGeometry';

this.parameters={
path:path,
tubularSegments:tubularSegments,
radius:radius,
radialSegments:radialSegments,
closed:closed};


tubularSegments=tubularSegments||64;
radius=radius||1;
radialSegments=radialSegments||8;
closed=closed||false;

var frames=path.computeFrenetFrames(tubularSegments,closed);

// expose internals

this.tangents=frames.tangents;
this.normals=frames.normals;
this.binormals=frames.binormals;

// helper variables

var vertex=new Vector3();
var normal=new Vector3();
var uv=new Vector2();
var P=new Vector3();

var i,j;

// buffer

var vertices=[];
var normals=[];
var uvs=[];
var indices=[];

// create buffer data

generateBufferData();

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

// functions

function generateBufferData(){

for(i=0;i<tubularSegments;i++){

generateSegment(i);

}

// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

generateSegment(closed===false?tubularSegments:0);

// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries

generateUVs();

// finally create faces

generateIndices();

}

function generateSegment(i){

// we use getPointAt to sample evenly distributed points from the given path

P=path.getPointAt(i/tubularSegments,P);

// retrieve corresponding normal and binormal

var N=frames.normals[i];
var B=frames.binormals[i];

// generate normals and vertices for the current segment

for(j=0;j<=radialSegments;j++){

var v=j/radialSegments*Math.PI*2;

var sin=Math.sin(v);
var cos=-Math.cos(v);

// normal

normal.x=cos*N.x+sin*B.x;
normal.y=cos*N.y+sin*B.y;
normal.z=cos*N.z+sin*B.z;
normal.normalize();

normals.push(normal.x,normal.y,normal.z);

// vertex

vertex.x=P.x+radius*normal.x;
vertex.y=P.y+radius*normal.y;
vertex.z=P.z+radius*normal.z;

vertices.push(vertex.x,vertex.y,vertex.z);

}

}

function generateIndices(){

for(j=1;j<=tubularSegments;j++){

for(i=1;i<=radialSegments;i++){

var a=(radialSegments+1)*(j-1)+(i-1);
var b=(radialSegments+1)*j+(i-1);
var c=(radialSegments+1)*j+i;
var d=(radialSegments+1)*(j-1)+i;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

}

function generateUVs(){

for(i=0;i<=tubularSegments;i++){

for(j=0;j<=radialSegments;j++){

uv.x=i/tubularSegments;
uv.y=j/radialSegments;

uvs.push(uv.x,uv.y);

}

}

}

}

TubeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON=function(){

var data=BufferGeometry.prototype.toJSON.call(this);

data.path=this.parameters.path.toJSON();

return data;

};

/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */

// TorusKnotGeometry

function TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){

Geometry.call(this);

this.type='TorusKnotGeometry';

this.parameters={
radius:radius,
tube:tube,
tubularSegments:tubularSegments,
radialSegments:radialSegments,
p:p,
q:q};


if(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');

this.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));
this.mergeVertices();

}

TorusKnotGeometry.prototype=Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor=TorusKnotGeometry;

// TorusKnotBufferGeometry

function TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){

BufferGeometry.call(this);

this.type='TorusKnotBufferGeometry';

this.parameters={
radius:radius,
tube:tube,
tubularSegments:tubularSegments,
radialSegments:radialSegments,
p:p,
q:q};


radius=radius||1;
tube=tube||0.4;
tubularSegments=Math.floor(tubularSegments)||64;
radialSegments=Math.floor(radialSegments)||8;
p=p||2;
q=q||3;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var i,j;

var vertex=new Vector3();
var normal=new Vector3();

var P1=new Vector3();
var P2=new Vector3();

var B=new Vector3();
var T=new Vector3();
var N=new Vector3();

// generate vertices, normals and uvs

for(i=0;i<=tubularSegments;++i){

// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

var u=i/tubularSegments*p*Math.PI*2;

// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

calculatePositionOnCurve(u,p,q,radius,P1);
calculatePositionOnCurve(u+0.01,p,q,radius,P2);

// calculate orthonormal basis

T.subVectors(P2,P1);
N.addVectors(P2,P1);
B.crossVectors(T,N);
N.crossVectors(B,T);

// normalize B, N. T can be ignored, we don't use it

B.normalize();
N.normalize();

for(j=0;j<=radialSegments;++j){

// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

var v=j/radialSegments*Math.PI*2;
var cx=-tube*Math.cos(v);
var cy=tube*Math.sin(v);

// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

vertex.x=P1.x+(cx*N.x+cy*B.x);
vertex.y=P1.y+(cx*N.y+cy*B.y);
vertex.z=P1.z+(cx*N.z+cy*B.z);

vertices.push(vertex.x,vertex.y,vertex.z);

// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

normal.subVectors(vertex,P1).normalize();

normals.push(normal.x,normal.y,normal.z);

// uv

uvs.push(i/tubularSegments);
uvs.push(j/radialSegments);

}

}

// generate indices

for(j=1;j<=tubularSegments;j++){

for(i=1;i<=radialSegments;i++){

// indices

var a=(radialSegments+1)*(j-1)+(i-1);
var b=(radialSegments+1)*j+(i-1);
var c=(radialSegments+1)*j+i;
var d=(radialSegments+1)*(j-1)+i;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

// this function calculates the current position on the torus curve

function calculatePositionOnCurve(u,p,q,radius,position){

var cu=Math.cos(u);
var su=Math.sin(u);
var quOverP=q/p*u;
var cs=Math.cos(quOverP);

position.x=radius*(2+cs)*0.5*cu;
position.y=radius*(2+cs)*su*0.5;
position.z=radius*Math.sin(quOverP)*0.5;

}

}

TorusKnotBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// TorusGeometry

function TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){

Geometry.call(this);

this.type='TorusGeometry';

this.parameters={
radius:radius,
tube:tube,
radialSegments:radialSegments,
tubularSegments:tubularSegments,
arc:arc};


this.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));
this.mergeVertices();

}

TorusGeometry.prototype=Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor=TorusGeometry;

// TorusBufferGeometry

function TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){

BufferGeometry.call(this);

this.type='TorusBufferGeometry';

this.parameters={
radius:radius,
tube:tube,
radialSegments:radialSegments,
tubularSegments:tubularSegments,
arc:arc};


radius=radius||1;
tube=tube||0.4;
radialSegments=Math.floor(radialSegments)||8;
tubularSegments=Math.floor(tubularSegments)||6;
arc=arc||Math.PI*2;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var center=new Vector3();
var vertex=new Vector3();
var normal=new Vector3();

var j,i;

// generate vertices, normals and uvs

for(j=0;j<=radialSegments;j++){

for(i=0;i<=tubularSegments;i++){

var u=i/tubularSegments*arc;
var v=j/radialSegments*Math.PI*2;

// vertex

vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);
vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);
vertex.z=tube*Math.sin(v);

vertices.push(vertex.x,vertex.y,vertex.z);

// normal

center.x=radius*Math.cos(u);
center.y=radius*Math.sin(u);
normal.subVectors(vertex,center).normalize();

normals.push(normal.x,normal.y,normal.z);

// uv

uvs.push(i/tubularSegments);
uvs.push(j/radialSegments);

}

}

// generate indices

for(j=1;j<=radialSegments;j++){

for(i=1;i<=tubularSegments;i++){

// indices

var a=(tubularSegments+1)*j+i-1;
var b=(tubularSegments+1)*(j-1)+i-1;
var c=(tubularSegments+1)*(j-1)+i;
var d=(tubularSegments+1)*j+i;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

TorusBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.2)
 */

var Earcut={

triangulate:function triangulate(data,holeIndices,dim){

dim=dim||2;

var hasHoles=holeIndices&&holeIndices.length,
outerLen=hasHoles?holeIndices[0]*dim:data.length,
outerNode=linkedList(data,0,outerLen,dim,true),
triangles=[];

if(!outerNode)return triangles;

var minX,minY,maxX,maxY,x,y,invSize;

if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);

// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

if(data.length>80*dim){

minX=maxX=data[0];
minY=maxY=data[1];

for(var i=dim;i<outerLen;i+=dim){

x=data[i];
y=data[i+1];
if(x<minX)minX=x;
if(y<minY)minY=y;
if(x>maxX)maxX=x;
if(y>maxY)maxY=y;

}

// minX, minY and invSize are later used to transform coords into integers for z-order calculation

invSize=Math.max(maxX-minX,maxY-minY);
invSize=invSize!==0?1/invSize:0;

}

earcutLinked(outerNode,triangles,dim,minX,minY,invSize);

return triangles;

}};



// create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data,start,end,dim,clockwise){

var i,last;

if(clockwise===signedArea(data,start,end,dim)>0){

for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}

}else{

for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}

}

if(last&&equals(last,last.next)){

removeNode(last);
last=last.next;

}

return last;

}

// eliminate colinear or duplicate points

function filterPoints(start,end){

if(!start)return start;
if(!end)end=start;

var p=start,again;

do{

again=false;

if(!p.steiner&&(equals(p,p.next)||three_module_area(p.prev,p,p.next)===0)){

removeNode(p);
p=end=p.prev;
if(p===p.next)break;
again=true;

}else{

p=p.next;

}

}while(again||p!==end);

return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)

function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){

if(!ear)return;

// interlink polygon nodes in z-order

if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);

var stop=ear,prev,next;

// iterate through ears, slicing them one by one

while(ear.prev!==ear.next){

prev=ear.prev;
next=ear.next;

if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){

// cut off the triangle
triangles.push(prev.i/dim);
triangles.push(ear.i/dim);
triangles.push(next.i/dim);

removeNode(ear);

// skipping the next vertice leads to less sliver triangles
ear=next.next;
stop=next.next;

continue;

}

ear=next;

// if we looped through the whole remaining polygon and can't find any more ears

if(ear===stop){

// try filtering points and slicing again

if(!pass){

earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);

// if this didn't work, try curing all small self-intersections locally

}else if(pass===1){

ear=cureLocalIntersections(ear,triangles,dim);
earcutLinked(ear,triangles,dim,minX,minY,invSize,2);

// as a last resort, try splitting the remaining polygon into two

}else if(pass===2){

splitEarcut(ear,triangles,dim,minX,minY,invSize);

}

break;

}

}

}

// check whether a polygon node forms a valid ear with adjacent nodes

function isEar(ear){

var a=ear.prev,
b=ear,
c=ear.next;

if(three_module_area(a,b,c)>=0)return false;// reflex, can't be an ear

// now make sure we don't have other points inside the potential ear
var p=ear.next.next;

while(p!==ear.prev){

if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&three_module_area(p.prev,p,p.next)>=0){

return false;

}

p=p.next;

}

return true;

}

function isEarHashed(ear,minX,minY,invSize){

var a=ear.prev,
b=ear,
c=ear.next;

if(three_module_area(a,b,c)>=0)return false;// reflex, can't be an ear

// triangle bbox; min & max are calculated like this for speed

var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,
minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,
maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,
maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;

// z-order range for the current triangle bbox;

var minZ=zOrder(minTX,minTY,minX,minY,invSize),
maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);

// first look for points inside the triangle in increasing z-order

var p=ear.nextZ;

while(p&&p.z<=maxZ){

if(p!==ear.prev&&p!==ear.next&&
pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
three_module_area(p.prev,p,p.next)>=0)return false;
p=p.nextZ;

}

// then look for points in decreasing z-order

p=ear.prevZ;

while(p&&p.z>=minZ){

if(p!==ear.prev&&p!==ear.next&&
pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&
three_module_area(p.prev,p,p.next)>=0)return false;

p=p.prevZ;

}

return true;

}

// go through all polygon nodes and cure small local self-intersections

function cureLocalIntersections(start,triangles,dim){

var p=start;

do{

var a=p.prev,b=p.next.next;

if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){

triangles.push(a.i/dim);
triangles.push(p.i/dim);
triangles.push(b.i/dim);

// remove two nodes involved

removeNode(p);
removeNode(p.next);

p=start=b;

}

p=p.next;

}while(p!==start);

return p;

}

// try splitting polygon into two and triangulate them independently

function splitEarcut(start,triangles,dim,minX,minY,invSize){

// look for a valid diagonal that divides the polygon into two

var a=start;

do{

var b=a.next.next;

while(b!==a.prev){

if(a.i!==b.i&&isValidDiagonal(a,b)){

// split the polygon in two by the diagonal

var c=splitPolygon(a,b);

// filter colinear points around the cuts

a=filterPoints(a,a.next);
c=filterPoints(c,c.next);

// run earcut on each half

earcutLinked(a,triangles,dim,minX,minY,invSize);
earcutLinked(c,triangles,dim,minX,minY,invSize);
return;

}

b=b.next;

}

a=a.next;

}while(a!==start);

}

// link every hole into the outer loop, producing a single-ring polygon without holes

function eliminateHoles(data,holeIndices,outerNode,dim){

var queue=[],i,len,start,end,list;

for(i=0,len=holeIndices.length;i<len;i++){

start=holeIndices[i]*dim;
end=i<len-1?holeIndices[i+1]*dim:data.length;
list=linkedList(data,start,end,dim,false);
if(list===list.next)list.steiner=true;
queue.push(getLeftmost(list));

}

queue.sort(compareX);

// process holes from left to right

for(i=0;i<queue.length;i++){

eliminateHole(queue[i],outerNode);
outerNode=filterPoints(outerNode,outerNode.next);

}

return outerNode;

}

function compareX(a,b){

return a.x-b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it

function eliminateHole(hole,outerNode){

outerNode=findHoleBridge(hole,outerNode);

if(outerNode){

var b=splitPolygon(outerNode,hole);

filterPoints(b,b.next);

}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon

function findHoleBridge(hole,outerNode){

var p=outerNode,
hx=hole.x,
hy=hole.y,
qx=-Infinity,
m;

// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point

do{

if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){

var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);

if(x<=hx&&x>qx){

qx=x;

if(x===hx){

if(hy===p.y)return p;
if(hy===p.next.y)return p.next;

}

m=p.x<p.next.x?p:p.next;

}

}

p=p.next;

}while(p!==outerNode);

if(!m)return null;

if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint

// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point

var stop=m,
mx=m.x,
my=m.y,
tanMin=Infinity,
tan;

p=m.next;

while(p!==stop){

if(hx>=p.x&&p.x>=mx&&hx!==p.x&&
pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){

tan=Math.abs(hy-p.y)/(hx-p.x);// tangential

if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){

m=p;
tanMin=tan;

}

}

p=p.next;

}

return m;

}

// interlink polygon nodes in z-order

function indexCurve(start,minX,minY,invSize){

var p=start;

do{

if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);
p.prevZ=p.prev;
p.nextZ=p.next;
p=p.next;

}while(p!==start);

p.prevZ.nextZ=null;
p.prevZ=null;

sortLinked(p);

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

function sortLinked(list){

var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;

do{

p=list;
list=null;
tail=null;
numMerges=0;

while(p){

numMerges++;
q=p;
pSize=0;

for(i=0;i<inSize;i++){

pSize++;
q=q.nextZ;
if(!q)break;

}

qSize=inSize;

while(pSize>0||qSize>0&&q){

if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){

e=p;
p=p.nextZ;
pSize--;

}else{

e=q;
q=q.nextZ;
qSize--;

}

if(tail)tail.nextZ=e;else
list=e;

e.prevZ=tail;
tail=e;

}

p=q;

}

tail.nextZ=null;
inSize*=2;

}while(numMerges>1);

return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox

function zOrder(x,y,minX,minY,invSize){

// coords are transformed into non-negative 15-bit integer range

x=32767*(x-minX)*invSize;
y=32767*(y-minY)*invSize;

x=(x|x<<8)&0x00FF00FF;
x=(x|x<<4)&0x0F0F0F0F;
x=(x|x<<2)&0x33333333;
x=(x|x<<1)&0x55555555;

y=(y|y<<8)&0x00FF00FF;
y=(y|y<<4)&0x0F0F0F0F;
y=(y|y<<2)&0x33333333;
y=(y|y<<1)&0x55555555;

return x|y<<1;

}

// find the leftmost node of a polygon ring

function getLeftmost(start){

var p=start,leftmost=start;

do{

if(p.x<leftmost.x)leftmost=p;
p=p.next;

}while(p!==start);

return leftmost;

}

// check if a point lies within a convex triangle

function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){

return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&
(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&
(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

function isValidDiagonal(a,b){

return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&
locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);

}

// signed area of a triangle

function three_module_area(p,q,r){

return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);

}

// check if two points are equal

function equals(p1,p2){

return p1.x===p2.x&&p1.y===p2.y;

}

// check if two segments intersect

function intersects(p1,q1,p2,q2){

if(equals(p1,q1)&&equals(p2,q2)||
equals(p1,q2)&&equals(p2,q1))return true;

return three_module_area(p1,q1,p2)>0!==three_module_area(p1,q1,q2)>0&&
three_module_area(p2,q2,p1)>0!==three_module_area(p2,q2,q1)>0;

}

// check if a polygon diagonal intersects any polygon segments

function intersectsPolygon(a,b){

var p=a;

do{

if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&
intersects(p,p.next,a,b)){

return true;

}

p=p.next;

}while(p!==a);

return false;

}

// check if a polygon diagonal is locally inside the polygon

function locallyInside(a,b){

return three_module_area(a.prev,a,a.next)<0?
three_module_area(a,b,a.next)>=0&&three_module_area(a,a.prev,b)>=0:
three_module_area(a,b,a.prev)<0||three_module_area(a,a.next,b)<0;

}

// check if the middle point of a polygon diagonal is inside the polygon

function middleInside(a,b){

var p=a,
inside=false,
px=(a.x+b.x)/2,
py=(a.y+b.y)/2;

do{

if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&
px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x){

inside=!inside;

}

p=p.next;

}while(p!==a);

return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring

function splitPolygon(a,b){

var a2=new three_module_Node(a.i,a.x,a.y),
b2=new three_module_Node(b.i,b.x,b.y),
an=a.next,
bp=b.prev;

a.next=b;
b.prev=a;

a2.next=an;
an.prev=a2;

b2.next=a2;
a2.prev=b2;

bp.next=b2;
b2.prev=bp;

return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)

function insertNode(i,x,y,last){

var p=new three_module_Node(i,x,y);

if(!last){

p.prev=p;
p.next=p;

}else{

p.next=last.next;
p.prev=last;
last.next.prev=p;
last.next=p;

}

return p;

}

function removeNode(p){

p.next.prev=p.prev;
p.prev.next=p.next;

if(p.prevZ)p.prevZ.nextZ=p.nextZ;
if(p.nextZ)p.nextZ.prevZ=p.prevZ;

}

function three_module_Node(i,x,y){

// vertice index in coordinates array
this.i=i;

// vertex coordinates
this.x=x;
this.y=y;

// previous and next vertice nodes in a polygon ring
this.prev=null;
this.next=null;

// z-order curve value
this.z=null;

// previous and next nodes in z-order
this.prevZ=null;
this.nextZ=null;

// indicates whether this is a steiner point
this.steiner=false;

}

function signedArea(data,start,end,dim){

var sum=0;

for(var i=start,j=end-dim;i<end;i+=dim){

sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);
j=i;

}

return sum;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils={

// calculate area of the contour polygon

area:function area(contour){

var n=contour.length;
var a=0.0;

for(var p=n-1,q=0;q<n;p=q++){

a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;

}

return a*0.5;

},

isClockWise:function isClockWise(pts){

return ShapeUtils.area(pts)<0;

},

triangulateShape:function triangulateShape(contour,holes){

var vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
var holeIndices=[];// array of hole indices
var faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

removeDupEndPts(contour);
addContour(vertices,contour);

//

var holeIndex=contour.length;

holes.forEach(removeDupEndPts);

for(var i=0;i<holes.length;i++){

holeIndices.push(holeIndex);
holeIndex+=holes[i].length;
addContour(vertices,holes[i]);

}

//

var triangles=Earcut.triangulate(vertices,holeIndices);

//

for(var i=0;i<triangles.length;i+=3){

faces.push(triangles.slice(i,i+3));

}

return faces;

}};



function removeDupEndPts(points){

var l=points.length;

if(l>2&&points[l-1].equals(points[0])){

points.pop();

}

}

function addContour(vertices,contour){

for(var i=0;i<contour.length;i++){

vertices.push(contour[i].x);
vertices.push(contour[i].y);

}

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

// ExtrudeGeometry

function ExtrudeGeometry(shapes,options){

Geometry.call(this);

this.type='ExtrudeGeometry';

this.parameters={
shapes:shapes,
options:options};


this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));
this.mergeVertices();

}

ExtrudeGeometry.prototype=Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON=function(){

var data=Geometry.prototype.toJSON.call(this);

var shapes=this.parameters.shapes;
var options=this.parameters.options;

return toJSON(shapes,options,data);

};

// ExtrudeBufferGeometry

function ExtrudeBufferGeometry(shapes,options){

BufferGeometry.call(this);

this.type='ExtrudeBufferGeometry';

this.parameters={
shapes:shapes,
options:options};


shapes=Array.isArray(shapes)?shapes:[shapes];

var scope=this;

var verticesArray=[];
var uvArray=[];

for(var i=0,l=shapes.length;i<l;i++){

var shape=shapes[i];
addShape(shape);

}

// build geometry

this.addAttribute('position',new Float32BufferAttribute(verticesArray,3));
this.addAttribute('uv',new Float32BufferAttribute(uvArray,2));

this.computeVertexNormals();

// functions

function addShape(shape){

var placeholder=[];

// options

var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;
var steps=options.steps!==undefined?options.steps:1;
var depth=options.depth!==undefined?options.depth:100;

var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;
var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;
var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;
var bevelOffset=options.bevelOffset!==undefined?options.bevelOffset:0;
var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;

var extrudePath=options.extrudePath;

var uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;

// deprecated options

if(options.amount!==undefined){

console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
depth=options.amount;

}

//

var extrudePts,extrudeByPath=false;
var splineTube,binormal,normal,position2;

if(extrudePath){

extrudePts=extrudePath.getSpacedPoints(steps);

extrudeByPath=true;
bevelEnabled=false;// bevels not supported for path extrusion

// SETUP TNB variables

// TODO1 - have a .isClosed in spline?

splineTube=extrudePath.computeFrenetFrames(steps,false);

// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

binormal=new Vector3();
normal=new Vector3();
position2=new Vector3();

}

// Safeguards if bevels are not enabled

if(!bevelEnabled){

bevelSegments=0;
bevelThickness=0;
bevelSize=0;
bevelOffset=0;

}

// Variables initialization

var ahole,h,hl;// looping of holes

var shapePoints=shape.extractPoints(curveSegments);

var vertices=shapePoints.shape;
var holes=shapePoints.holes;

var reverse=!ShapeUtils.isClockWise(vertices);

if(reverse){

vertices=vertices.reverse();

// Maybe we should also check if holes are in the opposite direction, just to be safe ...

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];

if(ShapeUtils.isClockWise(ahole)){

holes[h]=ahole.reverse();

}

}

}


var faces=ShapeUtils.triangulateShape(vertices,holes);

/* Vertices */

var contour=vertices;// vertices has all points but contour has only points of circumference

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];

vertices=vertices.concat(ahole);

}


function scalePt2(pt,vec,size){

if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");

return vec.clone().multiplyScalar(size).add(pt);

}

var b,bs,t,z,
vert,vlen=vertices.length,
face,flen=faces.length;


// Find directions for point movement


function getBevelVec(inPt,inPrev,inNext){

// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.

var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt

// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html

var v_prev_x=inPt.x-inPrev.x,
v_prev_y=inPt.y-inPrev.y;
var v_next_x=inNext.x-inPt.x,
v_next_y=inNext.y-inPt.y;

var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;

// check for collinear edges
var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;

if(Math.abs(collinear0)>Number.EPSILON){

// not collinear

// length of vectors for normalizing

var v_prev_len=Math.sqrt(v_prev_lensq);
var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);

// shift adjacent points by unit vectors to the left

var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;
var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;

var ptNextShift_x=inNext.x-v_next_y/v_next_len;
var ptNextShift_y=inNext.y+v_next_x/v_next_len;

// scaling factor for v_prev to intersection point

var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-
(ptNextShift_y-ptPrevShift_y)*v_next_x)/(
v_prev_x*v_next_y-v_prev_y*v_next_x);

// vector from inPt to intersection point

v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;
v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;

// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;
if(v_trans_lensq<=2){

return new Vector2(v_trans_x,v_trans_y);

}else{

shrink_by=Math.sqrt(v_trans_lensq/2);

}

}else{

// handle special case of collinear edges

var direction_eq=false;// assumes: opposite
if(v_prev_x>Number.EPSILON){

if(v_next_x>Number.EPSILON){

direction_eq=true;

}

}else{

if(v_prev_x<-Number.EPSILON){

if(v_next_x<-Number.EPSILON){

direction_eq=true;

}

}else{

if(Math.sign(v_prev_y)===Math.sign(v_next_y)){

direction_eq=true;

}

}

}

if(direction_eq){

// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;
v_trans_y=v_prev_x;
shrink_by=Math.sqrt(v_prev_lensq);

}else{

// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;
v_trans_y=v_prev_y;
shrink_by=Math.sqrt(v_prev_lensq/2);

}

}

return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);

}


var contourMovements=[];

for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){

if(j===il)j=0;
if(k===il)k=0;

//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)

contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);

}

var holesMovements=[],
oneHoleMovements,verticesMovements=contourMovements.concat();

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];

oneHoleMovements=[];

for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){

if(j===il)j=0;
if(k===il)k=0;

//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);

}

holesMovements.push(oneHoleMovements);
verticesMovements=verticesMovements.concat(oneHoleMovements);

}


// Loop bevelSegments, 1 for the front, 1 for the back

for(b=0;b<bevelSegments;b++){

//for ( b = bevelSegments; b > 0; b -- ) {

t=b/bevelSegments;
z=bevelThickness*Math.cos(t*Math.PI/2);
bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;

// contract shape

for(i=0,il=contour.length;i<il;i++){

vert=scalePt2(contour[i],contourMovements[i],bs);

v(vert.x,vert.y,-z);

}

// expand holes

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];
oneHoleMovements=holesMovements[h];

for(i=0,il=ahole.length;i<il;i++){

vert=scalePt2(ahole[i],oneHoleMovements[i],bs);

v(vert.x,vert.y,-z);

}

}

}

bs=bevelSize+bevelOffset;

// Back facing vertices

for(i=0;i<vlen;i++){

vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];

if(!extrudeByPath){

v(vert.x,vert.y,0);

}else{

// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

position2.copy(extrudePts[0]).add(normal).add(binormal);

v(position2.x,position2.y,position2.z);

}

}

// Add stepped vertices...
// Including front facing vertices

var s;

for(s=1;s<=steps;s++){

for(i=0;i<vlen;i++){

vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];

if(!extrudeByPath){

v(vert.x,vert.y,depth/steps*s);

}else{

// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

position2.copy(extrudePts[s]).add(normal).add(binormal);

v(position2.x,position2.y,position2.z);

}

}

}


// Add bevel segments planes

//for ( b = 1; b <= bevelSegments; b ++ ) {
for(b=bevelSegments-1;b>=0;b--){

t=b/bevelSegments;
z=bevelThickness*Math.cos(t*Math.PI/2);
bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;

// contract shape

for(i=0,il=contour.length;i<il;i++){

vert=scalePt2(contour[i],contourMovements[i],bs);
v(vert.x,vert.y,depth+z);

}

// expand holes

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];
oneHoleMovements=holesMovements[h];

for(i=0,il=ahole.length;i<il;i++){

vert=scalePt2(ahole[i],oneHoleMovements[i],bs);

if(!extrudeByPath){

v(vert.x,vert.y,depth+z);

}else{

v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);

}

}

}

}

/* Faces */

// Top and bottom faces

buildLidFaces();

// Sides faces

buildSideFaces();


/////  Internal functions

function buildLidFaces(){

var start=verticesArray.length/3;

if(bevelEnabled){

var layer=0;// steps + 1
var offset=vlen*layer;

// Bottom faces

for(i=0;i<flen;i++){

face=faces[i];
f3(face[2]+offset,face[1]+offset,face[0]+offset);

}

layer=steps+bevelSegments*2;
offset=vlen*layer;

// Top faces

for(i=0;i<flen;i++){

face=faces[i];
f3(face[0]+offset,face[1]+offset,face[2]+offset);

}

}else{

// Bottom faces

for(i=0;i<flen;i++){

face=faces[i];
f3(face[2],face[1],face[0]);

}

// Top faces

for(i=0;i<flen;i++){

face=faces[i];
f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);

}

}

scope.addGroup(start,verticesArray.length/3-start,0);

}

// Create faces for the z-sides of the shape

function buildSideFaces(){

var start=verticesArray.length/3;
var layeroffset=0;
sidewalls(contour,layeroffset);
layeroffset+=contour.length;

for(h=0,hl=holes.length;h<hl;h++){

ahole=holes[h];
sidewalls(ahole,layeroffset);

//, true
layeroffset+=ahole.length;

}


scope.addGroup(start,verticesArray.length/3-start,1);


}

function sidewalls(contour,layeroffset){

var j,k;
i=contour.length;

while(--i>=0){

j=i;
k=i-1;
if(k<0)k=contour.length-1;

//console.log('b', i,j, i-1, k,vertices.length);

var s=0,
sl=steps+bevelSegments*2;

for(s=0;s<sl;s++){

var slen1=vlen*s;
var slen2=vlen*(s+1);

var a=layeroffset+j+slen1,
b=layeroffset+k+slen1,
c=layeroffset+k+slen2,
d=layeroffset+j+slen2;

f4(a,b,c,d);

}

}

}

function v(x,y,z){

placeholder.push(x);
placeholder.push(y);
placeholder.push(z);

}


function f3(a,b,c){

addVertex(a);
addVertex(b);
addVertex(c);

var nextIndex=verticesArray.length/3;
var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);

addUV(uvs[0]);
addUV(uvs[1]);
addUV(uvs[2]);

}

function f4(a,b,c,d){

addVertex(a);
addVertex(b);
addVertex(d);

addVertex(b);
addVertex(c);
addVertex(d);


var nextIndex=verticesArray.length/3;
var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);

addUV(uvs[0]);
addUV(uvs[1]);
addUV(uvs[3]);

addUV(uvs[1]);
addUV(uvs[2]);
addUV(uvs[3]);

}

function addVertex(index){

verticesArray.push(placeholder[index*3+0]);
verticesArray.push(placeholder[index*3+1]);
verticesArray.push(placeholder[index*3+2]);

}


function addUV(vector2){

uvArray.push(vector2.x);
uvArray.push(vector2.y);

}

}

}

ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON=function(){

var data=BufferGeometry.prototype.toJSON.call(this);

var shapes=this.parameters.shapes;
var options=this.parameters.options;

return toJSON(shapes,options,data);

};

//

var WorldUVGenerator={

generateTopUV:function generateTopUV(geometry,vertices,indexA,indexB,indexC){

var a_x=vertices[indexA*3];
var a_y=vertices[indexA*3+1];
var b_x=vertices[indexB*3];
var b_y=vertices[indexB*3+1];
var c_x=vertices[indexC*3];
var c_y=vertices[indexC*3+1];

return[
new Vector2(a_x,a_y),
new Vector2(b_x,b_y),
new Vector2(c_x,c_y)];


},

generateSideWallUV:function generateSideWallUV(geometry,vertices,indexA,indexB,indexC,indexD){

var a_x=vertices[indexA*3];
var a_y=vertices[indexA*3+1];
var a_z=vertices[indexA*3+2];
var b_x=vertices[indexB*3];
var b_y=vertices[indexB*3+1];
var b_z=vertices[indexB*3+2];
var c_x=vertices[indexC*3];
var c_y=vertices[indexC*3+1];
var c_z=vertices[indexC*3+2];
var d_x=vertices[indexD*3];
var d_y=vertices[indexD*3+1];
var d_z=vertices[indexD*3+2];

if(Math.abs(a_y-b_y)<0.01){

return[
new Vector2(a_x,1-a_z),
new Vector2(b_x,1-b_z),
new Vector2(c_x,1-c_z),
new Vector2(d_x,1-d_z)];


}else{

return[
new Vector2(a_y,1-a_z),
new Vector2(b_y,1-b_z),
new Vector2(c_y,1-c_z),
new Vector2(d_y,1-d_z)];


}

}};


function toJSON(shapes,options,data){

//

data.shapes=[];

if(Array.isArray(shapes)){

for(var i=0,l=shapes.length;i<l;i++){

var shape=shapes[i];

data.shapes.push(shape.uuid);

}

}else{

data.shapes.push(shapes.uuid);

}

//

if(options.extrudePath!==undefined)data.options.extrudePath=options.extrudePath.toJSON();

return data;

}

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

// TextGeometry

function TextGeometry(text,parameters){

Geometry.call(this);

this.type='TextGeometry';

this.parameters={
text:text,
parameters:parameters};


this.fromBufferGeometry(new TextBufferGeometry(text,parameters));
this.mergeVertices();

}

TextGeometry.prototype=Object.create(Geometry.prototype);
TextGeometry.prototype.constructor=TextGeometry;

// TextBufferGeometry

function TextBufferGeometry(text,parameters){

parameters=parameters||{};

var font=parameters.font;

if(!(font&&font.isFont)){

console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
return new Geometry();

}

var shapes=font.generateShapes(text,parameters.size);

// translate parameters to ExtrudeGeometry API

parameters.depth=parameters.height!==undefined?parameters.height:50;

// defaults

if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;
if(parameters.bevelSize===undefined)parameters.bevelSize=8;
if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;

ExtrudeBufferGeometry.call(this,shapes,parameters);

this.type='TextBufferGeometry';

}

TextBufferGeometry.prototype=Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor=TextBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */

// SphereGeometry

function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){

Geometry.call(this);

this.type='SphereGeometry';

this.parameters={
radius:radius,
widthSegments:widthSegments,
heightSegments:heightSegments,
phiStart:phiStart,
phiLength:phiLength,
thetaStart:thetaStart,
thetaLength:thetaLength};


this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));
this.mergeVertices();

}

SphereGeometry.prototype=Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor=SphereGeometry;

// SphereBufferGeometry

function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){

BufferGeometry.call(this);

this.type='SphereBufferGeometry';

this.parameters={
radius:radius,
widthSegments:widthSegments,
heightSegments:heightSegments,
phiStart:phiStart,
phiLength:phiLength,
thetaStart:thetaStart,
thetaLength:thetaLength};


radius=radius||1;

widthSegments=Math.max(3,Math.floor(widthSegments)||8);
heightSegments=Math.max(2,Math.floor(heightSegments)||6);

phiStart=phiStart!==undefined?phiStart:0;
phiLength=phiLength!==undefined?phiLength:Math.PI*2;

thetaStart=thetaStart!==undefined?thetaStart:0;
thetaLength=thetaLength!==undefined?thetaLength:Math.PI;

var thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);

var ix,iy;

var index=0;
var grid=[];

var vertex=new Vector3();
var normal=new Vector3();

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// generate vertices, normals and uvs

for(iy=0;iy<=heightSegments;iy++){

var verticesRow=[];

var v=iy/heightSegments;

// special case for the poles

var uOffset=0;

if(iy==0&&thetaStart==0){

uOffset=0.5/widthSegments;

}else if(iy==heightSegments&&thetaEnd==Math.PI){

uOffset=-0.5/widthSegments;

}

for(ix=0;ix<=widthSegments;ix++){

var u=ix/widthSegments;

// vertex

vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);
vertex.y=radius*Math.cos(thetaStart+v*thetaLength);
vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);

vertices.push(vertex.x,vertex.y,vertex.z);

// normal

normal.copy(vertex).normalize();
normals.push(normal.x,normal.y,normal.z);

// uv

uvs.push(u+uOffset,1-v);

verticesRow.push(index++);

}

grid.push(verticesRow);

}

// indices

for(iy=0;iy<heightSegments;iy++){

for(ix=0;ix<widthSegments;ix++){

var a=grid[iy][ix+1];
var b=grid[iy][ix];
var c=grid[iy+1][ix];
var d=grid[iy+1][ix+1];

if(iy!==0||thetaStart>0)indices.push(a,b,d);
if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;

/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */

// RingGeometry

function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){

Geometry.call(this);

this.type='RingGeometry';

this.parameters={
innerRadius:innerRadius,
outerRadius:outerRadius,
thetaSegments:thetaSegments,
phiSegments:phiSegments,
thetaStart:thetaStart,
thetaLength:thetaLength};


this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));
this.mergeVertices();

}

RingGeometry.prototype=Object.create(Geometry.prototype);
RingGeometry.prototype.constructor=RingGeometry;

// RingBufferGeometry

function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){

BufferGeometry.call(this);

this.type='RingBufferGeometry';

this.parameters={
innerRadius:innerRadius,
outerRadius:outerRadius,
thetaSegments:thetaSegments,
phiSegments:phiSegments,
thetaStart:thetaStart,
thetaLength:thetaLength};


innerRadius=innerRadius||0.5;
outerRadius=outerRadius||1;

thetaStart=thetaStart!==undefined?thetaStart:0;
thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;

thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;
phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// some helper variables

var segment;
var radius=innerRadius;
var radiusStep=(outerRadius-innerRadius)/phiSegments;
var vertex=new Vector3();
var uv=new Vector2();
var j,i;

// generate vertices, normals and uvs

for(j=0;j<=phiSegments;j++){

for(i=0;i<=thetaSegments;i++){

// values are generate from the inside of the ring to the outside

segment=thetaStart+i/thetaSegments*thetaLength;

// vertex

vertex.x=radius*Math.cos(segment);
vertex.y=radius*Math.sin(segment);

vertices.push(vertex.x,vertex.y,vertex.z);

// normal

normals.push(0,0,1);

// uv

uv.x=(vertex.x/outerRadius+1)/2;
uv.y=(vertex.y/outerRadius+1)/2;

uvs.push(uv.x,uv.y);

}

// increase the radius for next row of vertices

radius+=radiusStep;

}

// indices

for(j=0;j<phiSegments;j++){

var thetaSegmentLevel=j*(thetaSegments+1);

for(i=0;i<thetaSegments;i++){

segment=i+thetaSegmentLevel;

var a=segment;
var b=segment+thetaSegments+1;
var c=segment+thetaSegments+2;
var d=segment+1;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

RingBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor=RingBufferGeometry;

/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */

// LatheGeometry

function LatheGeometry(points,segments,phiStart,phiLength){

Geometry.call(this);

this.type='LatheGeometry';

this.parameters={
points:points,
segments:segments,
phiStart:phiStart,
phiLength:phiLength};


this.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));
this.mergeVertices();

}

LatheGeometry.prototype=Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor=LatheGeometry;

// LatheBufferGeometry

function LatheBufferGeometry(points,segments,phiStart,phiLength){

BufferGeometry.call(this);

this.type='LatheBufferGeometry';

this.parameters={
points:points,
segments:segments,
phiStart:phiStart,
phiLength:phiLength};


segments=Math.floor(segments)||12;
phiStart=phiStart||0;
phiLength=phiLength||Math.PI*2;

// clamp phiLength so it's in range of [ 0, 2PI ]

phiLength=_Math.clamp(phiLength,0,Math.PI*2);


// buffers

var indices=[];
var vertices=[];
var uvs=[];

// helper variables

var base;
var inverseSegments=1.0/segments;
var vertex=new Vector3();
var uv=new Vector2();
var i,j;

// generate vertices and uvs

for(i=0;i<=segments;i++){

var phi=phiStart+i*inverseSegments*phiLength;

var sin=Math.sin(phi);
var cos=Math.cos(phi);

for(j=0;j<=points.length-1;j++){

// vertex

vertex.x=points[j].x*sin;
vertex.y=points[j].y;
vertex.z=points[j].x*cos;

vertices.push(vertex.x,vertex.y,vertex.z);

// uv

uv.x=i/segments;
uv.y=j/(points.length-1);

uvs.push(uv.x,uv.y);


}

}

// indices

for(i=0;i<segments;i++){

for(j=0;j<points.length-1;j++){

base=j+i*points.length;

var a=base;
var b=base+points.length;
var c=base+points.length+1;
var d=base+1;

// faces

indices.push(a,b,d);
indices.push(b,c,d);

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

// generate normals

this.computeVertexNormals();

// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).

if(phiLength===Math.PI*2){

var normals=this.attributes.normal.array;
var n1=new Vector3();
var n2=new Vector3();
var n=new Vector3();

// this is the buffer offset for the last line of vertices

base=segments*points.length*3;

for(i=0,j=0;i<points.length;i++,j+=3){

// select the normal of the vertex in the first line

n1.x=normals[j+0];
n1.y=normals[j+1];
n1.z=normals[j+2];

// select the normal of the vertex in the last line

n2.x=normals[base+j+0];
n2.y=normals[base+j+1];
n2.z=normals[base+j+2];

// average normals

n.addVectors(n1,n2).normalize();

// assign the new values to both normals

normals[j+0]=normals[base+j+0]=n.x;
normals[j+1]=normals[base+j+1]=n.y;
normals[j+2]=normals[base+j+2]=n.z;

}

}

}

LatheBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor=LatheBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */

// ShapeGeometry

function ShapeGeometry(shapes,curveSegments){

Geometry.call(this);

this.type='ShapeGeometry';

if(typeof curveSegments==='object'){

console.warn('THREE.ShapeGeometry: Options parameter has been removed.');

curveSegments=curveSegments.curveSegments;

}

this.parameters={
shapes:shapes,
curveSegments:curveSegments};


this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));
this.mergeVertices();

}

ShapeGeometry.prototype=Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor=ShapeGeometry;

ShapeGeometry.prototype.toJSON=function(){

var data=Geometry.prototype.toJSON.call(this);

var shapes=this.parameters.shapes;

return toJSON$1(shapes,data);

};

// ShapeBufferGeometry

function ShapeBufferGeometry(shapes,curveSegments){

BufferGeometry.call(this);

this.type='ShapeBufferGeometry';

this.parameters={
shapes:shapes,
curveSegments:curveSegments};


curveSegments=curveSegments||12;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var groupStart=0;
var groupCount=0;

// allow single and array values for "shapes" parameter

if(Array.isArray(shapes)===false){

addShape(shapes);

}else{

for(var i=0;i<shapes.length;i++){

addShape(shapes[i]);

this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support

groupStart+=groupCount;
groupCount=0;

}

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));


// helper functions

function addShape(shape){

var i,l,shapeHole;

var indexOffset=vertices.length/3;
var points=shape.extractPoints(curveSegments);

var shapeVertices=points.shape;
var shapeHoles=points.holes;

// check direction of vertices

if(ShapeUtils.isClockWise(shapeVertices)===false){

shapeVertices=shapeVertices.reverse();

}

for(i=0,l=shapeHoles.length;i<l;i++){

shapeHole=shapeHoles[i];

if(ShapeUtils.isClockWise(shapeHole)===true){

shapeHoles[i]=shapeHole.reverse();

}

}

var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);

// join vertices of inner and outer paths to a single array

for(i=0,l=shapeHoles.length;i<l;i++){

shapeHole=shapeHoles[i];
shapeVertices=shapeVertices.concat(shapeHole);

}

// vertices, normals, uvs

for(i=0,l=shapeVertices.length;i<l;i++){

var vertex=shapeVertices[i];

vertices.push(vertex.x,vertex.y,0);
normals.push(0,0,1);
uvs.push(vertex.x,vertex.y);// world uvs

}

// incides

for(i=0,l=faces.length;i<l;i++){

var face=faces[i];

var a=face[0]+indexOffset;
var b=face[1]+indexOffset;
var c=face[2]+indexOffset;

indices.push(a,b,c);
groupCount+=3;

}

}

}

ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON=function(){

var data=BufferGeometry.prototype.toJSON.call(this);

var shapes=this.parameters.shapes;

return toJSON$1(shapes,data);

};

//

function toJSON$1(shapes,data){

data.shapes=[];

if(Array.isArray(shapes)){

for(var i=0,l=shapes.length;i<l;i++){

var shape=shapes[i];

data.shapes.push(shape.uuid);

}

}else{

data.shapes.push(shapes.uuid);

}

return data;

}

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */

function EdgesGeometry(geometry,thresholdAngle){

BufferGeometry.call(this);

this.type='EdgesGeometry';

this.parameters={
thresholdAngle:thresholdAngle};


thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;

// buffer

var vertices=[];

// helper variables

var thresholdDot=Math.cos(_Math.DEG2RAD*thresholdAngle);
var edge=[0,0],edges={},edge1,edge2;
var key,keys=['a','b','c'];

// prepare source geometry

var geometry2;

if(geometry.isBufferGeometry){

geometry2=new Geometry();
geometry2.fromBufferGeometry(geometry);

}else{

geometry2=geometry.clone();

}

geometry2.mergeVertices();
geometry2.computeFaceNormals();

var sourceVertices=geometry2.vertices;
var faces=geometry2.faces;

// now create a data structure where each entry represents an edge with its adjoining faces

for(var i=0,l=faces.length;i<l;i++){

var face=faces[i];

for(var j=0;j<3;j++){

edge1=face[keys[j]];
edge2=face[keys[(j+1)%3]];
edge[0]=Math.min(edge1,edge2);
edge[1]=Math.max(edge1,edge2);

key=edge[0]+','+edge[1];

if(edges[key]===undefined){

edges[key]={index1:edge[0],index2:edge[1],face1:i,face2:undefined};

}else{

edges[key].face2=i;

}

}

}

// generate vertices

for(key in edges){

var e=edges[key];

// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

if(e.face2===undefined||faces[e.face1].normal.dot(faces[e.face2].normal)<=thresholdDot){

var vertex=sourceVertices[e.index1];
vertices.push(vertex.x,vertex.y,vertex.z);

vertex=sourceVertices[e.index2];
vertices.push(vertex.x,vertex.y,vertex.z);

}

}

// build geometry

this.addAttribute('position',new Float32BufferAttribute(vertices,3));

}

EdgesGeometry.prototype=Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor=EdgesGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

// CylinderGeometry

function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){

Geometry.call(this);

this.type='CylinderGeometry';

this.parameters={
radiusTop:radiusTop,
radiusBottom:radiusBottom,
height:height,
radialSegments:radialSegments,
heightSegments:heightSegments,
openEnded:openEnded,
thetaStart:thetaStart,
thetaLength:thetaLength};


this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));
this.mergeVertices();

}

CylinderGeometry.prototype=Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor=CylinderGeometry;

// CylinderBufferGeometry

function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){

BufferGeometry.call(this);

this.type='CylinderBufferGeometry';

this.parameters={
radiusTop:radiusTop,
radiusBottom:radiusBottom,
height:height,
radialSegments:radialSegments,
heightSegments:heightSegments,
openEnded:openEnded,
thetaStart:thetaStart,
thetaLength:thetaLength};


var scope=this;

radiusTop=radiusTop!==undefined?radiusTop:1;
radiusBottom=radiusBottom!==undefined?radiusBottom:1;
height=height||1;

radialSegments=Math.floor(radialSegments)||8;
heightSegments=Math.floor(heightSegments)||1;

openEnded=openEnded!==undefined?openEnded:false;
thetaStart=thetaStart!==undefined?thetaStart:0.0;
thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var index=0;
var indexArray=[];
var halfHeight=height/2;
var groupStart=0;

// generate geometry

generateTorso();

if(openEnded===false){

if(radiusTop>0)generateCap(true);
if(radiusBottom>0)generateCap(false);

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

function generateTorso(){

var x,y;
var normal=new Vector3();
var vertex=new Vector3();

var groupCount=0;

// this will be used to calculate the normal
var slope=(radiusBottom-radiusTop)/height;

// generate vertices, normals and uvs

for(y=0;y<=heightSegments;y++){

var indexRow=[];

var v=y/heightSegments;

// calculate the radius of the current row

var radius=v*(radiusBottom-radiusTop)+radiusTop;

for(x=0;x<=radialSegments;x++){

var u=x/radialSegments;

var theta=u*thetaLength+thetaStart;

var sinTheta=Math.sin(theta);
var cosTheta=Math.cos(theta);

// vertex

vertex.x=radius*sinTheta;
vertex.y=-v*height+halfHeight;
vertex.z=radius*cosTheta;
vertices.push(vertex.x,vertex.y,vertex.z);

// normal

normal.set(sinTheta,slope,cosTheta).normalize();
normals.push(normal.x,normal.y,normal.z);

// uv

uvs.push(u,1-v);

// save index of vertex in respective row

indexRow.push(index++);

}

// now save vertices of the row in our index array

indexArray.push(indexRow);

}

// generate indices

for(x=0;x<radialSegments;x++){

for(y=0;y<heightSegments;y++){

// we use the index array to access the correct indices

var a=indexArray[y][x];
var b=indexArray[y+1][x];
var c=indexArray[y+1][x+1];
var d=indexArray[y][x+1];

// faces

indices.push(a,b,d);
indices.push(b,c,d);

// update group counter

groupCount+=6;

}

}

// add a group to the geometry. this will ensure multi material support

scope.addGroup(groupStart,groupCount,0);

// calculate new start value for groups

groupStart+=groupCount;

}

function generateCap(top){

var x,centerIndexStart,centerIndexEnd;

var uv=new Vector2();
var vertex=new Vector3();

var groupCount=0;

var radius=top===true?radiusTop:radiusBottom;
var sign=top===true?1:-1;

// save the index of the first center vertex
centerIndexStart=index;

// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment

for(x=1;x<=radialSegments;x++){

// vertex

vertices.push(0,halfHeight*sign,0);

// normal

normals.push(0,sign,0);

// uv

uvs.push(0.5,0.5);

// increase index

index++;

}

// save the index of the last center vertex

centerIndexEnd=index;

// now we generate the surrounding vertices, normals and uvs

for(x=0;x<=radialSegments;x++){

var u=x/radialSegments;
var theta=u*thetaLength+thetaStart;

var cosTheta=Math.cos(theta);
var sinTheta=Math.sin(theta);

// vertex

vertex.x=radius*sinTheta;
vertex.y=halfHeight*sign;
vertex.z=radius*cosTheta;
vertices.push(vertex.x,vertex.y,vertex.z);

// normal

normals.push(0,sign,0);

// uv

uv.x=cosTheta*0.5+0.5;
uv.y=sinTheta*0.5*sign+0.5;
uvs.push(uv.x,uv.y);

// increase index

index++;

}

// generate indices

for(x=0;x<radialSegments;x++){

var c=centerIndexStart+x;
var i=centerIndexEnd+x;

if(top===true){

// face top

indices.push(i,i+1,c);

}else{

// face bottom

indices.push(i+1,i,c);

}

groupCount+=3;

}

// add a group to the geometry. this will ensure multi material support

scope.addGroup(groupStart,groupCount,top===true?1:2);

// calculate new start value for groups

groupStart+=groupCount;

}

}

CylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

// ConeGeometry

function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){

CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);

this.type='ConeGeometry';

this.parameters={
radius:radius,
height:height,
radialSegments:radialSegments,
heightSegments:heightSegments,
openEnded:openEnded,
thetaStart:thetaStart,
thetaLength:thetaLength};


}

ConeGeometry.prototype=Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor=ConeGeometry;

// ConeBufferGeometry

function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){

CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);

this.type='ConeBufferGeometry';

this.parameters={
radius:radius,
height:height,
radialSegments:radialSegments,
heightSegments:heightSegments,
openEnded:openEnded,
thetaStart:thetaStart,
thetaLength:thetaLength};


}

ConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */

// CircleGeometry

function CircleGeometry(radius,segments,thetaStart,thetaLength){

Geometry.call(this);

this.type='CircleGeometry';

this.parameters={
radius:radius,
segments:segments,
thetaStart:thetaStart,
thetaLength:thetaLength};


this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));
this.mergeVertices();

}

CircleGeometry.prototype=Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor=CircleGeometry;

// CircleBufferGeometry

function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){

BufferGeometry.call(this);

this.type='CircleBufferGeometry';

this.parameters={
radius:radius,
segments:segments,
thetaStart:thetaStart,
thetaLength:thetaLength};


radius=radius||1;
segments=segments!==undefined?Math.max(3,segments):8;

thetaStart=thetaStart!==undefined?thetaStart:0;
thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;

// buffers

var indices=[];
var vertices=[];
var normals=[];
var uvs=[];

// helper variables

var i,s;
var vertex=new Vector3();
var uv=new Vector2();

// center point

vertices.push(0,0,0);
normals.push(0,0,1);
uvs.push(0.5,0.5);

for(s=0,i=3;s<=segments;s++,i+=3){

var segment=thetaStart+s/segments*thetaLength;

// vertex

vertex.x=radius*Math.cos(segment);
vertex.y=radius*Math.sin(segment);

vertices.push(vertex.x,vertex.y,vertex.z);

// normal

normals.push(0,0,1);

// uvs

uv.x=(vertices[i]/radius+1)/2;
uv.y=(vertices[i+1]/radius+1)/2;

uvs.push(uv.x,uv.y);

}

// indices

for(i=1;i<=segments;i++){

indices.push(i,i+1,0);

}

// build geometry

this.setIndex(indices);
this.addAttribute('position',new Float32BufferAttribute(vertices,3));
this.addAttribute('normal',new Float32BufferAttribute(normals,3));
this.addAttribute('uv',new Float32BufferAttribute(uvs,2));

}

CircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;



var Geometries=/*#__PURE__*/Object.freeze({
WireframeGeometry:WireframeGeometry,
ParametricGeometry:ParametricGeometry,
ParametricBufferGeometry:ParametricBufferGeometry,
TetrahedronGeometry:TetrahedronGeometry,
TetrahedronBufferGeometry:TetrahedronBufferGeometry,
OctahedronGeometry:OctahedronGeometry,
OctahedronBufferGeometry:OctahedronBufferGeometry,
IcosahedronGeometry:IcosahedronGeometry,
IcosahedronBufferGeometry:IcosahedronBufferGeometry,
DodecahedronGeometry:DodecahedronGeometry,
DodecahedronBufferGeometry:DodecahedronBufferGeometry,
PolyhedronGeometry:PolyhedronGeometry,
PolyhedronBufferGeometry:PolyhedronBufferGeometry,
TubeGeometry:TubeGeometry,
TubeBufferGeometry:TubeBufferGeometry,
TorusKnotGeometry:TorusKnotGeometry,
TorusKnotBufferGeometry:TorusKnotBufferGeometry,
TorusGeometry:TorusGeometry,
TorusBufferGeometry:TorusBufferGeometry,
TextGeometry:TextGeometry,
TextBufferGeometry:TextBufferGeometry,
SphereGeometry:SphereGeometry,
SphereBufferGeometry:SphereBufferGeometry,
RingGeometry:RingGeometry,
RingBufferGeometry:RingBufferGeometry,
PlaneGeometry:PlaneGeometry,
PlaneBufferGeometry:PlaneBufferGeometry,
LatheGeometry:LatheGeometry,
LatheBufferGeometry:LatheBufferGeometry,
ShapeGeometry:ShapeGeometry,
ShapeBufferGeometry:ShapeBufferGeometry,
ExtrudeGeometry:ExtrudeGeometry,
ExtrudeBufferGeometry:ExtrudeBufferGeometry,
EdgesGeometry:EdgesGeometry,
ConeGeometry:ConeGeometry,
ConeBufferGeometry:ConeBufferGeometry,
CylinderGeometry:CylinderGeometry,
CylinderBufferGeometry:CylinderBufferGeometry,
CircleGeometry:CircleGeometry,
CircleBufferGeometry:CircleBufferGeometry,
BoxGeometry:BoxGeometry,
BoxBufferGeometry:BoxBufferGeometry});


/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters){

Material.call(this);

this.type='ShadowMaterial';

this.color=new Color(0x000000);
this.transparent=true;

this.setValues(parameters);

}

ShadowMaterial.prototype=Object.create(Material.prototype);
ShadowMaterial.prototype.constructor=ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial=true;

ShadowMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial(parameters){

ShaderMaterial.call(this,parameters);

this.type='RawShaderMaterial';

}

RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor=RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial=true;

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters){

Material.call(this);

this.defines={'STANDARD':''};

this.type='MeshStandardMaterial';

this.color=new Color(0xffffff);// diffuse
this.roughness=0.5;
this.metalness=0.5;

this.map=null;

this.lightMap=null;
this.lightMapIntensity=1.0;

this.aoMap=null;
this.aoMapIntensity=1.0;

this.emissive=new Color(0x000000);
this.emissiveIntensity=1.0;
this.emissiveMap=null;

this.bumpMap=null;
this.bumpScale=1;

this.normalMap=null;
this.normalMapType=TangentSpaceNormalMap;
this.normalScale=new Vector2(1,1);

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.roughnessMap=null;

this.metalnessMap=null;

this.alphaMap=null;

this.envMap=null;
this.envMapIntensity=1.0;

this.refractionRatio=0.98;

this.wireframe=false;
this.wireframeLinewidth=1;
this.wireframeLinecap='round';
this.wireframeLinejoin='round';

this.skinning=false;
this.morphTargets=false;
this.morphNormals=false;

this.setValues(parameters);

}

MeshStandardMaterial.prototype=Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor=MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial=true;

MeshStandardMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.defines={'STANDARD':''};

this.color.copy(source.color);
this.roughness=source.roughness;
this.metalness=source.metalness;

this.map=source.map;

this.lightMap=source.lightMap;
this.lightMapIntensity=source.lightMapIntensity;

this.aoMap=source.aoMap;
this.aoMapIntensity=source.aoMapIntensity;

this.emissive.copy(source.emissive);
this.emissiveMap=source.emissiveMap;
this.emissiveIntensity=source.emissiveIntensity;

this.bumpMap=source.bumpMap;
this.bumpScale=source.bumpScale;

this.normalMap=source.normalMap;
this.normalMapType=source.normalMapType;
this.normalScale.copy(source.normalScale);

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

this.roughnessMap=source.roughnessMap;

this.metalnessMap=source.metalnessMap;

this.alphaMap=source.alphaMap;

this.envMap=source.envMap;
this.envMapIntensity=source.envMapIntensity;

this.refractionRatio=source.refractionRatio;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;
this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 *  clearCoat: <float>
 *  clearCoatRoughness: <float>
 * }
 */

function MeshPhysicalMaterial(parameters){

MeshStandardMaterial.call(this);

this.defines={'PHYSICAL':''};

this.type='MeshPhysicalMaterial';

this.reflectivity=0.5;// maps to F0 = 0.04

this.clearCoat=0.0;
this.clearCoatRoughness=0.0;

this.setValues(parameters);

}

MeshPhysicalMaterial.prototype=Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;

MeshPhysicalMaterial.prototype.copy=function(source){

MeshStandardMaterial.prototype.copy.call(this,source);

this.defines={'PHYSICAL':''};

this.reflectivity=source.reflectivity;

this.clearCoat=source.clearCoat;
this.clearCoatRoughness=source.clearCoatRoughness;

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial(parameters){

Material.call(this);

this.type='MeshPhongMaterial';

this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);
this.shininess=30;

this.map=null;

this.lightMap=null;
this.lightMapIntensity=1.0;

this.aoMap=null;
this.aoMapIntensity=1.0;

this.emissive=new Color(0x000000);
this.emissiveIntensity=1.0;
this.emissiveMap=null;

this.bumpMap=null;
this.bumpScale=1;

this.normalMap=null;
this.normalMapType=TangentSpaceNormalMap;
this.normalScale=new Vector2(1,1);

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.specularMap=null;

this.alphaMap=null;

this.envMap=null;
this.combine=MultiplyOperation;
this.reflectivity=1;
this.refractionRatio=0.98;

this.wireframe=false;
this.wireframeLinewidth=1;
this.wireframeLinecap='round';
this.wireframeLinejoin='round';

this.skinning=false;
this.morphTargets=false;
this.morphNormals=false;

this.setValues(parameters);

}

MeshPhongMaterial.prototype=Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial=true;

MeshPhongMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);
this.specular.copy(source.specular);
this.shininess=source.shininess;

this.map=source.map;

this.lightMap=source.lightMap;
this.lightMapIntensity=source.lightMapIntensity;

this.aoMap=source.aoMap;
this.aoMapIntensity=source.aoMapIntensity;

this.emissive.copy(source.emissive);
this.emissiveMap=source.emissiveMap;
this.emissiveIntensity=source.emissiveIntensity;

this.bumpMap=source.bumpMap;
this.bumpScale=source.bumpScale;

this.normalMap=source.normalMap;
this.normalMapType=source.normalMapType;
this.normalScale.copy(source.normalScale);

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

this.specularMap=source.specularMap;

this.alphaMap=source.alphaMap;

this.envMap=source.envMap;
this.combine=source.combine;
this.reflectivity=source.reflectivity;
this.refractionRatio=source.refractionRatio;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;
this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */

function MeshToonMaterial(parameters){

MeshPhongMaterial.call(this);

this.defines={'TOON':''};

this.type='MeshToonMaterial';

this.gradientMap=null;

this.setValues(parameters);

}

MeshToonMaterial.prototype=Object.create(MeshPhongMaterial.prototype);
MeshToonMaterial.prototype.constructor=MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial=true;

MeshToonMaterial.prototype.copy=function(source){

MeshPhongMaterial.prototype.copy.call(this,source);

this.gradientMap=source.gradientMap;

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial(parameters){

Material.call(this);

this.type='MeshNormalMaterial';

this.bumpMap=null;
this.bumpScale=1;

this.normalMap=null;
this.normalMapType=TangentSpaceNormalMap;
this.normalScale=new Vector2(1,1);

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.wireframe=false;
this.wireframeLinewidth=1;

this.fog=false;
this.lights=false;

this.skinning=false;
this.morphTargets=false;
this.morphNormals=false;

this.setValues(parameters);

}

MeshNormalMaterial.prototype=Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor=MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial=true;

MeshNormalMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.bumpMap=source.bumpMap;
this.bumpScale=source.bumpScale;

this.normalMap=source.normalMap;
this.normalMapType=source.normalMapType;
this.normalScale.copy(source.normalScale);

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial(parameters){

Material.call(this);

this.type='MeshLambertMaterial';

this.color=new Color(0xffffff);// diffuse

this.map=null;

this.lightMap=null;
this.lightMapIntensity=1.0;

this.aoMap=null;
this.aoMapIntensity=1.0;

this.emissive=new Color(0x000000);
this.emissiveIntensity=1.0;
this.emissiveMap=null;

this.specularMap=null;

this.alphaMap=null;

this.envMap=null;
this.combine=MultiplyOperation;
this.reflectivity=1;
this.refractionRatio=0.98;

this.wireframe=false;
this.wireframeLinewidth=1;
this.wireframeLinecap='round';
this.wireframeLinejoin='round';

this.skinning=false;
this.morphTargets=false;
this.morphNormals=false;

this.setValues(parameters);

}

MeshLambertMaterial.prototype=Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial=true;

MeshLambertMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.color.copy(source.color);

this.map=source.map;

this.lightMap=source.lightMap;
this.lightMapIntensity=source.lightMapIntensity;

this.aoMap=source.aoMap;
this.aoMapIntensity=source.aoMapIntensity;

this.emissive.copy(source.emissive);
this.emissiveMap=source.emissiveMap;
this.emissiveIntensity=source.emissiveIntensity;

this.specularMap=source.specularMap;

this.alphaMap=source.alphaMap;

this.envMap=source.envMap;
this.combine=source.combine;
this.reflectivity=source.reflectivity;
this.refractionRatio=source.refractionRatio;

this.wireframe=source.wireframe;
this.wireframeLinewidth=source.wireframeLinewidth;
this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshMatcapMaterial(parameters){

Material.call(this);

this.defines={'MATCAP':''};

this.type='MeshMatcapMaterial';

this.color=new Color(0xffffff);// diffuse

this.matcap=null;

this.map=null;

this.bumpMap=null;
this.bumpScale=1;

this.normalMap=null;
this.normalMapType=TangentSpaceNormalMap;
this.normalScale=new Vector2(1,1);

this.displacementMap=null;
this.displacementScale=1;
this.displacementBias=0;

this.alphaMap=null;

this.skinning=false;
this.morphTargets=false;
this.morphNormals=false;

this.lights=false;

this.setValues(parameters);

}

MeshMatcapMaterial.prototype=Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor=MeshMatcapMaterial;

MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;

MeshMatcapMaterial.prototype.copy=function(source){

Material.prototype.copy.call(this,source);

this.defines={'MATCAP':''};

this.color.copy(source.color);

this.matcap=source.matcap;

this.map=source.map;

this.bumpMap=source.bumpMap;
this.bumpScale=source.bumpScale;

this.normalMap=source.normalMap;
this.normalMapType=source.normalMapType;
this.normalScale.copy(source.normalScale);

this.displacementMap=source.displacementMap;
this.displacementScale=source.displacementScale;
this.displacementBias=source.displacementBias;

this.alphaMap=source.alphaMap;

this.skinning=source.skinning;
this.morphTargets=source.morphTargets;
this.morphNormals=source.morphNormals;

return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial(parameters){

LineBasicMaterial.call(this);

this.type='LineDashedMaterial';

this.scale=1;
this.dashSize=3;
this.gapSize=1;

this.setValues(parameters);

}

LineDashedMaterial.prototype=Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor=LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial=true;

LineDashedMaterial.prototype.copy=function(source){

LineBasicMaterial.prototype.copy.call(this,source);

this.scale=source.scale;
this.dashSize=source.dashSize;
this.gapSize=source.gapSize;

return this;

};



var Materials=/*#__PURE__*/Object.freeze({
ShadowMaterial:ShadowMaterial,
SpriteMaterial:SpriteMaterial,
RawShaderMaterial:RawShaderMaterial,
ShaderMaterial:ShaderMaterial,
PointsMaterial:PointsMaterial,
MeshPhysicalMaterial:MeshPhysicalMaterial,
MeshStandardMaterial:MeshStandardMaterial,
MeshPhongMaterial:MeshPhongMaterial,
MeshToonMaterial:MeshToonMaterial,
MeshNormalMaterial:MeshNormalMaterial,
MeshLambertMaterial:MeshLambertMaterial,
MeshDepthMaterial:MeshDepthMaterial,
MeshDistanceMaterial:MeshDistanceMaterial,
MeshBasicMaterial:MeshBasicMaterial,
MeshMatcapMaterial:MeshMatcapMaterial,
LineDashedMaterial:LineDashedMaterial,
LineBasicMaterial:LineBasicMaterial,
Material:Material});


/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils={

// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function arraySlice(array,from,to){

if(AnimationUtils.isTypedArray(array)){

// in ios9 array.subarray(from, undefined) will return empty array
// but array.subarray(from) or array.subarray(from, len) is correct
return new array.constructor(array.subarray(from,to!==undefined?to:array.length));

}

return array.slice(from,to);

},

// converts an array to a specific type
convertArray:function convertArray(array,type,forceClone){

if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;

if(typeof type.BYTES_PER_ELEMENT==='number'){

return new type(array);// create typed array

}

return Array.prototype.slice.call(array);// create Array

},

isTypedArray:function isTypedArray(object){

return ArrayBuffer.isView(object)&&
!(object instanceof DataView);

},

// returns an array by which times and values can be sorted
getKeyframeOrder:function getKeyframeOrder(times){

function compareTime(i,j){

return times[i]-times[j];

}

var n=times.length;
var result=new Array(n);
for(var i=0;i!==n;++i){result[i]=i;}

result.sort(compareTime);

return result;

},

// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function sortedArray(values,stride,order){

var nValues=values.length;
var result=new values.constructor(nValues);

for(var i=0,dstOffset=0;dstOffset!==nValues;++i){

var srcOffset=order[i]*stride;

for(var j=0;j!==stride;++j){

result[dstOffset++]=values[srcOffset+j];

}

}

return result;

},

// function for parsing AOS keyframe formats
flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){

var i=1,key=jsonKeys[0];

while(key!==undefined&&key[valuePropertyName]===undefined){

key=jsonKeys[i++];

}

if(key===undefined)return;// no data

var value=key[valuePropertyName];
if(value===undefined)return;// no data

if(Array.isArray(value)){

do{

value=key[valuePropertyName];

if(value!==undefined){

times.push(key.time);
values.push.apply(values,value);// push all elements

}

key=jsonKeys[i++];

}while(key!==undefined);

}else if(value.toArray!==undefined){

// ...assume THREE.Math-ish

do{

value=key[valuePropertyName];

if(value!==undefined){

times.push(key.time);
value.toArray(values,values.length);

}

key=jsonKeys[i++];

}while(key!==undefined);

}else{

// otherwise push as-is

do{

value=key[valuePropertyName];

if(value!==undefined){

times.push(key.time);
values.push(value);

}

key=jsonKeys[i++];

}while(key!==undefined);

}

}};



/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

this.parameterPositions=parameterPositions;
this._cachedIndex=0;

this.resultBuffer=resultBuffer!==undefined?
resultBuffer:new sampleValues.constructor(sampleSize);
this.sampleValues=sampleValues;
this.valueSize=sampleSize;

}

Object.assign(Interpolant.prototype,{

evaluate:function evaluate(t){

var pp=this.parameterPositions,
i1=this._cachedIndex,

t1=pp[i1],
t0=pp[i1-1];

validate_interval:{

seek:{

var right;

linear_scan:{

//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){

for(var giveUpAt=i1+2;;){

if(t1===undefined){

if(t<t0)break forward_scan;

// after end

i1=pp.length;
this._cachedIndex=i1;
return this.afterEnd_(i1-1,t,t0);

}

if(i1===giveUpAt)break;// this loop

t0=t1;
t1=pp[++i1];

if(t<t1){

// we have arrived at the sought interval
break seek;

}

}

// prepare binary search on the right side of the index
right=pp.length;
break linear_scan;

}

//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){

// looping?

var t1global=pp[1];

if(t<t1global){

i1=2;// + 1, using the scan for the details
t0=t1global;

}

// linear reverse scan

for(var giveUpAt=i1-2;;){

if(t0===undefined){

// before start

this._cachedIndex=0;
return this.beforeStart_(0,t,t1);

}

if(i1===giveUpAt)break;// this loop

t1=t0;
t0=pp[--i1-1];

if(t>=t0){

// we have arrived at the sought interval
break seek;

}

}

// prepare binary search on the left side of the index
right=i1;
i1=0;
break linear_scan;

}

// the interval is valid

break validate_interval;

}// linear scan

// binary search

while(i1<right){

var mid=i1+right>>>1;

if(t<pp[mid]){

right=mid;

}else{

i1=mid+1;

}

}

t1=pp[i1];
t0=pp[i1-1];

// check boundary cases, again

if(t0===undefined){

this._cachedIndex=0;
return this.beforeStart_(0,t,t1);

}

if(t1===undefined){

i1=pp.length;
this._cachedIndex=i1;
return this.afterEnd_(i1-1,t0,t);

}

}// seek

this._cachedIndex=i1;

this.intervalChanged_(i1,t0,t1);

}// validate_interval

return this.interpolate_(i1,t0,t,t1);

},

settings:null,// optional, subclass-specific settings structure
// Note: The indirection allows central control of many interpolants.

// --- Protected interface

DefaultSettings_:{},

getSettings_:function getSettings_(){

return this.settings||this.DefaultSettings_;

},

copySampleValue_:function copySampleValue_(index){

// copies a sample value to the result buffer

var result=this.resultBuffer,
values=this.sampleValues,
stride=this.valueSize,
offset=index*stride;

for(var i=0;i!==stride;++i){

result[i]=values[offset+i];

}

return result;

},

// Template methods for derived classes:

interpolate_:function interpolate_()/* i1, t0, t, t1 */{

throw new Error('call to abstract method');
// implementations shall return this.resultBuffer

},

intervalChanged_:function intervalChanged_()/* i1, t0, t1 */{

// empty

}});



//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype,{

//( 0, t, t0 ), returns this.resultBuffer
beforeStart_:Interpolant.prototype.copySampleValue_,

//( N-1, tN-1, t ), returns this.resultBuffer
afterEnd_:Interpolant.prototype.copySampleValue_});



/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);

this._weightPrev=-0;
this._offsetPrev=-0;
this._weightNext=-0;
this._offsetNext=-0;

}

CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{

constructor:CubicInterpolant,

DefaultSettings_:{

endingStart:ZeroCurvatureEnding,
endingEnd:ZeroCurvatureEnding},



intervalChanged_:function intervalChanged_(i1,t0,t1){

var pp=this.parameterPositions,
iPrev=i1-2,
iNext=i1+1,

tPrev=pp[iPrev],
tNext=pp[iNext];

if(tPrev===undefined){

switch(this.getSettings_().endingStart){

case ZeroSlopeEnding:

// f'(t0) = 0
iPrev=i1;
tPrev=2*t0-t1;

break;

case WrapAroundEnding:

// use the other end of the curve
iPrev=pp.length-2;
tPrev=t0+pp[iPrev]-pp[iPrev+1];

break;

default:// ZeroCurvatureEnding

// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;
tPrev=t1;}



}

if(tNext===undefined){

switch(this.getSettings_().endingEnd){

case ZeroSlopeEnding:

// f'(tN) = 0
iNext=i1;
tNext=2*t1-t0;

break;

case WrapAroundEnding:

// use the other end of the curve
iNext=1;
tNext=t1+pp[1]-pp[0];

break;

default:// ZeroCurvatureEnding

// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;
tNext=t0;}



}

var halfDt=(t1-t0)*0.5,
stride=this.valueSize;

this._weightPrev=halfDt/(t0-tPrev);
this._weightNext=halfDt/(tNext-t1);
this._offsetPrev=iPrev*stride;
this._offsetNext=iNext*stride;

},

interpolate_:function interpolate_(i1,t0,t,t1){

var result=this.resultBuffer,
values=this.sampleValues,
stride=this.valueSize,

o1=i1*stride,o0=o1-stride,
oP=this._offsetPrev,oN=this._offsetNext,
wP=this._weightPrev,wN=this._weightNext,

p=(t-t0)/(t1-t0),
pp=p*p,
ppp=pp*p;

// evaluate polynomials

var sP=-wP*ppp+2*wP*pp-wP*p;
var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;
var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;
var sN=wN*ppp-wN*pp;

// combine data linearly

for(var i=0;i!==stride;++i){

result[i]=
sP*values[oP+i]+
s0*values[o0+i]+
s1*values[o1+i]+
sN*values[oN+i];

}

return result;

}});



/**
 * @author tschw
 */

function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);

}

LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{

constructor:LinearInterpolant,

interpolate_:function interpolate_(i1,t0,t,t1){

var result=this.resultBuffer,
values=this.sampleValues,
stride=this.valueSize,

offset1=i1*stride,
offset0=offset1-stride,

weight1=(t-t0)/(t1-t0),
weight0=1-weight1;

for(var i=0;i!==stride;++i){

result[i]=
values[offset0+i]*weight0+
values[offset1+i]*weight1;

}

return result;

}});



/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);

}

DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{

constructor:DiscreteInterpolant,

interpolate_:function interpolate_(i1/*, t0, t, t1 */){

return this.copySampleValue_(i1-1);

}});



/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack(name,times,values,interpolation){

if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');
if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);

this.name=name;

this.times=AnimationUtils.convertArray(times,this.TimeBufferType);
this.values=AnimationUtils.convertArray(values,this.ValueBufferType);

this.setInterpolation(interpolation||this.DefaultInterpolation);

}

// Static methods

Object.assign(KeyframeTrack,{

// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):

toJSON:function toJSON(track){

var trackType=track.constructor;

var json;

// derived classes can define a static toJSON method
if(trackType.toJSON!==undefined){

json=trackType.toJSON(track);

}else{

// by default, we assume the data can be serialized as-is
json={

'name':track.name,
'times':AnimationUtils.convertArray(track.times,Array),
'values':AnimationUtils.convertArray(track.values,Array)};



var interpolation=track.getInterpolation();

if(interpolation!==track.DefaultInterpolation){

json.interpolation=interpolation;

}

}

json.type=track.ValueTypeName;// mandatory

return json;

}});



Object.assign(KeyframeTrack.prototype,{

constructor:KeyframeTrack,

TimeBufferType:Float32Array,

ValueBufferType:Float32Array,

DefaultInterpolation:InterpolateLinear,

InterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){

return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);

},

InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){

return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);

},

InterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){

return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);

},

setInterpolation:function setInterpolation(interpolation){

var factoryMethod;

switch(interpolation){

case InterpolateDiscrete:

factoryMethod=this.InterpolantFactoryMethodDiscrete;

break;

case InterpolateLinear:

factoryMethod=this.InterpolantFactoryMethodLinear;

break;

case InterpolateSmooth:

factoryMethod=this.InterpolantFactoryMethodSmooth;

break;}



if(factoryMethod===undefined){

var message="unsupported interpolation for "+
this.ValueTypeName+" keyframe track named "+this.name;

if(this.createInterpolant===undefined){

// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){

this.setInterpolation(this.DefaultInterpolation);

}else{

throw new Error(message);// fatal, in this case

}

}

console.warn('THREE.KeyframeTrack:',message);
return this;

}

this.createInterpolant=factoryMethod;

return this;

},

getInterpolation:function getInterpolation(){

switch(this.createInterpolant){

case this.InterpolantFactoryMethodDiscrete:

return InterpolateDiscrete;

case this.InterpolantFactoryMethodLinear:

return InterpolateLinear;

case this.InterpolantFactoryMethodSmooth:

return InterpolateSmooth;}



},

getValueSize:function getValueSize(){

return this.values.length/this.times.length;

},

// move all keyframes either forwards or backwards in time
shift:function shift(timeOffset){

if(timeOffset!==0.0){

var times=this.times;

for(var i=0,n=times.length;i!==n;++i){

times[i]+=timeOffset;

}

}

return this;

},

// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale:function scale(timeScale){

if(timeScale!==1.0){

var times=this.times;

for(var i=0,n=times.length;i!==n;++i){

times[i]*=timeScale;

}

}

return this;

},

// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim:function trim(startTime,endTime){

var times=this.times,
nKeys=times.length,
from=0,
to=nKeys-1;

while(from!==nKeys&&times[from]<startTime){

++from;

}

while(to!==-1&&times[to]>endTime){

--to;

}

++to;// inclusive -> exclusive bound

if(from!==0||to!==nKeys){

// empty tracks are forbidden, so keep at least one keyframe
if(from>=to)to=Math.max(to,1),from=to-1;

var stride=this.getValueSize();
this.times=AnimationUtils.arraySlice(times,from,to);
this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);

}

return this;

},

// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate:function validate(){

var valid=true;

var valueSize=this.getValueSize();
if(valueSize-Math.floor(valueSize)!==0){

console.error('THREE.KeyframeTrack: Invalid value size in track.',this);
valid=false;

}

var times=this.times,
values=this.values,

nKeys=times.length;

if(nKeys===0){

console.error('THREE.KeyframeTrack: Track is empty.',this);
valid=false;

}

var prevTime=null;

for(var i=0;i!==nKeys;i++){

var currTime=times[i];

if(typeof currTime==='number'&&isNaN(currTime)){

console.error('THREE.KeyframeTrack: Time is not a valid number.',this,i,currTime);
valid=false;
break;

}

if(prevTime!==null&&prevTime>currTime){

console.error('THREE.KeyframeTrack: Out of order keys.',this,i,currTime,prevTime);
valid=false;
break;

}

prevTime=currTime;

}

if(values!==undefined){

if(AnimationUtils.isTypedArray(values)){

for(var i=0,n=values.length;i!==n;++i){

var value=values[i];

if(isNaN(value)){

console.error('THREE.KeyframeTrack: Value is not a valid number.',this,i,value);
valid=false;
break;

}

}

}

}

return valid;

},

// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize:function optimize(){

var times=this.times,
values=this.values,
stride=this.getValueSize(),

smoothInterpolation=this.getInterpolation()===InterpolateSmooth,

writeIndex=1,
lastIndex=times.length-1;

for(var i=1;i<lastIndex;++i){

var keep=false;

var time=times[i];
var timeNext=times[i+1];

// remove adjacent keyframes scheduled at the same time

if(time!==timeNext&&(i!==1||time!==time[0])){

if(!smoothInterpolation){

// remove unnecessary keyframes same as their neighbors

var offset=i*stride,
offsetP=offset-stride,
offsetN=offset+stride;

for(var j=0;j!==stride;++j){

var value=values[offset+j];

if(value!==values[offsetP+j]||
value!==values[offsetN+j]){

keep=true;
break;

}

}

}else{

keep=true;

}

}

// in-place compaction

if(keep){

if(i!==writeIndex){

times[writeIndex]=times[i];

var readOffset=i*stride,
writeOffset=writeIndex*stride;

for(var j=0;j!==stride;++j){

values[writeOffset+j]=values[readOffset+j];

}

}

++writeIndex;

}

}

// flush last keyframe (compaction looks ahead)

if(lastIndex>0){

times[writeIndex]=times[lastIndex];

for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){

values[writeOffset+j]=values[readOffset+j];

}

++writeIndex;

}

if(writeIndex!==times.length){

this.times=AnimationUtils.arraySlice(times,0,writeIndex);
this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);

}

return this;

},

clone:function clone(){

var times=AnimationUtils.arraySlice(this.times,0);
var values=AnimationUtils.arraySlice(this.values,0);

var TypedKeyframeTrack=this.constructor;
var track=new TypedKeyframeTrack(this.name,times,values);

// Interpolant argument to constructor is not saved, so copy the factory method directly.
track.createInterpolant=this.createInterpolant;

return track;

}});



/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack(name,times,values){

KeyframeTrack.call(this,name,times,values);

}

BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:BooleanKeyframeTrack,

ValueTypeName:'bool',
ValueBufferType:Array,

DefaultInterpolation:InterpolateDiscrete,

InterpolantFactoryMethodLinear:undefined,
InterpolantFactoryMethodSmooth:undefined

// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".
});


/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack(name,times,values,interpolation){

KeyframeTrack.call(this,name,times,values,interpolation);

}

ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:ColorKeyframeTrack,

ValueTypeName:'color'

// ValueBufferType is inherited

// DefaultInterpolation is inherited

// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.
});


/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack(name,times,values,interpolation){

KeyframeTrack.call(this,name,times,values,interpolation);

}

NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:NumberKeyframeTrack,

ValueTypeName:'number'

// ValueBufferType is inherited

// DefaultInterpolation is inherited
});


/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);

}

QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{

constructor:QuaternionLinearInterpolant,

interpolate_:function interpolate_(i1,t0,t,t1){

var result=this.resultBuffer,
values=this.sampleValues,
stride=this.valueSize,

offset=i1*stride,

alpha=(t-t0)/(t1-t0);

for(var end=offset+stride;offset!==end;offset+=4){

Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);

}

return result;

}});



/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack(name,times,values,interpolation){

KeyframeTrack.call(this,name,times,values,interpolation);

}

QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:QuaternionKeyframeTrack,

ValueTypeName:'quaternion',

// ValueBufferType is inherited

DefaultInterpolation:InterpolateLinear,

InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){

return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);

},

InterpolantFactoryMethodSmooth:undefined// not yet implemented
});


/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack(name,times,values,interpolation){

KeyframeTrack.call(this,name,times,values,interpolation);

}

StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:StringKeyframeTrack,

ValueTypeName:'string',
ValueBufferType:Array,

DefaultInterpolation:InterpolateDiscrete,

InterpolantFactoryMethodLinear:undefined,

InterpolantFactoryMethodSmooth:undefined});



/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack(name,times,values,interpolation){

KeyframeTrack.call(this,name,times,values,interpolation);

}

VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrack.prototype),{

constructor:VectorKeyframeTrack,

ValueTypeName:'vector'

// ValueBufferType is inherited

// DefaultInterpolation is inherited
});


/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip(name,duration,tracks){

this.name=name;
this.tracks=tracks;
this.duration=duration!==undefined?duration:-1;

this.uuid=_Math.generateUUID();

// this means it should figure out its duration by scanning the tracks
if(this.duration<0){

this.resetDuration();

}

}

function getTrackTypeForValueTypeName(typeName){

switch(typeName.toLowerCase()){

case'scalar':
case'double':
case'float':
case'number':
case'integer':

return NumberKeyframeTrack;

case'vector':
case'vector2':
case'vector3':
case'vector4':

return VectorKeyframeTrack;

case'color':

return ColorKeyframeTrack;

case'quaternion':

return QuaternionKeyframeTrack;

case'bool':
case'boolean':

return BooleanKeyframeTrack;

case'string':

return StringKeyframeTrack;}



throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);

}

function parseKeyframeTrack(json){

if(json.type===undefined){

throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');

}

var trackType=getTrackTypeForValueTypeName(json.type);

if(json.times===undefined){

var times=[],values=[];

AnimationUtils.flattenJSON(json.keys,times,values,'value');

json.times=times;
json.values=values;

}

// derived classes can define a static parse method
if(trackType.parse!==undefined){

return trackType.parse(json);

}else{

// by default, we assume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);

}

}

Object.assign(AnimationClip,{

parse:function parse(json){

var tracks=[],
jsonTracks=json.tracks,
frameTime=1.0/(json.fps||1.0);

for(var i=0,n=jsonTracks.length;i!==n;++i){

tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));

}

return new AnimationClip(json.name,json.duration,tracks);

},

toJSON:function toJSON(clip){

var tracks=[],
clipTracks=clip.tracks;

var json={

'name':clip.name,
'duration':clip.duration,
'tracks':tracks,
'uuid':clip.uuid};



for(var i=0,n=clipTracks.length;i!==n;++i){

tracks.push(KeyframeTrack.toJSON(clipTracks[i]));

}

return json;

},

CreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){

var numMorphTargets=morphTargetSequence.length;
var tracks=[];

for(var i=0;i<numMorphTargets;i++){

var times=[];
var values=[];

times.push(
(i+numMorphTargets-1)%numMorphTargets,
i,
(i+1)%numMorphTargets);

values.push(0,1,0);

var order=AnimationUtils.getKeyframeOrder(times);
times=AnimationUtils.sortedArray(times,1,order);
values=AnimationUtils.sortedArray(values,1,order);

// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){

times.push(numMorphTargets);
values.push(values[0]);

}

tracks.push(
new NumberKeyframeTrack(
'.morphTargetInfluences['+morphTargetSequence[i].name+']',
times,values).
scale(1.0/fps));

}

return new AnimationClip(name,-1,tracks);

},

findByName:function findByName(objectOrClipArray,name){

var clipArray=objectOrClipArray;

if(!Array.isArray(objectOrClipArray)){

var o=objectOrClipArray;
clipArray=o.geometry&&o.geometry.animations||o.animations;

}

for(var i=0;i<clipArray.length;i++){

if(clipArray[i].name===name){

return clipArray[i];

}

}

return null;

},

CreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){

var animationToMorphTargets={};

// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
var pattern=/^([\w-]*?)([\d]+)$/;

// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(var i=0,il=morphTargets.length;i<il;i++){

var morphTarget=morphTargets[i];
var parts=morphTarget.name.match(pattern);

if(parts&&parts.length>1){

var name=parts[1];

var animationMorphTargets=animationToMorphTargets[name];
if(!animationMorphTargets){

animationToMorphTargets[name]=animationMorphTargets=[];

}

animationMorphTargets.push(morphTarget);

}

}

var clips=[];

for(var name in animationToMorphTargets){

clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));

}

return clips;

},

// parse the animation.hierarchy format
parseAnimation:function parseAnimation(animation,bones){

if(!animation){

console.error('THREE.AnimationClip: No animation in JSONLoader data.');
return null;

}

var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){

// only return track if there are actually keys.
if(animationKeys.length!==0){

var times=[];
var values=[];

AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);

// empty keys are filtered out, so check again
if(times.length!==0){

destTracks.push(new trackType(trackName,times,values));

}

}

};

var tracks=[];

var clipName=animation.name||'default';
// automatic length determination in AnimationClip.
var duration=animation.length||-1;
var fps=animation.fps||30;

var hierarchyTracks=animation.hierarchy||[];

for(var h=0;h<hierarchyTracks.length;h++){

var animationKeys=hierarchyTracks[h].keys;

// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;

// process morph targets
if(animationKeys[0].morphTargets){

// figure out all morph targets used in this track
var morphTargetNames={};

for(var k=0;k<animationKeys.length;k++){

if(animationKeys[k].morphTargets){

for(var m=0;m<animationKeys[k].morphTargets.length;m++){

morphTargetNames[animationKeys[k].morphTargets[m]]=-1;

}

}

}

// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(var morphTargetName in morphTargetNames){

var times=[];
var values=[];

for(var m=0;m!==animationKeys[k].morphTargets.length;++m){

var animationKey=animationKeys[k];

times.push(animationKey.time);
values.push(animationKey.morphTarget===morphTargetName?1:0);

}

tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));

}

duration=morphTargetNames.length*(fps||1.0);

}else{

// ...assume skeletal animation

var boneName='.bones['+bones[h].name+']';

addNonemptyTrack(
VectorKeyframeTrack,boneName+'.position',
animationKeys,'pos',tracks);

addNonemptyTrack(
QuaternionKeyframeTrack,boneName+'.quaternion',
animationKeys,'rot',tracks);

addNonemptyTrack(
VectorKeyframeTrack,boneName+'.scale',
animationKeys,'scl',tracks);

}

}

if(tracks.length===0){

return null;

}

var clip=new AnimationClip(clipName,duration,tracks);

return clip;

}});



Object.assign(AnimationClip.prototype,{

resetDuration:function resetDuration(){

var tracks=this.tracks,duration=0;

for(var i=0,n=tracks.length;i!==n;++i){

var track=this.tracks[i];

duration=Math.max(duration,track.times[track.times.length-1]);

}

this.duration=duration;

return this;

},

trim:function trim(){

for(var i=0;i<this.tracks.length;i++){

this.tracks[i].trim(0,this.duration);

}

return this;

},

validate:function validate(){

var valid=true;

for(var i=0;i<this.tracks.length;i++){

valid=valid&&this.tracks[i].validate();

}

return valid;

},

optimize:function optimize(){

for(var i=0;i<this.tracks.length;i++){

this.tracks[i].optimize();

}

return this;

},


clone:function clone(){

var tracks=[];

for(var i=0;i<this.tracks.length;i++){

tracks.push(this.tracks[i].clone());

}

return new AnimationClip(this.name,this.duration,tracks);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache={

enabled:false,

files:{},

add:function add(key,file){

if(this.enabled===false)return;

// console.log( 'THREE.Cache', 'Adding key:', key );

this.files[key]=file;

},

get:function get(key){

if(this.enabled===false)return;

// console.log( 'THREE.Cache', 'Checking key:', key );

return this.files[key];

},

remove:function remove(key){

delete this.files[key];

},

clear:function clear(){

this.files={};

}};



/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager(onLoad,onProgress,onError){

var scope=this;

var isLoading=false;
var itemsLoaded=0;
var itemsTotal=0;
var urlModifier=undefined;

// Refer to #5689 for the reason why we don't set .onStart
// in the constructor

this.onStart=undefined;
this.onLoad=onLoad;
this.onProgress=onProgress;
this.onError=onError;

this.itemStart=function(url){

itemsTotal++;

if(isLoading===false){

if(scope.onStart!==undefined){

scope.onStart(url,itemsLoaded,itemsTotal);

}

}

isLoading=true;

};

this.itemEnd=function(url){

itemsLoaded++;

if(scope.onProgress!==undefined){

scope.onProgress(url,itemsLoaded,itemsTotal);

}

if(itemsLoaded===itemsTotal){

isLoading=false;

if(scope.onLoad!==undefined){

scope.onLoad();

}

}

};

this.itemError=function(url){

if(scope.onError!==undefined){

scope.onError(url);

}

};

this.resolveURL=function(url){

if(urlModifier){

return urlModifier(url);

}

return url;

};

this.setURLModifier=function(transform){

urlModifier=transform;
return this;

};

}

var DefaultLoadingManager=new LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

var loading={};

function FileLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(FileLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

if(url===undefined)url='';

if(this.path!==undefined)url=this.path+url;

url=this.manager.resolveURL(url);

var scope=this;

var cached=Cache.get(url);

if(cached!==undefined){

scope.manager.itemStart(url);

setTimeout(function(){

if(onLoad)onLoad(cached);

scope.manager.itemEnd(url);

},0);

return cached;

}

// Check if request is duplicate

if(loading[url]!==undefined){

loading[url].push({

onLoad:onLoad,
onProgress:onProgress,
onError:onError});



return;

}

// Check for data: URI
var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;
var dataUriRegexResult=url.match(dataUriRegex);

// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){

var mimeType=dataUriRegexResult[1];
var isBase64=!!dataUriRegexResult[2];
var data=dataUriRegexResult[3];

data=decodeURIComponent(data);

if(isBase64)data=atob(data);

try{

var response;
var responseType=(this.responseType||'').toLowerCase();

switch(responseType){

case'arraybuffer':
case'blob':

var view=new Uint8Array(data.length);

for(var i=0;i<data.length;i++){

view[i]=data.charCodeAt(i);

}

if(responseType==='blob'){

response=new Blob([view.buffer],{type:mimeType});

}else{

response=view.buffer;

}

break;

case'document':

var parser=new DOMParser();
response=parser.parseFromString(data,mimeType);

break;

case'json':

response=JSON.parse(data);

break;

default:// 'text' or other

response=data;

break;}



// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){

if(onLoad)onLoad(response);

scope.manager.itemEnd(url);

},0);

}catch(error){

// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){

if(onError)onError(error);

scope.manager.itemError(url);
scope.manager.itemEnd(url);

},0);

}

}else{

// Initialise array for duplicate requests

loading[url]=[];

loading[url].push({

onLoad:onLoad,
onProgress:onProgress,
onError:onError});



var request=new XMLHttpRequest();

request.open('GET',url,true);

request.addEventListener('load',function(event){

var response=this.response;

Cache.add(url,response);

var callbacks=loading[url];

delete loading[url];

if(this.status===200||this.status===0){

// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.

if(this.status===0)console.warn('THREE.FileLoader: HTTP Status 0 received.');

for(var i=0,il=callbacks.length;i<il;i++){

var callback=callbacks[i];
if(callback.onLoad)callback.onLoad(response);

}

scope.manager.itemEnd(url);

}else{

for(var i=0,il=callbacks.length;i<il;i++){

var callback=callbacks[i];
if(callback.onError)callback.onError(event);

}

scope.manager.itemError(url);
scope.manager.itemEnd(url);

}

},false);

request.addEventListener('progress',function(event){

var callbacks=loading[url];

for(var i=0,il=callbacks.length;i<il;i++){

var callback=callbacks[i];
if(callback.onProgress)callback.onProgress(event);

}

},false);

request.addEventListener('error',function(event){

var callbacks=loading[url];

delete loading[url];

for(var i=0,il=callbacks.length;i<il;i++){

var callback=callbacks[i];
if(callback.onError)callback.onError(event);

}

scope.manager.itemError(url);
scope.manager.itemEnd(url);

},false);

request.addEventListener('abort',function(event){

var callbacks=loading[url];

delete loading[url];

for(var i=0,il=callbacks.length;i<il;i++){

var callback=callbacks[i];
if(callback.onError)callback.onError(event);

}

scope.manager.itemError(url);
scope.manager.itemEnd(url);

},false);

if(this.responseType!==undefined)request.responseType=this.responseType;
if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;

if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');

for(var header in this.requestHeader){

request.setRequestHeader(header,this.requestHeader[header]);

}

request.send(null);

}

scope.manager.itemStart(url);

return request;

},

setPath:function setPath(value){

this.path=value;
return this;

},

setResponseType:function setResponseType(value){

this.responseType=value;
return this;

},

setWithCredentials:function setWithCredentials(value){

this.withCredentials=value;
return this;

},

setMimeType:function setMimeType(value){

this.mimeType=value;
return this;

},

setRequestHeader:function setRequestHeader(value){

this.requestHeader=value;
return this;

}});



/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(AnimationLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(scope.manager);
loader.setPath(scope.path);
loader.load(url,function(text){

onLoad(scope.parse(JSON.parse(text)));

},onProgress,onError);

},

parse:function parse(json){

var animations=[];

for(var i=0;i<json.length;i++){

var clip=AnimationClip.parse(json[i]);

animations.push(clip);

}

return animations;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

// override in sub classes
this._parser=null;

}

Object.assign(CompressedTextureLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var images=[];

var texture=new CompressedTexture();
texture.image=images;

var loader=new FileLoader(this.manager);
loader.setPath(this.path);
loader.setResponseType('arraybuffer');

function loadTexture(i){

loader.load(url[i],function(buffer){

var texDatas=scope._parser(buffer,true);

images[i]={
width:texDatas.width,
height:texDatas.height,
format:texDatas.format,
mipmaps:texDatas.mipmaps};


loaded+=1;

if(loaded===6){

if(texDatas.mipmapCount===1)
texture.minFilter=LinearFilter;

texture.format=texDatas.format;
texture.needsUpdate=true;

if(onLoad)onLoad(texture);

}

},onProgress,onError);

}

if(Array.isArray(url)){

var loaded=0;

for(var i=0,il=url.length;i<il;++i){

loadTexture(i);

}

}else{

// compressed cubemap texture stored in a single DDS file

loader.load(url,function(buffer){

var texDatas=scope._parser(buffer,true);

if(texDatas.isCubemap){

var faces=texDatas.mipmaps.length/texDatas.mipmapCount;

for(var f=0;f<faces;f++){

images[f]={mipmaps:[]};

for(var i=0;i<texDatas.mipmapCount;i++){

images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);
images[f].format=texDatas.format;
images[f].width=texDatas.width;
images[f].height=texDatas.height;

}

}

}else{

texture.image.width=texDatas.width;
texture.image.height=texDatas.height;
texture.mipmaps=texDatas.mipmaps;

}

if(texDatas.mipmapCount===1){

texture.minFilter=LinearFilter;

}

texture.format=texDatas.format;
texture.needsUpdate=true;

if(onLoad)onLoad(texture);

},onProgress,onError);

}

return texture;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

function DataTextureLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

// override in sub classes
this._parser=null;

}

Object.assign(DataTextureLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var texture=new DataTexture();

var loader=new FileLoader(this.manager);
loader.setResponseType('arraybuffer');
loader.setPath(this.path);
loader.load(url,function(buffer){

var texData=scope._parser(buffer);

if(!texData)return;

if(texData.image!==undefined){

texture.image=texData.image;

}else if(texData.data!==undefined){

texture.image.width=texData.width;
texture.image.height=texData.height;
texture.image.data=texData.data;

}

texture.wrapS=texData.wrapS!==undefined?texData.wrapS:ClampToEdgeWrapping;
texture.wrapT=texData.wrapT!==undefined?texData.wrapT:ClampToEdgeWrapping;

texture.magFilter=texData.magFilter!==undefined?texData.magFilter:LinearFilter;
texture.minFilter=texData.minFilter!==undefined?texData.minFilter:LinearMipMapLinearFilter;

texture.anisotropy=texData.anisotropy!==undefined?texData.anisotropy:1;

if(texData.format!==undefined){

texture.format=texData.format;

}
if(texData.type!==undefined){

texture.type=texData.type;

}

if(texData.mipmaps!==undefined){

texture.mipmaps=texData.mipmaps;

}

if(texData.mipmapCount===1){

texture.minFilter=LinearFilter;

}

texture.needsUpdate=true;

if(onLoad)onLoad(texture,texData);

},onProgress,onError);


return texture;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */


function ImageLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(ImageLoader.prototype,{

crossOrigin:'anonymous',

load:function load(url,onLoad,onProgress,onError){

if(url===undefined)url='';

if(this.path!==undefined)url=this.path+url;

url=this.manager.resolveURL(url);

var scope=this;

var cached=Cache.get(url);

if(cached!==undefined){

scope.manager.itemStart(url);

setTimeout(function(){

if(onLoad)onLoad(cached);

scope.manager.itemEnd(url);

},0);

return cached;

}

var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');

function onImageLoad(){

image.removeEventListener('load',onImageLoad,false);
image.removeEventListener('error',onImageError,false);

Cache.add(url,this);

if(onLoad)onLoad(this);

scope.manager.itemEnd(url);

}

function onImageError(event){

image.removeEventListener('load',onImageLoad,false);
image.removeEventListener('error',onImageError,false);

if(onError)onError(event);

scope.manager.itemError(url);
scope.manager.itemEnd(url);

}

image.addEventListener('load',onImageLoad,false);
image.addEventListener('error',onImageError,false);

if(url.substr(0,5)!=='data:'){

if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;

}

scope.manager.itemStart(url);

image.src=url;

return image;

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTextureLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(CubeTextureLoader.prototype,{

crossOrigin:'anonymous',

load:function load(urls,onLoad,onProgress,onError){

var texture=new CubeTexture();

var loader=new ImageLoader(this.manager);
loader.setCrossOrigin(this.crossOrigin);
loader.setPath(this.path);

var loaded=0;

function loadTexture(i){

loader.load(urls[i],function(image){

texture.images[i]=image;

loaded++;

if(loaded===6){

texture.needsUpdate=true;

if(onLoad)onLoad(texture);

}

},undefined,onError);

}

for(var i=0;i<urls.length;++i){

loadTexture(i);

}

return texture;

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */


function TextureLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(TextureLoader.prototype,{

crossOrigin:'anonymous',

load:function load(url,onLoad,onProgress,onError){

var texture=new Texture();

var loader=new ImageLoader(this.manager);
loader.setCrossOrigin(this.crossOrigin);
loader.setPath(this.path);

loader.load(url,function(image){

texture.image=image;

// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
var isJPEG=url.search(/\.jpe?g($|\?)/i)>0||url.search(/^data\:image\/jpeg/)===0;

texture.format=isJPEG?RGBFormat:RGBAFormat;
texture.needsUpdate=true;

if(onLoad!==undefined){

onLoad(texture);

}

},onProgress,onError);

return texture;

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve(){

this.type='Curve';

this.arcLengthDivisions=200;

}

Object.assign(Curve.prototype,{

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

getPoint:function getPoint()/* t, optionalTarget */{

console.warn('THREE.Curve: .getPoint() not implemented.');
return null;

},

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

getPointAt:function getPointAt(u,optionalTarget){

var t=this.getUtoTmapping(u);
return this.getPoint(t,optionalTarget);

},

// Get sequence of points using getPoint( t )

getPoints:function getPoints(divisions){

if(divisions===undefined)divisions=5;

var points=[];

for(var d=0;d<=divisions;d++){

points.push(this.getPoint(d/divisions));

}

return points;

},

// Get sequence of points using getPointAt( u )

getSpacedPoints:function getSpacedPoints(divisions){

if(divisions===undefined)divisions=5;

var points=[];

for(var d=0;d<=divisions;d++){

points.push(this.getPointAt(d/divisions));

}

return points;

},

// Get total curve arc length

getLength:function getLength(){

var lengths=this.getLengths();
return lengths[lengths.length-1];

},

// Get list of cumulative segment lengths

getLengths:function getLengths(divisions){

if(divisions===undefined)divisions=this.arcLengthDivisions;

if(this.cacheArcLengths&&
this.cacheArcLengths.length===divisions+1&&
!this.needsUpdate){

return this.cacheArcLengths;

}

this.needsUpdate=false;

var cache=[];
var current,last=this.getPoint(0);
var p,sum=0;

cache.push(0);

for(p=1;p<=divisions;p++){

current=this.getPoint(p/divisions);
sum+=current.distanceTo(last);
cache.push(sum);
last=current;

}

this.cacheArcLengths=cache;

return cache;// { sums: cache, sum: sum }; Sum is in the last element.

},

updateArcLengths:function updateArcLengths(){

this.needsUpdate=true;
this.getLengths();

},

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

getUtoTmapping:function getUtoTmapping(u,distance){

var arcLengths=this.getLengths();

var i=0,il=arcLengths.length;

var targetArcLength;// The targeted u distance value to get

if(distance){

targetArcLength=distance;

}else{

targetArcLength=u*arcLengths[il-1];

}

// binary search for the index with largest value smaller than target u distance

var low=0,high=il-1,comparison;

while(low<=high){

i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

comparison=arcLengths[i]-targetArcLength;

if(comparison<0){

low=i+1;

}else if(comparison>0){

high=i-1;

}else{

high=i;
break;

// DONE

}

}

i=high;

if(arcLengths[i]===targetArcLength){

return i/(il-1);

}

// we could get finer grain at lengths, or use simple interpolation between two points

var lengthBefore=arcLengths[i];
var lengthAfter=arcLengths[i+1];

var segmentLength=lengthAfter-lengthBefore;

// determine where we are between the 'before' and 'after' points

var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;

// add that fractional amount to t

var t=(i+segmentFraction)/(il-1);

return t;

},

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

getTangent:function getTangent(t){

var delta=0.0001;
var t1=t-delta;
var t2=t+delta;

// Capping in case of danger

if(t1<0)t1=0;
if(t2>1)t2=1;

var pt1=this.getPoint(t1);
var pt2=this.getPoint(t2);

var vec=pt2.clone().sub(pt1);
return vec.normalize();

},

getTangentAt:function getTangentAt(u){

var t=this.getUtoTmapping(u);
return this.getTangent(t);

},

computeFrenetFrames:function computeFrenetFrames(segments,closed){

// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

var normal=new Vector3();

var tangents=[];
var normals=[];
var binormals=[];

var vec=new Vector3();
var mat=new Matrix4();

var i,u,theta;

// compute the tangent vectors for each segment on the curve

for(i=0;i<=segments;i++){

u=i/segments;

tangents[i]=this.getTangentAt(u);
tangents[i].normalize();

}

// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component

normals[0]=new Vector3();
binormals[0]=new Vector3();
var min=Number.MAX_VALUE;
var tx=Math.abs(tangents[0].x);
var ty=Math.abs(tangents[0].y);
var tz=Math.abs(tangents[0].z);

if(tx<=min){

min=tx;
normal.set(1,0,0);

}

if(ty<=min){

min=ty;
normal.set(0,1,0);

}

if(tz<=min){

normal.set(0,0,1);

}

vec.crossVectors(tangents[0],normal).normalize();

normals[0].crossVectors(tangents[0],vec);
binormals[0].crossVectors(tangents[0],normals[0]);


// compute the slowly-varying normal and binormal vectors for each segment on the curve

for(i=1;i<=segments;i++){

normals[i]=normals[i-1].clone();

binormals[i]=binormals[i-1].clone();

vec.crossVectors(tangents[i-1],tangents[i]);

if(vec.length()>Number.EPSILON){

vec.normalize();

theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors

normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));

}

binormals[i].crossVectors(tangents[i],normals[i]);

}

// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

if(closed===true){

theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));
theta/=segments;

if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){

theta=-theta;

}

for(i=1;i<=segments;i++){

// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));
binormals[i].crossVectors(tangents[i],normals[i]);

}

}

return{
tangents:tangents,
normals:normals,
binormals:binormals};


},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(source){

this.arcLengthDivisions=source.arcLengthDivisions;

return this;

},

toJSON:function toJSON(){

var data={
metadata:{
version:4.5,
type:'Curve',
generator:'Curve.toJSON'}};



data.arcLengthDivisions=this.arcLengthDivisions;
data.type=this.type;

return data;

},

fromJSON:function fromJSON(json){

this.arcLengthDivisions=json.arcLengthDivisions;

return this;

}});



function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){

Curve.call(this);

this.type='EllipseCurve';

this.aX=aX||0;
this.aY=aY||0;

this.xRadius=xRadius||1;
this.yRadius=yRadius||1;

this.aStartAngle=aStartAngle||0;
this.aEndAngle=aEndAngle||2*Math.PI;

this.aClockwise=aClockwise||false;

this.aRotation=aRotation||0;

}

EllipseCurve.prototype=Object.create(Curve.prototype);
EllipseCurve.prototype.constructor=EllipseCurve;

EllipseCurve.prototype.isEllipseCurve=true;

EllipseCurve.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector2();

var twoPi=Math.PI*2;
var deltaAngle=this.aEndAngle-this.aStartAngle;
var samePoints=Math.abs(deltaAngle)<Number.EPSILON;

// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0){deltaAngle+=twoPi;}
while(deltaAngle>twoPi){deltaAngle-=twoPi;}

if(deltaAngle<Number.EPSILON){

if(samePoints){

deltaAngle=0;

}else{

deltaAngle=twoPi;

}

}

if(this.aClockwise===true&&!samePoints){

if(deltaAngle===twoPi){

deltaAngle=-twoPi;

}else{

deltaAngle=deltaAngle-twoPi;

}

}

var angle=this.aStartAngle+t*deltaAngle;
var x=this.aX+this.xRadius*Math.cos(angle);
var y=this.aY+this.yRadius*Math.sin(angle);

if(this.aRotation!==0){

var cos=Math.cos(this.aRotation);
var sin=Math.sin(this.aRotation);

var tx=x-this.aX;
var ty=y-this.aY;

// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;
y=tx*sin+ty*cos+this.aY;

}

return point.set(x,y);

};

EllipseCurve.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.aX=source.aX;
this.aY=source.aY;

this.xRadius=source.xRadius;
this.yRadius=source.yRadius;

this.aStartAngle=source.aStartAngle;
this.aEndAngle=source.aEndAngle;

this.aClockwise=source.aClockwise;

this.aRotation=source.aRotation;

return this;

};


EllipseCurve.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.aX=this.aX;
data.aY=this.aY;

data.xRadius=this.xRadius;
data.yRadius=this.yRadius;

data.aStartAngle=this.aStartAngle;
data.aEndAngle=this.aEndAngle;

data.aClockwise=this.aClockwise;

data.aRotation=this.aRotation;

return data;

};

EllipseCurve.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.aX=json.aX;
this.aY=json.aY;

this.xRadius=json.xRadius;
this.yRadius=json.yRadius;

this.aStartAngle=json.aStartAngle;
this.aEndAngle=json.aEndAngle;

this.aClockwise=json.aClockwise;

this.aRotation=json.aRotation;

return this;

};

function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){

EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);

this.type='ArcCurve';

}

ArcCurve.prototype=Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor=ArcCurve;

ArcCurve.prototype.isArcCurve=true;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly(){

var c0=0,c1=0,c2=0,c3=0;

/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
function init(x0,x1,t0,t1){

c0=x0;
c1=t0;
c2=-3*x0+3*x1-2*t0-t1;
c3=2*x0-2*x1+t0+t1;

}

return{

initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){

init(x1,x2,tension*(x2-x0),tension*(x3-x1));

},

initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){

// compute tangents when parameterized in [t1,t2]
var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;
var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;

// rescale tangents for parametrization in [0,1]
t1*=dt1;
t2*=dt1;

init(x1,x2,t1,t2);

},

calc:function calc(t){

var t2=t*t;
var t3=t2*t;
return c0+c1*t+c2*t2+c3*t3;

}};



}

//

var tmp=new Vector3();
var px=new CubicPoly(),py=new CubicPoly(),pz=new CubicPoly();

function CatmullRomCurve3(points,closed,curveType,tension){

Curve.call(this);

this.type='CatmullRomCurve3';

this.points=points||[];
this.closed=closed||false;
this.curveType=curveType||'centripetal';
this.tension=tension||0.5;

}

CatmullRomCurve3.prototype=Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;

CatmullRomCurve3.prototype.isCatmullRomCurve3=true;

CatmullRomCurve3.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector3();

var points=this.points;
var l=points.length;

var p=(l-(this.closed?0:1))*t;
var intPoint=Math.floor(p);
var weight=p-intPoint;

if(this.closed){

intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;

}else if(weight===0&&intPoint===l-1){

intPoint=l-2;
weight=1;

}

var p0,p1,p2,p3;// 4 points

if(this.closed||intPoint>0){

p0=points[(intPoint-1)%l];

}else{

// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);
p0=tmp;

}

p1=points[intPoint%l];
p2=points[(intPoint+1)%l];

if(this.closed||intPoint+2<l){

p3=points[(intPoint+2)%l];

}else{

// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);
p3=tmp;

}

if(this.curveType==='centripetal'||this.curveType==='chordal'){

// init Centripetal / Chordal Catmull-Rom
var pow=this.curveType==='chordal'?0.5:0.25;
var dt0=Math.pow(p0.distanceToSquared(p1),pow);
var dt1=Math.pow(p1.distanceToSquared(p2),pow);
var dt2=Math.pow(p2.distanceToSquared(p3),pow);

// safety check for repeated points
if(dt1<1e-4)dt1=1.0;
if(dt0<1e-4)dt0=dt1;
if(dt2<1e-4)dt2=dt1;

px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);
py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);
pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);

}else if(this.curveType==='catmullrom'){

px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);
py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);
pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);

}

point.set(
px.calc(weight),
py.calc(weight),
pz.calc(weight));


return point;

};

CatmullRomCurve3.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.points=[];

for(var i=0,l=source.points.length;i<l;i++){

var point=source.points[i];

this.points.push(point.clone());

}

this.closed=source.closed;
this.curveType=source.curveType;
this.tension=source.tension;

return this;

};

CatmullRomCurve3.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.points=[];

for(var i=0,l=this.points.length;i<l;i++){

var point=this.points[i];
data.points.push(point.toArray());

}

data.closed=this.closed;
data.curveType=this.curveType;
data.tension=this.tension;

return data;

};

CatmullRomCurve3.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.points=[];

for(var i=0,l=json.points.length;i<l;i++){

var point=json.points[i];
this.points.push(new Vector3().fromArray(point));

}

this.closed=json.closed;
this.curveType=json.curveType;
this.tension=json.tension;

return this;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom(t,p0,p1,p2,p3){

var v0=(p2-p0)*0.5;
var v1=(p3-p1)*0.5;
var t2=t*t;
var t3=t*t2;
return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;

}

//

function QuadraticBezierP0(t,p){

var k=1-t;
return k*k*p;

}

function QuadraticBezierP1(t,p){

return 2*(1-t)*t*p;

}

function QuadraticBezierP2(t,p){

return t*t*p;

}

function QuadraticBezier(t,p0,p1,p2){

return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+
QuadraticBezierP2(t,p2);

}

//

function CubicBezierP0(t,p){

var k=1-t;
return k*k*k*p;

}

function CubicBezierP1(t,p){

var k=1-t;
return 3*k*k*t*p;

}

function CubicBezierP2(t,p){

return 3*(1-t)*t*t*p;

}

function CubicBezierP3(t,p){

return t*t*t*p;

}

function CubicBezier(t,p0,p1,p2,p3){

return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+
CubicBezierP3(t,p3);

}

function CubicBezierCurve(v0,v1,v2,v3){

Curve.call(this);

this.type='CubicBezierCurve';

this.v0=v0||new Vector2();
this.v1=v1||new Vector2();
this.v2=v2||new Vector2();
this.v3=v3||new Vector2();

}

CubicBezierCurve.prototype=Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor=CubicBezierCurve;

CubicBezierCurve.prototype.isCubicBezierCurve=true;

CubicBezierCurve.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector2();

var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;

point.set(
CubicBezier(t,v0.x,v1.x,v2.x,v3.x),
CubicBezier(t,v0.y,v1.y,v2.y,v3.y));


return point;

};

CubicBezierCurve.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v0.copy(source.v0);
this.v1.copy(source.v1);
this.v2.copy(source.v2);
this.v3.copy(source.v3);

return this;

};

CubicBezierCurve.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v0=this.v0.toArray();
data.v1=this.v1.toArray();
data.v2=this.v2.toArray();
data.v3=this.v3.toArray();

return data;

};

CubicBezierCurve.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v0.fromArray(json.v0);
this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);
this.v3.fromArray(json.v3);

return this;

};

function CubicBezierCurve3(v0,v1,v2,v3){

Curve.call(this);

this.type='CubicBezierCurve3';

this.v0=v0||new Vector3();
this.v1=v1||new Vector3();
this.v2=v2||new Vector3();
this.v3=v3||new Vector3();

}

CubicBezierCurve3.prototype=Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;

CubicBezierCurve3.prototype.isCubicBezierCurve3=true;

CubicBezierCurve3.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector3();

var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;

point.set(
CubicBezier(t,v0.x,v1.x,v2.x,v3.x),
CubicBezier(t,v0.y,v1.y,v2.y,v3.y),
CubicBezier(t,v0.z,v1.z,v2.z,v3.z));


return point;

};

CubicBezierCurve3.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v0.copy(source.v0);
this.v1.copy(source.v1);
this.v2.copy(source.v2);
this.v3.copy(source.v3);

return this;

};

CubicBezierCurve3.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v0=this.v0.toArray();
data.v1=this.v1.toArray();
data.v2=this.v2.toArray();
data.v3=this.v3.toArray();

return data;

};

CubicBezierCurve3.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v0.fromArray(json.v0);
this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);
this.v3.fromArray(json.v3);

return this;

};

function LineCurve(v1,v2){

Curve.call(this);

this.type='LineCurve';

this.v1=v1||new Vector2();
this.v2=v2||new Vector2();

}

LineCurve.prototype=Object.create(Curve.prototype);
LineCurve.prototype.constructor=LineCurve;

LineCurve.prototype.isLineCurve=true;

LineCurve.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector2();

if(t===1){

point.copy(this.v2);

}else{

point.copy(this.v2).sub(this.v1);
point.multiplyScalar(t).add(this.v1);

}

return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt=function(u,optionalTarget){

return this.getPoint(u,optionalTarget);

};

LineCurve.prototype.getTangent=function()/* t */{

var tangent=this.v2.clone().sub(this.v1);

return tangent.normalize();

};

LineCurve.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v1.copy(source.v1);
this.v2.copy(source.v2);

return this;

};

LineCurve.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v1=this.v1.toArray();
data.v2=this.v2.toArray();

return data;

};

LineCurve.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);

return this;

};

function LineCurve3(v1,v2){

Curve.call(this);

this.type='LineCurve3';

this.v1=v1||new Vector3();
this.v2=v2||new Vector3();

}

LineCurve3.prototype=Object.create(Curve.prototype);
LineCurve3.prototype.constructor=LineCurve3;

LineCurve3.prototype.isLineCurve3=true;

LineCurve3.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector3();

if(t===1){

point.copy(this.v2);

}else{

point.copy(this.v2).sub(this.v1);
point.multiplyScalar(t).add(this.v1);

}

return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve3.prototype.getPointAt=function(u,optionalTarget){

return this.getPoint(u,optionalTarget);

};

LineCurve3.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v1.copy(source.v1);
this.v2.copy(source.v2);

return this;

};

LineCurve3.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v1=this.v1.toArray();
data.v2=this.v2.toArray();

return data;

};

LineCurve3.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);

return this;

};

function QuadraticBezierCurve(v0,v1,v2){

Curve.call(this);

this.type='QuadraticBezierCurve';

this.v0=v0||new Vector2();
this.v1=v1||new Vector2();
this.v2=v2||new Vector2();

}

QuadraticBezierCurve.prototype=Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;

QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;

QuadraticBezierCurve.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector2();

var v0=this.v0,v1=this.v1,v2=this.v2;

point.set(
QuadraticBezier(t,v0.x,v1.x,v2.x),
QuadraticBezier(t,v0.y,v1.y,v2.y));


return point;

};

QuadraticBezierCurve.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v0.copy(source.v0);
this.v1.copy(source.v1);
this.v2.copy(source.v2);

return this;

};

QuadraticBezierCurve.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v0=this.v0.toArray();
data.v1=this.v1.toArray();
data.v2=this.v2.toArray();

return data;

};

QuadraticBezierCurve.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v0.fromArray(json.v0);
this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);

return this;

};

function QuadraticBezierCurve3(v0,v1,v2){

Curve.call(this);

this.type='QuadraticBezierCurve3';

this.v0=v0||new Vector3();
this.v1=v1||new Vector3();
this.v2=v2||new Vector3();

}

QuadraticBezierCurve3.prototype=Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;

QuadraticBezierCurve3.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector3();

var v0=this.v0,v1=this.v1,v2=this.v2;

point.set(
QuadraticBezier(t,v0.x,v1.x,v2.x),
QuadraticBezier(t,v0.y,v1.y,v2.y),
QuadraticBezier(t,v0.z,v1.z,v2.z));


return point;

};

QuadraticBezierCurve3.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.v0.copy(source.v0);
this.v1.copy(source.v1);
this.v2.copy(source.v2);

return this;

};

QuadraticBezierCurve3.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.v0=this.v0.toArray();
data.v1=this.v1.toArray();
data.v2=this.v2.toArray();

return data;

};

QuadraticBezierCurve3.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.v0.fromArray(json.v0);
this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);

return this;

};

function SplineCurve(points/* array of Vector2 */){

Curve.call(this);

this.type='SplineCurve';

this.points=points||[];

}

SplineCurve.prototype=Object.create(Curve.prototype);
SplineCurve.prototype.constructor=SplineCurve;

SplineCurve.prototype.isSplineCurve=true;

SplineCurve.prototype.getPoint=function(t,optionalTarget){

var point=optionalTarget||new Vector2();

var points=this.points;
var p=(points.length-1)*t;

var intPoint=Math.floor(p);
var weight=p-intPoint;

var p0=points[intPoint===0?intPoint:intPoint-1];
var p1=points[intPoint];
var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];
var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];

point.set(
CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),
CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));


return point;

};

SplineCurve.prototype.copy=function(source){

Curve.prototype.copy.call(this,source);

this.points=[];

for(var i=0,l=source.points.length;i<l;i++){

var point=source.points[i];

this.points.push(point.clone());

}

return this;

};

SplineCurve.prototype.toJSON=function(){

var data=Curve.prototype.toJSON.call(this);

data.points=[];

for(var i=0,l=this.points.length;i<l;i++){

var point=this.points[i];
data.points.push(point.toArray());

}

return data;

};

SplineCurve.prototype.fromJSON=function(json){

Curve.prototype.fromJSON.call(this,json);

this.points=[];

for(var i=0,l=json.points.length;i<l;i++){

var point=json.points[i];
this.points.push(new Vector2().fromArray(point));

}

return this;

};



var Curves=/*#__PURE__*/Object.freeze({
ArcCurve:ArcCurve,
CatmullRomCurve3:CatmullRomCurve3,
CubicBezierCurve:CubicBezierCurve,
CubicBezierCurve3:CubicBezierCurve3,
EllipseCurve:EllipseCurve,
LineCurve:LineCurve,
LineCurve3:LineCurve3,
QuadraticBezierCurve:QuadraticBezierCurve,
QuadraticBezierCurve3:QuadraticBezierCurve3,
SplineCurve:SplineCurve});


/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath(){

Curve.call(this);

this.type='CurvePath';

this.curves=[];
this.autoClose=false;// Automatically closes the path

}

CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{

constructor:CurvePath,

add:function add(curve){

this.curves.push(curve);

},

closePath:function closePath(){

// Add a line curve if start and end of lines are not connected
var startPoint=this.curves[0].getPoint(0);
var endPoint=this.curves[this.curves.length-1].getPoint(1);

if(!startPoint.equals(endPoint)){

this.curves.push(new LineCurve(endPoint,startPoint));

}

},

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

getPoint:function getPoint(t){

var d=t*this.getLength();
var curveLengths=this.getCurveLengths();
var i=0;

// To think about boundaries points.

while(i<curveLengths.length){

if(curveLengths[i]>=d){

var diff=curveLengths[i]-d;
var curve=this.curves[i];

var segmentLength=curve.getLength();
var u=segmentLength===0?0:1-diff/segmentLength;

return curve.getPointAt(u);

}

i++;

}

return null;

// loop where sum != 0, sum > d , sum+1 <d

},

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

getLength:function getLength(){

var lens=this.getCurveLengths();
return lens[lens.length-1];

},

// cacheLengths must be recalculated.
updateArcLengths:function updateArcLengths(){

this.needsUpdate=true;
this.cacheLengths=null;
this.getCurveLengths();

},

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

getCurveLengths:function getCurveLengths(){

// We use cache values if curves and cache array are same length

if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){

return this.cacheLengths;

}

// Get length of sub-curve
// Push sums into cached array

var lengths=[],sums=0;

for(var i=0,l=this.curves.length;i<l;i++){

sums+=this.curves[i].getLength();
lengths.push(sums);

}

this.cacheLengths=lengths;

return lengths;

},

getSpacedPoints:function getSpacedPoints(divisions){

if(divisions===undefined)divisions=40;

var points=[];

for(var i=0;i<=divisions;i++){

points.push(this.getPoint(i/divisions));

}

if(this.autoClose){

points.push(points[0]);

}

return points;

},

getPoints:function getPoints(divisions){

divisions=divisions||12;

var points=[],last;

for(var i=0,curves=this.curves;i<curves.length;i++){

var curve=curves[i];
var resolution=curve&&curve.isEllipseCurve?divisions*2:
curve&&(curve.isLineCurve||curve.isLineCurve3)?1:
curve&&curve.isSplineCurve?divisions*curve.points.length:
divisions;

var pts=curve.getPoints(resolution);

for(var j=0;j<pts.length;j++){

var point=pts[j];

if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates

points.push(point);
last=point;

}

}

if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){

points.push(points[0]);

}

return points;

},

copy:function copy(source){

Curve.prototype.copy.call(this,source);

this.curves=[];

for(var i=0,l=source.curves.length;i<l;i++){

var curve=source.curves[i];

this.curves.push(curve.clone());

}

this.autoClose=source.autoClose;

return this;

},

toJSON:function toJSON(){

var data=Curve.prototype.toJSON.call(this);

data.autoClose=this.autoClose;
data.curves=[];

for(var i=0,l=this.curves.length;i<l;i++){

var curve=this.curves[i];
data.curves.push(curve.toJSON());

}

return data;

},

fromJSON:function fromJSON(json){

Curve.prototype.fromJSON.call(this,json);

this.autoClose=json.autoClose;
this.curves=[];

for(var i=0,l=json.curves.length;i<l;i++){

var curve=json.curves[i];
this.curves.push(new Curves[curve.type]().fromJSON(curve));

}

return this;

}});



/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path(points){

CurvePath.call(this);

this.type='Path';

this.currentPoint=new Vector2();

if(points){

this.setFromPoints(points);

}

}

Path.prototype=Object.assign(Object.create(CurvePath.prototype),{

constructor:Path,

setFromPoints:function setFromPoints(points){

this.moveTo(points[0].x,points[0].y);

for(var i=1,l=points.length;i<l;i++){

this.lineTo(points[i].x,points[i].y);

}

},

moveTo:function moveTo(x,y){

this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?

},

lineTo:function lineTo(x,y){

var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));
this.curves.push(curve);

this.currentPoint.set(x,y);

},

quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){

var curve=new QuadraticBezierCurve(
this.currentPoint.clone(),
new Vector2(aCPx,aCPy),
new Vector2(aX,aY));


this.curves.push(curve);

this.currentPoint.set(aX,aY);

},

bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){

var curve=new CubicBezierCurve(
this.currentPoint.clone(),
new Vector2(aCP1x,aCP1y),
new Vector2(aCP2x,aCP2y),
new Vector2(aX,aY));


this.curves.push(curve);

this.currentPoint.set(aX,aY);

},

splineThru:function splineThru(pts/*Array of Vector*/){

var npts=[this.currentPoint.clone()].concat(pts);

var curve=new SplineCurve(npts);
this.curves.push(curve);

this.currentPoint.copy(pts[pts.length-1]);

},

arc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){

var x0=this.currentPoint.x;
var y0=this.currentPoint.y;

this.absarc(aX+x0,aY+y0,aRadius,
aStartAngle,aEndAngle,aClockwise);

},

absarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){

this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);

},

ellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){

var x0=this.currentPoint.x;
var y0=this.currentPoint.y;

this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);

},

absellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){

var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);

if(this.curves.length>0){

// if a previous curve is present, attempt to join
var firstPoint=curve.getPoint(0);

if(!firstPoint.equals(this.currentPoint)){

this.lineTo(firstPoint.x,firstPoint.y);

}

}

this.curves.push(curve);

var lastPoint=curve.getPoint(1);
this.currentPoint.copy(lastPoint);

},

copy:function copy(source){

CurvePath.prototype.copy.call(this,source);

this.currentPoint.copy(source.currentPoint);

return this;

},

toJSON:function toJSON(){

var data=CurvePath.prototype.toJSON.call(this);

data.currentPoint=this.currentPoint.toArray();

return data;

},

fromJSON:function fromJSON(json){

CurvePath.prototype.fromJSON.call(this,json);

this.currentPoint.fromArray(json.currentPoint);

return this;

}});



/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape(points){

Path.call(this,points);

this.uuid=_Math.generateUUID();

this.type='Shape';

this.holes=[];

}

Shape.prototype=Object.assign(Object.create(Path.prototype),{

constructor:Shape,

getPointsHoles:function getPointsHoles(divisions){

var holesPts=[];

for(var i=0,l=this.holes.length;i<l;i++){

holesPts[i]=this.holes[i].getPoints(divisions);

}

return holesPts;

},

// get points of shape and holes (keypoints based on segments parameter)

extractPoints:function extractPoints(divisions){

return{

shape:this.getPoints(divisions),
holes:this.getPointsHoles(divisions)};



},

copy:function copy(source){

Path.prototype.copy.call(this,source);

this.holes=[];

for(var i=0,l=source.holes.length;i<l;i++){

var hole=source.holes[i];

this.holes.push(hole.clone());

}

return this;

},

toJSON:function toJSON(){

var data=Path.prototype.toJSON.call(this);

data.uuid=this.uuid;
data.holes=[];

for(var i=0,l=this.holes.length;i<l;i++){

var hole=this.holes[i];
data.holes.push(hole.toJSON());

}

return data;

},

fromJSON:function fromJSON(json){

Path.prototype.fromJSON.call(this,json);

this.uuid=json.uuid;
this.holes=[];

for(var i=0,l=json.holes.length;i<l;i++){

var hole=json.holes[i];
this.holes.push(new Path().fromJSON(hole));

}

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light(color,intensity){

Object3D.call(this);

this.type='Light';

this.color=new Color(color);
this.intensity=intensity!==undefined?intensity:1;

this.receiveShadow=undefined;

}

Light.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Light,

isLight:true,

copy:function copy(source){

Object3D.prototype.copy.call(this,source);

this.color.copy(source.color);
this.intensity=source.intensity;

return this;

},

toJSON:function toJSON(meta){

var data=Object3D.prototype.toJSON.call(this,meta);

data.object.color=this.color.getHex();
data.object.intensity=this.intensity;

if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();

if(this.distance!==undefined)data.object.distance=this.distance;
if(this.angle!==undefined)data.object.angle=this.angle;
if(this.decay!==undefined)data.object.decay=this.decay;
if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;

if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();

return data;

}});



/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight(skyColor,groundColor,intensity){

Light.call(this,skyColor,intensity);

this.type='HemisphereLight';

this.castShadow=undefined;

this.position.copy(Object3D.DefaultUp);
this.updateMatrix();

this.groundColor=new Color(groundColor);

}

HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:HemisphereLight,

isHemisphereLight:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.groundColor.copy(source.groundColor);

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow(camera){

this.camera=camera;

this.bias=0;
this.radius=1;

this.mapSize=new Vector2(512,512);

this.map=null;
this.matrix=new Matrix4();

}

Object.assign(LightShadow.prototype,{

copy:function copy(source){

this.camera=source.camera.clone();

this.bias=source.bias;
this.radius=source.radius;

this.mapSize.copy(source.mapSize);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

toJSON:function toJSON(){

var object={};

if(this.bias!==0)object.bias=this.bias;
if(this.radius!==1)object.radius=this.radius;
if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();

object.camera=this.camera.toJSON(false).object;
delete object.camera.matrix;

return object;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow(){

LightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));

}

SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{

constructor:SpotLightShadow,

isSpotLightShadow:true,

update:function update(light){

var camera=this.camera;

var fov=_Math.RAD2DEG*2*light.angle;
var aspect=this.mapSize.width/this.mapSize.height;
var far=light.distance||camera.far;

if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){

camera.fov=fov;
camera.aspect=aspect;
camera.far=far;
camera.updateProjectionMatrix();

}

}});



/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight(color,intensity,distance,angle,penumbra,decay){

Light.call(this,color,intensity);

this.type='SpotLight';

this.position.copy(Object3D.DefaultUp);
this.updateMatrix();

this.target=new Object3D();

Object.defineProperty(this,'power',{
get:function get(){

// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*Math.PI;

},
set:function set(power){

// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/Math.PI;

}});


this.distance=distance!==undefined?distance:0;
this.angle=angle!==undefined?angle:Math.PI/3;
this.penumbra=penumbra!==undefined?penumbra:0;
this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.

this.shadow=new SpotLightShadow();

}

SpotLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:SpotLight,

isSpotLight:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.distance=source.distance;
this.angle=source.angle;
this.penumbra=source.penumbra;
this.decay=source.decay;

this.target=source.target.clone();

this.shadow=source.shadow.clone();

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight(color,intensity,distance,decay){

Light.call(this,color,intensity);

this.type='PointLight';

Object.defineProperty(this,'power',{
get:function get(){

// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*4*Math.PI;

},
set:function set(power){

// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/(4*Math.PI);

}});


this.distance=distance!==undefined?distance:0;
this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.

this.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));

}

PointLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:PointLight,

isPointLight:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.distance=source.distance;
this.decay=source.decay;

this.shadow=source.shadow.clone();

return this;

}});



/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera(left,right,top,bottom,near,far){

Camera.call(this);

this.type='OrthographicCamera';

this.zoom=1;
this.view=null;

this.left=left!==undefined?left:-1;
this.right=right!==undefined?right:1;
this.top=top!==undefined?top:1;
this.bottom=bottom!==undefined?bottom:-1;

this.near=near!==undefined?near:0.1;
this.far=far!==undefined?far:2000;

this.updateProjectionMatrix();

}

OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{

constructor:OrthographicCamera,

isOrthographicCamera:true,

copy:function copy(source,recursive){

Camera.prototype.copy.call(this,source,recursive);

this.left=source.left;
this.right=source.right;
this.top=source.top;
this.bottom=source.bottom;
this.near=source.near;
this.far=source.far;

this.zoom=source.zoom;
this.view=source.view===null?null:Object.assign({},source.view);

return this;

},

setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){

if(this.view===null){

this.view={
enabled:true,
fullWidth:1,
fullHeight:1,
offsetX:0,
offsetY:0,
width:1,
height:1};


}

this.view.enabled=true;
this.view.fullWidth=fullWidth;
this.view.fullHeight=fullHeight;
this.view.offsetX=x;
this.view.offsetY=y;
this.view.width=width;
this.view.height=height;

this.updateProjectionMatrix();

},

clearViewOffset:function clearViewOffset(){

if(this.view!==null){

this.view.enabled=false;

}

this.updateProjectionMatrix();

},

updateProjectionMatrix:function updateProjectionMatrix(){

var dx=(this.right-this.left)/(2*this.zoom);
var dy=(this.top-this.bottom)/(2*this.zoom);
var cx=(this.right+this.left)/2;
var cy=(this.top+this.bottom)/2;

var left=cx-dx;
var right=cx+dx;
var top=cy+dy;
var bottom=cy-dy;

if(this.view!==null&&this.view.enabled){

var zoomW=this.zoom/(this.view.width/this.view.fullWidth);
var zoomH=this.zoom/(this.view.height/this.view.fullHeight);
var scaleW=(this.right-this.left)/this.view.width;
var scaleH=(this.top-this.bottom)/this.view.height;

left+=scaleW*(this.view.offsetX/zoomW);
right=left+scaleW*(this.view.width/zoomW);
top-=scaleH*(this.view.offsetY/zoomH);
bottom=top-scaleH*(this.view.height/zoomH);

}

this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);

this.projectionMatrixInverse.getInverse(this.projectionMatrix);

},

toJSON:function toJSON(meta){

var data=Object3D.prototype.toJSON.call(this,meta);

data.object.zoom=this.zoom;
data.object.left=this.left;
data.object.right=this.right;
data.object.top=this.top;
data.object.bottom=this.bottom;
data.object.near=this.near;
data.object.far=this.far;

if(this.view!==null)data.object.view=Object.assign({},this.view);

return data;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow(){

LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));

}

DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{

constructor:DirectionalLightShadow});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight(color,intensity){

Light.call(this,color,intensity);

this.type='DirectionalLight';

this.position.copy(Object3D.DefaultUp);
this.updateMatrix();

this.target=new Object3D();

this.shadow=new DirectionalLightShadow();

}

DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:DirectionalLight,

isDirectionalLight:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.target=source.target.clone();

this.shadow=source.shadow.clone();

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight(color,intensity){

Light.call(this,color,intensity);

this.type='AmbientLight';

this.castShadow=undefined;

}

AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:AmbientLight,

isAmbientLight:true});



/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight(color,intensity,width,height){

Light.call(this,color,intensity);

this.type='RectAreaLight';

this.width=width!==undefined?width:10;
this.height=height!==undefined?height:10;

}

RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{

constructor:RectAreaLight,

isRectAreaLight:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.width=source.width;
this.height=source.height;

return this;

},

toJSON:function toJSON(meta){

var data=Light.prototype.toJSON.call(this,meta);

data.object.width=this.width;
data.object.height=this.height;

return data;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;
this.textures={};

}

Object.assign(MaterialLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(scope.manager);
loader.setPath(scope.path);
loader.load(url,function(text){

onLoad(scope.parse(JSON.parse(text)));

},onProgress,onError);

},

parse:function parse(json){

var textures=this.textures;

function getTexture(name){

if(textures[name]===undefined){

console.warn('THREE.MaterialLoader: Undefined texture',name);

}

return textures[name];

}

var material=new Materials[json.type]();

if(json.uuid!==undefined)material.uuid=json.uuid;
if(json.name!==undefined)material.name=json.name;
if(json.color!==undefined)material.color.setHex(json.color);
if(json.roughness!==undefined)material.roughness=json.roughness;
if(json.metalness!==undefined)material.metalness=json.metalness;
if(json.emissive!==undefined)material.emissive.setHex(json.emissive);
if(json.specular!==undefined)material.specular.setHex(json.specular);
if(json.shininess!==undefined)material.shininess=json.shininess;
if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;
if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;
if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;
if(json.fog!==undefined)material.fog=json.fog;
if(json.flatShading!==undefined)material.flatShading=json.flatShading;
if(json.blending!==undefined)material.blending=json.blending;
if(json.combine!==undefined)material.combine=json.combine;
if(json.side!==undefined)material.side=json.side;
if(json.opacity!==undefined)material.opacity=json.opacity;
if(json.transparent!==undefined)material.transparent=json.transparent;
if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;
if(json.depthTest!==undefined)material.depthTest=json.depthTest;
if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;
if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;
if(json.wireframe!==undefined)material.wireframe=json.wireframe;
if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;
if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;
if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;

if(json.rotation!==undefined)material.rotation=json.rotation;

if(json.linewidth!==1)material.linewidth=json.linewidth;
if(json.dashSize!==undefined)material.dashSize=json.dashSize;
if(json.gapSize!==undefined)material.gapSize=json.gapSize;
if(json.scale!==undefined)material.scale=json.scale;

if(json.polygonOffset!==undefined)material.polygonOffset=json.polygonOffset;
if(json.polygonOffsetFactor!==undefined)material.polygonOffsetFactor=json.polygonOffsetFactor;
if(json.polygonOffsetUnits!==undefined)material.polygonOffsetUnits=json.polygonOffsetUnits;

if(json.skinning!==undefined)material.skinning=json.skinning;
if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;
if(json.dithering!==undefined)material.dithering=json.dithering;

if(json.visible!==undefined)material.visible=json.visible;
if(json.userData!==undefined)material.userData=json.userData;

// Shader Material

if(json.uniforms!==undefined){

for(var name in json.uniforms){

var uniform=json.uniforms[name];

material.uniforms[name]={};

switch(uniform.type){

case't':
material.uniforms[name].value=getTexture(uniform.value);
break;

case'c':
material.uniforms[name].value=new Color().setHex(uniform.value);
break;

case'v2':
material.uniforms[name].value=new Vector2().fromArray(uniform.value);
break;

case'v3':
material.uniforms[name].value=new Vector3().fromArray(uniform.value);
break;

case'v4':
material.uniforms[name].value=new Vector4().fromArray(uniform.value);
break;

case'm3':
material.uniforms[name].value=new Matrix3().fromArray(uniform.value);

case'm4':
material.uniforms[name].value=new Matrix4().fromArray(uniform.value);
break;

default:
material.uniforms[name].value=uniform.value;}



}

}

if(json.defines!==undefined)material.defines=json.defines;
if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;
if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;

if(json.extensions!==undefined){

for(var key in json.extensions){

material.extensions[key]=json.extensions[key];

}

}

// Deprecated

if(json.shading!==undefined)material.flatShading=json.shading===1;// THREE.FlatShading

// for PointsMaterial

if(json.size!==undefined)material.size=json.size;
if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;

// maps

if(json.map!==undefined)material.map=getTexture(json.map);
if(json.matcap!==undefined)material.matcap=getTexture(json.matcap);

if(json.alphaMap!==undefined){

material.alphaMap=getTexture(json.alphaMap);
material.transparent=true;

}

if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);
if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;

if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);
if(json.normalMapType!==undefined)material.normalMapType=json.normalMapType;
if(json.normalScale!==undefined){

var normalScale=json.normalScale;

if(Array.isArray(normalScale)===false){

// Blender exporter used to export a scalar. See #7459

normalScale=[normalScale,normalScale];

}

material.normalScale=new Vector2().fromArray(normalScale);

}

if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);
if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;
if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;

if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);
if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);

if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);
if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;

if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);

if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);
if(json.envMapIntensity!==undefined)material.envMapIntensity=json.envMapIntensity;

if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;

if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);
if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;

if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);
if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;

if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);

return material;

},

setPath:function setPath(value){

this.path=value;
return this;

},

setTextures:function setTextures(value){

this.textures=value;
return this;

}});



/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

var LoaderUtils={

decodeText:function decodeText(array){

if(typeof TextDecoder!=='undefined'){

return new TextDecoder().decode(array);

}

// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.

var s='';

for(var i=0,il=array.length;i<il;i++){

// Implicitly assumes little-endian.
s+=String.fromCharCode(array[i]);

}

try{

// merges multi-byte utf-8 characters.

return decodeURIComponent(escape(s));

}catch(e){// see #16358

return s;

}

},

extractUrlBase:function extractUrlBase(url){

var index=url.lastIndexOf('/');

if(index===-1)return'./';

return url.substr(0,index+1);

}};



/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry(){

BufferGeometry.call(this);

this.type='InstancedBufferGeometry';
this.maxInstancedCount=undefined;

}

InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{

constructor:InstancedBufferGeometry,

isInstancedBufferGeometry:true,

copy:function copy(source){

BufferGeometry.prototype.copy.call(this,source);

this.maxInstancedCount=source.maxInstancedCount;

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

toJSON:function toJSON(){

var data=BufferGeometry.prototype.toJSON.call(this);

data.maxInstancedCount=this.maxInstancedCount;

data.isInstancedBufferGeometry=true;

return data;

}});



/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute(array,itemSize,normalized,meshPerAttribute){

if(typeof normalized==='number'){

meshPerAttribute=normalized;

normalized=false;

console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');

}

BufferAttribute.call(this,array,itemSize,normalized);

this.meshPerAttribute=meshPerAttribute||1;

}

InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{

constructor:InstancedBufferAttribute,

isInstancedBufferAttribute:true,

copy:function copy(source){

BufferAttribute.prototype.copy.call(this,source);

this.meshPerAttribute=source.meshPerAttribute;

return this;

},

toJSON:function toJSON(){

var data=BufferAttribute.prototype.toJSON.call(this);

data.meshPerAttribute=this.meshPerAttribute;

data.isInstancedBufferAttribute=true;

return data;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(BufferGeometryLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(scope.manager);
loader.setPath(scope.path);
loader.load(url,function(text){

onLoad(scope.parse(JSON.parse(text)));

},onProgress,onError);

},

parse:function parse(json){

var geometry=json.isInstancedBufferGeometry?new InstancedBufferGeometry():new BufferGeometry();

var index=json.data.index;

if(index!==undefined){

var typedArray=new TYPED_ARRAYS[index.type](index.array);
geometry.setIndex(new BufferAttribute(typedArray,1));

}

var attributes=json.data.attributes;

for(var key in attributes){

var attribute=attributes[key];
var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);
var bufferAttributeConstr=attribute.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;
var bufferAttribute=new bufferAttributeConstr(typedArray,attribute.itemSize,attribute.normalized);
if(attribute.name!==undefined)bufferAttribute.name=attribute.name;
geometry.addAttribute(key,bufferAttribute);

}

var morphAttributes=json.data.morphAttributes;

if(morphAttributes){

for(var key in morphAttributes){

var attributeArray=morphAttributes[key];

var array=[];

for(var i=0,il=attributeArray.length;i<il;i++){

var attribute=attributeArray[i];
var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);

var bufferAttribute=new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized);
if(attribute.name!==undefined)bufferAttribute.name=attribute.name;
array.push(bufferAttribute);

}

geometry.morphAttributes[key]=array;

}

}

var groups=json.data.groups||json.data.drawcalls||json.data.offsets;

if(groups!==undefined){

for(var i=0,n=groups.length;i!==n;++i){

var group=groups[i];

geometry.addGroup(group.start,group.count,group.materialIndex);

}

}

var boundingSphere=json.data.boundingSphere;

if(boundingSphere!==undefined){

var center=new Vector3();

if(boundingSphere.center!==undefined){

center.fromArray(boundingSphere.center);

}

geometry.boundingSphere=new Sphere(center,boundingSphere.radius);

}

if(json.name)geometry.name=json.name;
if(json.userData)geometry.userData=json.userData;

return geometry;

},

setPath:function setPath(value){

this.path=value;
return this;

}});



var TYPED_ARRAYS={
Int8Array:Int8Array,
Uint8Array:Uint8Array,
// Workaround for IE11 pre KB2929437. See #11440
Uint8ClampedArray:typeof Uint8ClampedArray!=='undefined'?Uint8ClampedArray:Uint8Array,
Int16Array:Int16Array,
Uint16Array:Uint16Array,
Int32Array:Int32Array,
Uint32Array:Uint32Array,
Float32Array:Float32Array,
Float64Array:Float64Array};


/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;
this.resourcePath='';

}

Object.assign(ObjectLoader.prototype,{

crossOrigin:'anonymous',

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var path=this.path===undefined?LoaderUtils.extractUrlBase(url):this.path;
this.resourcePath=this.resourcePath||path;

var loader=new FileLoader(scope.manager);
loader.setPath(this.path);
loader.load(url,function(text){

var json=null;

try{

json=JSON.parse(text);

}catch(error){

if(onError!==undefined)onError(error);

console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);

return;

}

var metadata=json.metadata;

if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){

console.error('THREE.ObjectLoader: Can\'t load '+url);
return;

}

scope.parse(json,onLoad);

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;
return this;

},

setResourcePath:function setResourcePath(value){

this.resourcePath=value;
return this;

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

parse:function parse(json,onLoad){

var shapes=this.parseShape(json.shapes);
var geometries=this.parseGeometries(json.geometries,shapes);

var images=this.parseImages(json.images,function(){

if(onLoad!==undefined)onLoad(object);

});

var textures=this.parseTextures(json.textures,images);
var materials=this.parseMaterials(json.materials,textures);

var object=this.parseObject(json.object,geometries,materials);

if(json.animations){

object.animations=this.parseAnimations(json.animations);

}

if(json.images===undefined||json.images.length===0){

if(onLoad!==undefined)onLoad(object);

}

return object;

},

parseShape:function parseShape(json){

var shapes={};

if(json!==undefined){

for(var i=0,l=json.length;i<l;i++){

var shape=new Shape().fromJSON(json[i]);

shapes[shape.uuid]=shape;

}

}

return shapes;

},

parseGeometries:function parseGeometries(json,shapes){

var geometries={};

if(json!==undefined){

var bufferGeometryLoader=new BufferGeometryLoader();

for(var i=0,l=json.length;i<l;i++){

var geometry;
var data=json[i];

switch(data.type){

case'PlaneGeometry':
case'PlaneBufferGeometry':

geometry=new Geometries[data.type](
data.width,
data.height,
data.widthSegments,
data.heightSegments);


break;

case'BoxGeometry':
case'BoxBufferGeometry':
case'CubeGeometry':// backwards compatible

geometry=new Geometries[data.type](
data.width,
data.height,
data.depth,
data.widthSegments,
data.heightSegments,
data.depthSegments);


break;

case'CircleGeometry':
case'CircleBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.segments,
data.thetaStart,
data.thetaLength);


break;

case'CylinderGeometry':
case'CylinderBufferGeometry':

geometry=new Geometries[data.type](
data.radiusTop,
data.radiusBottom,
data.height,
data.radialSegments,
data.heightSegments,
data.openEnded,
data.thetaStart,
data.thetaLength);


break;

case'ConeGeometry':
case'ConeBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.height,
data.radialSegments,
data.heightSegments,
data.openEnded,
data.thetaStart,
data.thetaLength);


break;

case'SphereGeometry':
case'SphereBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.widthSegments,
data.heightSegments,
data.phiStart,
data.phiLength,
data.thetaStart,
data.thetaLength);


break;

case'DodecahedronGeometry':
case'DodecahedronBufferGeometry':
case'IcosahedronGeometry':
case'IcosahedronBufferGeometry':
case'OctahedronGeometry':
case'OctahedronBufferGeometry':
case'TetrahedronGeometry':
case'TetrahedronBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.detail);


break;

case'RingGeometry':
case'RingBufferGeometry':

geometry=new Geometries[data.type](
data.innerRadius,
data.outerRadius,
data.thetaSegments,
data.phiSegments,
data.thetaStart,
data.thetaLength);


break;

case'TorusGeometry':
case'TorusBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.tube,
data.radialSegments,
data.tubularSegments,
data.arc);


break;

case'TorusKnotGeometry':
case'TorusKnotBufferGeometry':

geometry=new Geometries[data.type](
data.radius,
data.tube,
data.tubularSegments,
data.radialSegments,
data.p,
data.q);


break;

case'TubeGeometry':
case'TubeBufferGeometry':

// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
geometry=new Geometries[data.type](
new Curves[data.path.type]().fromJSON(data.path),
data.tubularSegments,
data.radius,
data.radialSegments,
data.closed);


break;

case'LatheGeometry':
case'LatheBufferGeometry':

geometry=new Geometries[data.type](
data.points,
data.segments,
data.phiStart,
data.phiLength);


break;

case'PolyhedronGeometry':
case'PolyhedronBufferGeometry':

geometry=new Geometries[data.type](
data.vertices,
data.indices,
data.radius,
data.details);


break;

case'ShapeGeometry':
case'ShapeBufferGeometry':

var geometryShapes=[];

for(var j=0,jl=data.shapes.length;j<jl;j++){

var shape=shapes[data.shapes[j]];

geometryShapes.push(shape);

}

geometry=new Geometries[data.type](
geometryShapes,
data.curveSegments);


break;


case'ExtrudeGeometry':
case'ExtrudeBufferGeometry':

var geometryShapes=[];

for(var j=0,jl=data.shapes.length;j<jl;j++){

var shape=shapes[data.shapes[j]];

geometryShapes.push(shape);

}

var extrudePath=data.options.extrudePath;

if(extrudePath!==undefined){

data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath);

}

geometry=new Geometries[data.type](
geometryShapes,
data.options);


break;

case'BufferGeometry':
case'InstancedBufferGeometry':

geometry=bufferGeometryLoader.parse(data);

break;

case'Geometry':

if('THREE'in window&&'LegacyJSONLoader'in THREE){

var geometryLoader=new THREE.LegacyJSONLoader();
geometry=geometryLoader.parse(data,this.resourcePath).geometry;


}else{

console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');

}

break;

default:

console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');

continue;}



geometry.uuid=data.uuid;

if(data.name!==undefined)geometry.name=data.name;
if(geometry.isBufferGeometry===true&&data.userData!==undefined)geometry.userData=data.userData;

geometries[data.uuid]=geometry;

}

}

return geometries;

},

parseMaterials:function parseMaterials(json,textures){

var cache={};// MultiMaterial
var materials={};

if(json!==undefined){

var loader=new MaterialLoader();
loader.setTextures(textures);

for(var i=0,l=json.length;i<l;i++){

var data=json[i];

if(data.type==='MultiMaterial'){

// Deprecated

var array=[];

for(var j=0;j<data.materials.length;j++){

var material=data.materials[j];

if(cache[material.uuid]===undefined){

cache[material.uuid]=loader.parse(material);

}

array.push(cache[material.uuid]);

}

materials[data.uuid]=array;

}else{

if(cache[data.uuid]===undefined){

cache[data.uuid]=loader.parse(data);

}

materials[data.uuid]=cache[data.uuid];

}

}

}

return materials;

},

parseAnimations:function parseAnimations(json){

var animations=[];

for(var i=0;i<json.length;i++){

var data=json[i];

var clip=AnimationClip.parse(data);

if(data.uuid!==undefined)clip.uuid=data.uuid;

animations.push(clip);

}

return animations;

},

parseImages:function parseImages(json,onLoad){

var scope=this;
var images={};

function loadImage(url){

scope.manager.itemStart(url);

return loader.load(url,function(){

scope.manager.itemEnd(url);

},undefined,function(){

scope.manager.itemError(url);
scope.manager.itemEnd(url);

});

}

if(json!==undefined&&json.length>0){

var manager=new LoadingManager(onLoad);

var loader=new ImageLoader(manager);
loader.setCrossOrigin(this.crossOrigin);

for(var i=0,il=json.length;i<il;i++){

var image=json[i];
var url=image.url;

if(Array.isArray(url)){

// load array of images e.g CubeTexture

images[image.uuid]=[];

for(var j=0,jl=url.length;j<jl;j++){

var currentUrl=url[j];

var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl)?currentUrl:scope.resourcePath+currentUrl;

images[image.uuid].push(loadImage(path));

}

}else{

// load single image

var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.resourcePath+image.url;

images[image.uuid]=loadImage(path);

}

}

}

return images;

},

parseTextures:function parseTextures(json,images){

function parseConstant(value,type){

if(typeof value==='number')return value;

console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);

return type[value];

}

var textures={};

if(json!==undefined){

for(var i=0,l=json.length;i<l;i++){

var data=json[i];

if(data.image===undefined){

console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);

}

if(images[data.image]===undefined){

console.warn('THREE.ObjectLoader: Undefined image',data.image);

}

var texture;

if(Array.isArray(images[data.image])){

texture=new CubeTexture(images[data.image]);

}else{

texture=new Texture(images[data.image]);

}

texture.needsUpdate=true;

texture.uuid=data.uuid;

if(data.name!==undefined)texture.name=data.name;

if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);

if(data.offset!==undefined)texture.offset.fromArray(data.offset);
if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);
if(data.center!==undefined)texture.center.fromArray(data.center);
if(data.rotation!==undefined)texture.rotation=data.rotation;

if(data.wrap!==undefined){

texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);
texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);

}

if(data.format!==undefined)texture.format=data.format;
if(data.type!==undefined)texture.type=data.type;
if(data.encoding!==undefined)texture.encoding=data.encoding;

if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);
if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);
if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;

if(data.flipY!==undefined)texture.flipY=data.flipY;

if(data.premultiplyAlpha!==undefined)texture.premultiplyAlpha=data.premultiplyAlpha;
if(data.unpackAlignment!==undefined)texture.unpackAlignment=data.unpackAlignment;

textures[data.uuid]=texture;

}

}

return textures;

},

parseObject:function parseObject(data,geometries,materials){

var object;

function getGeometry(name){

if(geometries[name]===undefined){

console.warn('THREE.ObjectLoader: Undefined geometry',name);

}

return geometries[name];

}

function getMaterial(name){

if(name===undefined)return undefined;

if(Array.isArray(name)){

var array=[];

for(var i=0,l=name.length;i<l;i++){

var uuid=name[i];

if(materials[uuid]===undefined){

console.warn('THREE.ObjectLoader: Undefined material',uuid);

}

array.push(materials[uuid]);

}

return array;

}

if(materials[name]===undefined){

console.warn('THREE.ObjectLoader: Undefined material',name);

}

return materials[name];

}

switch(data.type){

case'Scene':

object=new Scene();

if(data.background!==undefined){

if(Number.isInteger(data.background)){

object.background=new Color(data.background);

}

}

if(data.fog!==undefined){

if(data.fog.type==='Fog'){

object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);

}else if(data.fog.type==='FogExp2'){

object.fog=new FogExp2(data.fog.color,data.fog.density);

}

}

break;

case'PerspectiveCamera':

object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);

if(data.focus!==undefined)object.focus=data.focus;
if(data.zoom!==undefined)object.zoom=data.zoom;
if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;
if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;
if(data.view!==undefined)object.view=Object.assign({},data.view);

break;

case'OrthographicCamera':

object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);

if(data.zoom!==undefined)object.zoom=data.zoom;
if(data.view!==undefined)object.view=Object.assign({},data.view);

break;

case'AmbientLight':

object=new AmbientLight(data.color,data.intensity);

break;

case'DirectionalLight':

object=new DirectionalLight(data.color,data.intensity);

break;

case'PointLight':

object=new PointLight(data.color,data.intensity,data.distance,data.decay);

break;

case'RectAreaLight':

object=new RectAreaLight(data.color,data.intensity,data.width,data.height);

break;

case'SpotLight':

object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);

break;

case'HemisphereLight':

object=new HemisphereLight(data.color,data.groundColor,data.intensity);

break;

case'SkinnedMesh':

console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

case'Mesh':

var geometry=getGeometry(data.geometry);
var material=getMaterial(data.material);

if(geometry.bones&&geometry.bones.length>0){

object=new SkinnedMesh(geometry,material);

}else{

object=new Mesh(geometry,material);

}

if(data.drawMode!==undefined)object.setDrawMode(data.drawMode);

break;

case'LOD':

object=new LOD();

break;

case'Line':

object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);

break;

case'LineLoop':

object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));

break;

case'LineSegments':

object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));

break;

case'PointCloud':
case'Points':

object=new Points(getGeometry(data.geometry),getMaterial(data.material));

break;

case'Sprite':

object=new Sprite(getMaterial(data.material));

break;

case'Group':

object=new Group();

break;

default:

object=new Object3D();}



object.uuid=data.uuid;

if(data.name!==undefined)object.name=data.name;

if(data.matrix!==undefined){

object.matrix.fromArray(data.matrix);

if(data.matrixAutoUpdate!==undefined)object.matrixAutoUpdate=data.matrixAutoUpdate;
if(object.matrixAutoUpdate)object.matrix.decompose(object.position,object.quaternion,object.scale);

}else{

if(data.position!==undefined)object.position.fromArray(data.position);
if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);
if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);
if(data.scale!==undefined)object.scale.fromArray(data.scale);

}

if(data.castShadow!==undefined)object.castShadow=data.castShadow;
if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;

if(data.shadow){

if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;
if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;
if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);
if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);

}

if(data.visible!==undefined)object.visible=data.visible;
if(data.frustumCulled!==undefined)object.frustumCulled=data.frustumCulled;
if(data.renderOrder!==undefined)object.renderOrder=data.renderOrder;
if(data.userData!==undefined)object.userData=data.userData;
if(data.layers!==undefined)object.layers.mask=data.layers;

if(data.children!==undefined){

var children=data.children;

for(var i=0;i<children.length;i++){

object.add(this.parseObject(children[i],geometries,materials));

}

}

if(data.type==='LOD'){

var levels=data.levels;

for(var l=0;l<levels.length;l++){

var level=levels[l];
var child=object.getObjectByProperty('uuid',level.object);

if(child!==undefined){

object.addLevel(child,level.distance);

}

}

}

return object;

}});



var TEXTURE_MAPPING={
UVMapping:UVMapping,
CubeReflectionMapping:CubeReflectionMapping,
CubeRefractionMapping:CubeRefractionMapping,
EquirectangularReflectionMapping:EquirectangularReflectionMapping,
EquirectangularRefractionMapping:EquirectangularRefractionMapping,
SphericalReflectionMapping:SphericalReflectionMapping,
CubeUVReflectionMapping:CubeUVReflectionMapping,
CubeUVRefractionMapping:CubeUVRefractionMapping};


var TEXTURE_WRAPPING={
RepeatWrapping:RepeatWrapping,
ClampToEdgeWrapping:ClampToEdgeWrapping,
MirroredRepeatWrapping:MirroredRepeatWrapping};


var TEXTURE_FILTER={
NearestFilter:NearestFilter,
NearestMipMapNearestFilter:NearestMipMapNearestFilter,
NearestMipMapLinearFilter:NearestMipMapLinearFilter,
LinearFilter:LinearFilter,
LinearMipMapNearestFilter:LinearMipMapNearestFilter,
LinearMipMapLinearFilter:LinearMipMapLinearFilter};


/**
 * @author thespite / http://clicktorelease.com/
 */


function ImageBitmapLoader(manager){

if(typeof createImageBitmap==='undefined'){

console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');

}

if(typeof fetch==='undefined'){

console.warn('THREE.ImageBitmapLoader: fetch() not supported.');

}

this.manager=manager!==undefined?manager:DefaultLoadingManager;
this.options=undefined;

}

ImageBitmapLoader.prototype={

constructor:ImageBitmapLoader,

setOptions:function setOptions(options){

this.options=options;

return this;

},

load:function load(url,onLoad,onProgress,onError){

if(url===undefined)url='';

if(this.path!==undefined)url=this.path+url;

url=this.manager.resolveURL(url);

var scope=this;

var cached=Cache.get(url);

if(cached!==undefined){

scope.manager.itemStart(url);

setTimeout(function(){

if(onLoad)onLoad(cached);

scope.manager.itemEnd(url);

},0);

return cached;

}

fetch(url).then(function(res){

return res.blob();

}).then(function(blob){

if(scope.options===undefined){

// Workaround for FireFox. It causes an error if you pass options.
return createImageBitmap(blob);

}else{

return createImageBitmap(blob,scope.options);

}

}).then(function(imageBitmap){

Cache.add(url,imageBitmap);

if(onLoad)onLoad(imageBitmap);

scope.manager.itemEnd(url);

}).catch(function(e){

if(onError)onError(e);

scope.manager.itemError(url);
scope.manager.itemEnd(url);

});

scope.manager.itemStart(url);

},

setCrossOrigin:function setCrossOrigin()/* value */{

return this;

},

setPath:function setPath(value){

this.path=value;
return this;

}};



/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath(){

this.type='ShapePath';

this.color=new Color();

this.subPaths=[];
this.currentPath=null;

}

Object.assign(ShapePath.prototype,{

moveTo:function moveTo(x,y){

this.currentPath=new Path();
this.subPaths.push(this.currentPath);
this.currentPath.moveTo(x,y);

},

lineTo:function lineTo(x,y){

this.currentPath.lineTo(x,y);

},

quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){

this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);

},

bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){

this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);

},

splineThru:function splineThru(pts){

this.currentPath.splineThru(pts);

},

toShapes:function toShapes(isCCW,noHoles){

function toShapesNoHoles(inSubpaths){

var shapes=[];

for(var i=0,l=inSubpaths.length;i<l;i++){

var tmpPath=inSubpaths[i];

var tmpShape=new Shape();
tmpShape.curves=tmpPath.curves;

shapes.push(tmpShape);

}

return shapes;

}

function isPointInsidePolygon(inPt,inPolygon){

var polyLen=inPolygon.length;

// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
var inside=false;
for(var p=polyLen-1,q=0;q<polyLen;p=q++){

var edgeLowPt=inPolygon[p];
var edgeHighPt=inPolygon[q];

var edgeDx=edgeHighPt.x-edgeLowPt.x;
var edgeDy=edgeHighPt.y-edgeLowPt.y;

if(Math.abs(edgeDy)>Number.EPSILON){

// not parallel
if(edgeDy<0){

edgeLowPt=inPolygon[q];edgeDx=-edgeDx;
edgeHighPt=inPolygon[p];edgeDy=-edgeDy;

}
if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;

if(inPt.y===edgeLowPt.y){

if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!

}else{

var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);
if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;
inside=!inside;// true intersection left of inPt

}

}else{

// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||
edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;

}

}

return inside;

}

var isClockWise=ShapeUtils.isClockWise;

var subPaths=this.subPaths;
if(subPaths.length===0)return[];

if(noHoles===true)return toShapesNoHoles(subPaths);


var solid,tmpPath,tmpShape,shapes=[];

if(subPaths.length===1){

tmpPath=subPaths[0];
tmpShape=new Shape();
tmpShape.curves=tmpPath.curves;
shapes.push(tmpShape);
return shapes;

}

var holesFirst=!isClockWise(subPaths[0].getPoints());
holesFirst=isCCW?!holesFirst:holesFirst;

// console.log("Holes first", holesFirst);

var betterShapeHoles=[];
var newShapes=[];
var newShapeHoles=[];
var mainIdx=0;
var tmpPoints;

newShapes[mainIdx]=undefined;
newShapeHoles[mainIdx]=[];

for(var i=0,l=subPaths.length;i<l;i++){

tmpPath=subPaths[i];
tmpPoints=tmpPath.getPoints();
solid=isClockWise(tmpPoints);
solid=isCCW?!solid:solid;

if(solid){

if(!holesFirst&&newShapes[mainIdx])mainIdx++;

newShapes[mainIdx]={s:new Shape(),p:tmpPoints};
newShapes[mainIdx].s.curves=tmpPath.curves;

if(holesFirst)mainIdx++;
newShapeHoles[mainIdx]=[];

//console.log('cw', i);

}else{

newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});

//console.log('ccw', i);

}

}

// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);


if(newShapes.length>1){

var ambiguous=false;
var toChange=[];

for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){

betterShapeHoles[sIdx]=[];

}

for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){

var sho=newShapeHoles[sIdx];

for(var hIdx=0;hIdx<sho.length;hIdx++){

var ho=sho[hIdx];
var hole_unassigned=true;

for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){

if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){

if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});
if(hole_unassigned){

hole_unassigned=false;
betterShapeHoles[s2Idx].push(ho);

}else{

ambiguous=true;

}

}

}
if(hole_unassigned){

betterShapeHoles[sIdx].push(ho);

}

}

}
// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){

// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;

}

}

var tmpHoles;

for(var i=0,il=newShapes.length;i<il;i++){

tmpShape=newShapes[i].s;
shapes.push(tmpShape);
tmpHoles=newShapeHoles[i];

for(var j=0,jl=tmpHoles.length;j<jl;j++){

tmpShape.holes.push(tmpHoles[j].h);

}

}

//console.log("shape", shapes);

return shapes;

}});



/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */


function Font(data){

this.type='Font';

this.data=data;

}

Object.assign(Font.prototype,{

isFont:true,

generateShapes:function generateShapes(text,size){

if(size===undefined)size=100;

var shapes=[];
var paths=createPaths(text,size,this.data);

for(var p=0,pl=paths.length;p<pl;p++){

Array.prototype.push.apply(shapes,paths[p].toShapes());

}

return shapes;

}});



function createPaths(text,size,data){

var chars=Array.from?Array.from(text):String(text).split('');// see #13988
var scale=size/data.resolution;
var line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;

var paths=[];

var offsetX=0,offsetY=0;

for(var i=0;i<chars.length;i++){

var char=chars[i];

if(char==='\n'){

offsetX=0;
offsetY-=line_height;

}else{

var ret=createPath(char,scale,offsetX,offsetY,data);
offsetX+=ret.offsetX;
paths.push(ret.path);

}

}

return paths;

}

function createPath(char,scale,offsetX,offsetY,data){

var glyph=data.glyphs[char]||data.glyphs['?'];

if(!glyph)return;

var path=new ShapePath();

var x,y,cpx,cpy,cpx1,cpy1,cpx2,cpy2;

if(glyph.o){

var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));

for(var i=0,l=outline.length;i<l;){

var action=outline[i++];

switch(action){

case'm':// moveTo

x=outline[i++]*scale+offsetX;
y=outline[i++]*scale+offsetY;

path.moveTo(x,y);

break;

case'l':// lineTo

x=outline[i++]*scale+offsetX;
y=outline[i++]*scale+offsetY;

path.lineTo(x,y);

break;

case'q':// quadraticCurveTo

cpx=outline[i++]*scale+offsetX;
cpy=outline[i++]*scale+offsetY;
cpx1=outline[i++]*scale+offsetX;
cpy1=outline[i++]*scale+offsetY;

path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);

break;

case'b':// bezierCurveTo

cpx=outline[i++]*scale+offsetX;
cpy=outline[i++]*scale+offsetY;
cpx1=outline[i++]*scale+offsetX;
cpy1=outline[i++]*scale+offsetY;
cpx2=outline[i++]*scale+offsetX;
cpy2=outline[i++]*scale+offsetY;

path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);

break;}



}

}

return{offsetX:glyph.ha*scale,path:path};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(FontLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(this.manager);
loader.setPath(this.path);
loader.load(url,function(text){

var json;

try{

json=JSON.parse(text);

}catch(e){

console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
json=JSON.parse(text.substring(65,text.length-2));

}

var font=scope.parse(json);

if(onLoad)onLoad(font);

},onProgress,onError);

},

parse:function parse(json){

return new Font(json);

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader(){}

Loader.Handlers={

handlers:[],

add:function add(regex,loader){

this.handlers.push(regex,loader);

},

get:function get(file){

var handlers=this.handlers;

for(var i=0,l=handlers.length;i<l;i+=2){

var regex=handlers[i];
var loader=handlers[i+1];

if(regex.test(file)){

return loader;

}

}

return null;

}};



Object.assign(Loader.prototype,{

crossOrigin:'anonymous',

onLoadStart:function onLoadStart(){},

onLoadProgress:function onLoadProgress(){},

onLoadComplete:function onLoadComplete(){},

initMaterials:function initMaterials(materials,texturePath,crossOrigin){

var array=[];

for(var i=0;i<materials.length;++i){

array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);

}

return array;

},

createMaterial:function(){

var BlendingMode={
NoBlending:NoBlending,
NormalBlending:NormalBlending,
AdditiveBlending:AdditiveBlending,
SubtractiveBlending:SubtractiveBlending,
MultiplyBlending:MultiplyBlending,
CustomBlending:CustomBlending};


var color=new Color();
var textureLoader=new TextureLoader();
var materialLoader=new MaterialLoader();

return function createMaterial(m,texturePath,crossOrigin){

// convert from old material format

var textures={};

function loadTexture(path,repeat,offset,wrap,anisotropy){

var fullPath=texturePath+path;
var loader=Loader.Handlers.get(fullPath);

var texture;

if(loader!==null){

texture=loader.load(fullPath);

}else{

textureLoader.setCrossOrigin(crossOrigin);
texture=textureLoader.load(fullPath);

}

if(repeat!==undefined){

texture.repeat.fromArray(repeat);

if(repeat[0]!==1)texture.wrapS=RepeatWrapping;
if(repeat[1]!==1)texture.wrapT=RepeatWrapping;

}

if(offset!==undefined){

texture.offset.fromArray(offset);

}

if(wrap!==undefined){

if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;
if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;

if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;
if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;

}

if(anisotropy!==undefined){

texture.anisotropy=anisotropy;

}

var uuid=_Math.generateUUID();

textures[uuid]=texture;

return uuid;

}

//

var json={
uuid:_Math.generateUUID(),
type:'MeshLambertMaterial'};


for(var name in m){

var value=m[name];

switch(name){

case'DbgColor':
case'DbgIndex':
case'opticalDensity':
case'illumination':
break;
case'DbgName':
json.name=value;
break;
case'blending':
json.blending=BlendingMode[value];
break;
case'colorAmbient':
case'mapAmbient':
console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');
break;
case'colorDiffuse':
json.color=color.fromArray(value).getHex();
break;
case'colorSpecular':
json.specular=color.fromArray(value).getHex();
break;
case'colorEmissive':
json.emissive=color.fromArray(value).getHex();
break;
case'specularCoef':
json.shininess=value;
break;
case'shading':
if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';
if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';
if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';
break;
case'mapDiffuse':
json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);
break;
case'mapDiffuseRepeat':
case'mapDiffuseOffset':
case'mapDiffuseWrap':
case'mapDiffuseAnisotropy':
break;
case'mapEmissive':
json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);
break;
case'mapEmissiveRepeat':
case'mapEmissiveOffset':
case'mapEmissiveWrap':
case'mapEmissiveAnisotropy':
break;
case'mapLight':
json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);
break;
case'mapLightRepeat':
case'mapLightOffset':
case'mapLightWrap':
case'mapLightAnisotropy':
break;
case'mapAO':
json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);
break;
case'mapAORepeat':
case'mapAOOffset':
case'mapAOWrap':
case'mapAOAnisotropy':
break;
case'mapBump':
json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);
break;
case'mapBumpScale':
json.bumpScale=value;
break;
case'mapBumpRepeat':
case'mapBumpOffset':
case'mapBumpWrap':
case'mapBumpAnisotropy':
break;
case'mapNormal':
json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);
break;
case'mapNormalFactor':
json.normalScale=value;
break;
case'mapNormalRepeat':
case'mapNormalOffset':
case'mapNormalWrap':
case'mapNormalAnisotropy':
break;
case'mapSpecular':
json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);
break;
case'mapSpecularRepeat':
case'mapSpecularOffset':
case'mapSpecularWrap':
case'mapSpecularAnisotropy':
break;
case'mapMetalness':
json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);
break;
case'mapMetalnessRepeat':
case'mapMetalnessOffset':
case'mapMetalnessWrap':
case'mapMetalnessAnisotropy':
break;
case'mapRoughness':
json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);
break;
case'mapRoughnessRepeat':
case'mapRoughnessOffset':
case'mapRoughnessWrap':
case'mapRoughnessAnisotropy':
break;
case'mapAlpha':
json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);
break;
case'mapAlphaRepeat':
case'mapAlphaOffset':
case'mapAlphaWrap':
case'mapAlphaAnisotropy':
break;
case'flipSided':
json.side=BackSide;
break;
case'doubleSided':
json.side=DoubleSide;
break;
case'transparency':
console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
json.opacity=value;
break;
case'depthTest':
case'depthWrite':
case'colorWrite':
case'opacity':
case'reflectivity':
case'transparent':
case'visible':
case'wireframe':
json[name]=value;
break;
case'vertexColors':
if(value===true)json.vertexColors=VertexColors;
if(value==='face')json.vertexColors=FaceColors;
break;
default:
console.error('THREE.Loader.createMaterial: Unsupported',name,value);
break;}



}

if(json.type==='MeshBasicMaterial')delete json.emissive;
if(json.type!=='MeshPhongMaterial')delete json.specular;

if(json.opacity<1)json.transparent=true;

materialLoader.setTextures(textures);

return materialLoader.parse(json);

};

}()});



/**
 * @author mrdoob / http://mrdoob.com/
 */

var context;

var AudioContext={

getContext:function getContext(){

if(context===undefined){

context=new(window.AudioContext||window.webkitAudioContext)();

}

return context;

},

setContext:function setContext(value){

context=value;

}};



/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

}

Object.assign(AudioLoader.prototype,{

load:function load(url,onLoad,onProgress,onError){

var loader=new FileLoader(this.manager);
loader.setResponseType('arraybuffer');
loader.setPath(this.path);
loader.load(url,function(buffer){

// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
var bufferCopy=buffer.slice(0);

var context=AudioContext.getContext();
context.decodeAudioData(bufferCopy,function(audioBuffer){

onLoad(audioBuffer);

});

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;
return this;

}});



/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

function SphericalHarmonics3(){

this.coefficients=[];

for(var i=0;i<9;i++){

this.coefficients.push(new Vector3());

}

}

Object.assign(SphericalHarmonics3.prototype,{

isSphericalHarmonics3:true,

set:function set(coefficients){

for(var i=0;i<9;i++){

this.coefficients[i].copy(coefficients[i]);

}

return this;

},

zero:function zero(){

for(var i=0;i<9;i++){

this.coefficients[i].set(0,0,0);

}

return this;

},

// get the radiance in the direction of the normal
// target is a Vector3
getAt:function getAt(normal,target){

// normal is assumed to be unit length

var x=normal.x,y=normal.y,z=normal.z;

var coeff=this.coefficients;

// band 0
target=coeff[0]*0.282095;

// band 1
target+=coeff[1]*0.488603*y;
target+=coeff[2]*0.488603*z;
target+=coeff[3]*0.488603*x;

// band 2
target+=coeff[4]*1.092548*(x*y);
target+=coeff[5]*1.092548*(y*z);
target+=coeff[6]*0.315392*(3.0*z*z-1.0);
target+=coeff[7]*1.092548*(x*z);
target+=coeff[8]*0.546274*(x*x-y*y);

return target;

},

// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt:function getIrradianceAt(normal,target){

// normal is assumed to be unit length

var x=normal.x,y=normal.y,z=normal.z;

var coeff=this.coefficients;

// band 0
target=coeff[0]*0.886227;// π * 0.282095

// band 1
target+=coeff[1]*2.0*0.511664*y;// ( 2 * π / 3 ) * 0.488603
target+=coeff[2]*2.0*0.511664*z;
target+=coeff[3]*2.0*0.511664*x;

// band 2
target+=coeff[4]*2.0*0.429043*x*y;// ( π / 4 ) * 1.092548
target+=coeff[5]*2.0*0.429043*y*z;
target+=coeff[6]*(0.743125*z*z-0.247708);// ( π / 4 ) * 0.315392 * 3
target+=coeff[7]*2.0*0.429043*x*z;
target+=coeff[8]*0.429043*(x*x-y*y);// ( π / 4 ) * 0.546274

return target;

},

add:function add(sh){

for(var i=0;i<9;i++){

this.coefficients[i].add(sh.coefficients[i]);

}

return this;

},


scale:function scale(s){

for(var i=0;i<9;i++){

this.coefficients[i].multiplyScalar(s);

}

return this;

},

lerp:function lerp(sh,alpha){

for(var i=0;i<9;i++){

this.coefficients[i].lerp(sh.coefficients[i],alpha);

}

return this;

},

equals:function equals(sh){

for(var i=0;i<9;i++){

if(!this.coefficients[i].equals(sh.coefficients[i])){

return false;

}

}

return true;

},

copy:function copy(sh){

return this.set(sh.coefficients);

},

clone:function clone(){

return new this.constructor().copy(this);

},

fromArray:function fromArray(array){

var coefficients=this.coefficients;

for(var i=0;i<9;i++){

coefficients[i].fromArray(array,i*3);

}

return this;

},

toArray:function toArray(){

var array=[];
var coefficients=this.coefficients;

for(var i=0;i<9;i++){

coefficients[i].toArray(array,i*3);

}

return array;

}});



Object.assign(SphericalHarmonics3,{

// evaluate the basis functions
// shBasis is an Array[ 9 ]
getBasisAt:function getBasisAt(normal,shBasis){

// normal is assumed to be unit length

var x=normal.x,y=normal.y,z=normal.z;

// band 0
shBasis[0]=0.282095;

// band 1
shBasis[1]=0.488603*y;
shBasis[2]=0.488603*z;
shBasis[3]=0.488603*x;

// band 2
shBasis[4]=1.092548*x*y;
shBasis[5]=1.092548*y*z;
shBasis[6]=0.315392*(3*z*z-1);
shBasis[7]=1.092548*x*z;
shBasis[8]=0.546274*(x*x-y*y);

}});



/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */

function LightProbe(sh,intensity){

Light.call(this,undefined,intensity);

this.sh=sh!==undefined?sh:new SphericalHarmonics3();

}

LightProbe.prototype=Object.assign(Object.create(Light.prototype),{

constructor:LightProbe,

isLightProbe:true,

copy:function copy(source){

Light.prototype.copy.call(this,source);

this.sh.copy(source.sh);
this.intensity=source.intensity;

return this;

},

toJSON:function toJSON(meta){

var data=Light.prototype.toJSON.call(this,meta);

// data.sh = this.sh.toArray(); // todo

return data;

}});



/**
 * @author WestLangley / http://github.com/WestLangley
 */

function HemisphereLightProbe(skyColor,groundColor,intensity){

LightProbe.call(this,undefined,intensity);

var color1=new Color().set(skyColor);
var color2=new Color().set(groundColor);

var sky=new Vector3(color1.r,color1.g,color1.b);
var ground=new Vector3(color2.r,color2.g,color2.b);

// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
var c0=Math.sqrt(Math.PI);
var c1=c0*Math.sqrt(0.75);

this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);

}

HemisphereLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{

constructor:HemisphereLightProbe,

isHemisphereLightProbe:true,

copy:function copy(source){// modifying colors not currently supported

LightProbe.prototype.copy.call(this,source);

return this;

},

toJSON:function toJSON(meta){

var data=LightProbe.prototype.toJSON.call(this,meta);

// data.sh = this.sh.toArray(); // todo

return data;

}});



/**
 * @author WestLangley / http://github.com/WestLangley
 */

function AmbientLightProbe(color,intensity){

LightProbe.call(this,undefined,intensity);

var color1=new Color().set(color);

// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(color1.r,color1.g,color1.b).multiplyScalar(2*Math.sqrt(Math.PI));

}

AmbientLightProbe.prototype=Object.assign(Object.create(LightProbe.prototype),{

constructor:AmbientLightProbe,

isAmbientLightProbe:true,

copy:function copy(source){// modifying color not currently supported

LightProbe.prototype.copy.call(this,source);

return this;

},

toJSON:function toJSON(meta){

var data=LightProbe.prototype.toJSON.call(this,meta);

// data.sh = this.sh.toArray(); // todo

return data;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera(){

this.type='StereoCamera';

this.aspect=1;

this.eyeSep=0.064;

this.cameraL=new PerspectiveCamera();
this.cameraL.layers.enable(1);
this.cameraL.matrixAutoUpdate=false;

this.cameraR=new PerspectiveCamera();
this.cameraR.layers.enable(2);
this.cameraR.matrixAutoUpdate=false;

}

Object.assign(StereoCamera.prototype,{

update:function(){

var instance,focus,fov,aspect,near,far,zoom,eyeSep;

var eyeRight=new Matrix4();
var eyeLeft=new Matrix4();

return function update(camera){

var needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||
aspect!==camera.aspect*this.aspect||near!==camera.near||
far!==camera.far||zoom!==camera.zoom||eyeSep!==this.eyeSep;

if(needsUpdate){

instance=this;
focus=camera.focus;
fov=camera.fov;
aspect=camera.aspect*this.aspect;
near=camera.near;
far=camera.far;
zoom=camera.zoom;

// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/

var projectionMatrix=camera.projectionMatrix.clone();
eyeSep=this.eyeSep/2;
var eyeSepOnProjection=eyeSep*near/focus;
var ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;
var xmin,xmax;

// translate xOffset

eyeLeft.elements[12]=-eyeSep;
eyeRight.elements[12]=eyeSep;

// for left eye

xmin=-ymax*aspect+eyeSepOnProjection;
xmax=ymax*aspect+eyeSepOnProjection;

projectionMatrix.elements[0]=2*near/(xmax-xmin);
projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);

this.cameraL.projectionMatrix.copy(projectionMatrix);

// for right eye

xmin=-ymax*aspect-eyeSepOnProjection;
xmax=ymax*aspect-eyeSepOnProjection;

projectionMatrix.elements[0]=2*near/(xmax-xmin);
projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);

this.cameraR.projectionMatrix.copy(projectionMatrix);

}

this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);

};

}()});



/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

var fov=90,aspect=1;

function CubeCamera(near,far,cubeResolution,options){

Object3D.call(this);

this.type='CubeCamera';

var cameraPX=new PerspectiveCamera(fov,aspect,near,far);
cameraPX.up.set(0,-1,0);
cameraPX.lookAt(new Vector3(1,0,0));
this.add(cameraPX);

var cameraNX=new PerspectiveCamera(fov,aspect,near,far);
cameraNX.up.set(0,-1,0);
cameraNX.lookAt(new Vector3(-1,0,0));
this.add(cameraNX);

var cameraPY=new PerspectiveCamera(fov,aspect,near,far);
cameraPY.up.set(0,0,1);
cameraPY.lookAt(new Vector3(0,1,0));
this.add(cameraPY);

var cameraNY=new PerspectiveCamera(fov,aspect,near,far);
cameraNY.up.set(0,0,-1);
cameraNY.lookAt(new Vector3(0,-1,0));
this.add(cameraNY);

var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);
cameraPZ.up.set(0,-1,0);
cameraPZ.lookAt(new Vector3(0,0,1));
this.add(cameraPZ);

var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);
cameraNZ.up.set(0,-1,0);
cameraNZ.lookAt(new Vector3(0,0,-1));
this.add(cameraNZ);

options=options||{format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter};

this.renderTarget=new WebGLRenderTargetCube(cubeResolution,cubeResolution,options);
this.renderTarget.texture.name="CubeCamera";

this.update=function(renderer,scene){

if(this.parent===null)this.updateMatrixWorld();

var currentRenderTarget=renderer.getRenderTarget();

var renderTarget=this.renderTarget;
var generateMipmaps=renderTarget.texture.generateMipmaps;

renderTarget.texture.generateMipmaps=false;

renderer.setRenderTarget(renderTarget,0);
renderer.render(scene,cameraPX);

renderer.setRenderTarget(renderTarget,1);
renderer.render(scene,cameraNX);

renderer.setRenderTarget(renderTarget,2);
renderer.render(scene,cameraPY);

renderer.setRenderTarget(renderTarget,3);
renderer.render(scene,cameraNY);

renderer.setRenderTarget(renderTarget,4);
renderer.render(scene,cameraPZ);

renderTarget.texture.generateMipmaps=generateMipmaps;

renderer.setRenderTarget(renderTarget,5);
renderer.render(scene,cameraNZ);

renderer.setRenderTarget(currentRenderTarget);

};

this.clear=function(renderer,color,depth,stencil){

var currentRenderTarget=renderer.getRenderTarget();

var renderTarget=this.renderTarget;

for(var i=0;i<6;i++){

renderer.setRenderTarget(renderTarget,i);

renderer.clear(color,depth,stencil);

}

renderer.setRenderTarget(currentRenderTarget);

};

}

CubeCamera.prototype=Object.create(Object3D.prototype);
CubeCamera.prototype.constructor=CubeCamera;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock(autoStart){

this.autoStart=autoStart!==undefined?autoStart:true;

this.startTime=0;
this.oldTime=0;
this.elapsedTime=0;

this.running=false;

}

Object.assign(Clock.prototype,{

start:function start(){

this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732

this.oldTime=this.startTime;
this.elapsedTime=0;
this.running=true;

},

stop:function stop(){

this.getElapsedTime();
this.running=false;
this.autoStart=false;

},

getElapsedTime:function getElapsedTime(){

this.getDelta();
return this.elapsedTime;

},

getDelta:function getDelta(){

var diff=0;

if(this.autoStart&&!this.running){

this.start();
return 0;

}

if(this.running){

var newTime=(typeof performance==='undefined'?Date:performance).now();

diff=(newTime-this.oldTime)/1000;
this.oldTime=newTime;

this.elapsedTime+=diff;

}

return diff;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioListener(){

Object3D.call(this);

this.type='AudioListener';

this.context=AudioContext.getContext();

this.gain=this.context.createGain();
this.gain.connect(this.context.destination);

this.filter=null;

this.timeDelta=0;

}

AudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:AudioListener,

getInput:function getInput(){

return this.gain;

},

removeFilter:function removeFilter(){

if(this.filter!==null){

this.gain.disconnect(this.filter);
this.filter.disconnect(this.context.destination);
this.gain.connect(this.context.destination);
this.filter=null;

}

return this;

},

getFilter:function getFilter(){

return this.filter;

},

setFilter:function setFilter(value){

if(this.filter!==null){

this.gain.disconnect(this.filter);
this.filter.disconnect(this.context.destination);

}else{

this.gain.disconnect(this.context.destination);

}

this.filter=value;
this.gain.connect(this.filter);
this.filter.connect(this.context.destination);

return this;

},

getMasterVolume:function getMasterVolume(){

return this.gain.gain.value;

},

setMasterVolume:function setMasterVolume(value){

this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);

return this;

},

updateMatrixWorld:function(){

var position=new Vector3();
var quaternion=new Quaternion();
var scale=new Vector3();

var orientation=new Vector3();
var clock=new Clock();

return function updateMatrixWorld(force){

Object3D.prototype.updateMatrixWorld.call(this,force);

var listener=this.context.listener;
var up=this.up;

this.timeDelta=clock.getDelta();

this.matrixWorld.decompose(position,quaternion,scale);

orientation.set(0,0,-1).applyQuaternion(quaternion);

if(listener.positionX){

// code path for Chrome (see #14393)

var endTime=this.context.currentTime+this.timeDelta;

listener.positionX.linearRampToValueAtTime(position.x,endTime);
listener.positionY.linearRampToValueAtTime(position.y,endTime);
listener.positionZ.linearRampToValueAtTime(position.z,endTime);
listener.forwardX.linearRampToValueAtTime(orientation.x,endTime);
listener.forwardY.linearRampToValueAtTime(orientation.y,endTime);
listener.forwardZ.linearRampToValueAtTime(orientation.z,endTime);
listener.upX.linearRampToValueAtTime(up.x,endTime);
listener.upY.linearRampToValueAtTime(up.y,endTime);
listener.upZ.linearRampToValueAtTime(up.z,endTime);

}else{

listener.setPosition(position.x,position.y,position.z);
listener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);

}

};

}()});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio(listener){

Object3D.call(this);

this.type='Audio';

this.listener=listener;
this.context=listener.context;

this.gain=this.context.createGain();
this.gain.connect(listener.getInput());

this.autoplay=false;

this.buffer=null;
this.detune=0;
this.loop=false;
this.startTime=0;
this.offset=0;
this.playbackRate=1;
this.isPlaying=false;
this.hasPlaybackControl=true;
this.sourceType='empty';

this.filters=[];

}

Audio.prototype=Object.assign(Object.create(Object3D.prototype),{

constructor:Audio,

getOutput:function getOutput(){

return this.gain;

},

setNodeSource:function setNodeSource(audioNode){

this.hasPlaybackControl=false;
this.sourceType='audioNode';
this.source=audioNode;
this.connect();

return this;

},

setMediaElementSource:function setMediaElementSource(mediaElement){

this.hasPlaybackControl=false;
this.sourceType='mediaNode';
this.source=this.context.createMediaElementSource(mediaElement);
this.connect();

return this;

},

setBuffer:function setBuffer(audioBuffer){

this.buffer=audioBuffer;
this.sourceType='buffer';

if(this.autoplay)this.play();

return this;

},

play:function play(){

if(this.isPlaying===true){

console.warn('THREE.Audio: Audio is already playing.');
return;

}

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return;

}

var source=this.context.createBufferSource();

source.buffer=this.buffer;
source.loop=this.loop;
source.onended=this.onEnded.bind(this);
this.startTime=this.context.currentTime;
source.start(this.startTime,this.offset);

this.isPlaying=true;

this.source=source;

this.setDetune(this.detune);
this.setPlaybackRate(this.playbackRate);

return this.connect();

},

pause:function pause(){

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return;

}

if(this.isPlaying===true){

this.source.stop();
this.source.onended=null;
this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate;
this.isPlaying=false;

}

return this;

},

stop:function stop(){

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return;

}

this.source.stop();
this.source.onended=null;
this.offset=0;
this.isPlaying=false;

return this;

},

connect:function connect(){

if(this.filters.length>0){

this.source.connect(this.filters[0]);

for(var i=1,l=this.filters.length;i<l;i++){

this.filters[i-1].connect(this.filters[i]);

}

this.filters[this.filters.length-1].connect(this.getOutput());

}else{

this.source.connect(this.getOutput());

}

return this;

},

disconnect:function disconnect(){

if(this.filters.length>0){

this.source.disconnect(this.filters[0]);

for(var i=1,l=this.filters.length;i<l;i++){

this.filters[i-1].disconnect(this.filters[i]);

}

this.filters[this.filters.length-1].disconnect(this.getOutput());

}else{

this.source.disconnect(this.getOutput());

}

return this;

},

getFilters:function getFilters(){

return this.filters;

},

setFilters:function setFilters(value){

if(!value)value=[];

if(this.isPlaying===true){

this.disconnect();
this.filters=value;
this.connect();

}else{

this.filters=value;

}

return this;

},

setDetune:function setDetune(value){

this.detune=value;

if(this.source.detune===undefined)return;// only set detune when available

if(this.isPlaying===true){

this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01);

}

return this;

},

getDetune:function getDetune(){

return this.detune;

},

getFilter:function getFilter(){

return this.getFilters()[0];

},

setFilter:function setFilter(filter){

return this.setFilters(filter?[filter]:[]);

},

setPlaybackRate:function setPlaybackRate(value){

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return;

}

this.playbackRate=value;

if(this.isPlaying===true){

this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01);

}

return this;

},

getPlaybackRate:function getPlaybackRate(){

return this.playbackRate;

},

onEnded:function onEnded(){

this.isPlaying=false;

},

getLoop:function getLoop(){

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return false;

}

return this.loop;

},

setLoop:function setLoop(value){

if(this.hasPlaybackControl===false){

console.warn('THREE.Audio: this Audio has no playback control.');
return;

}

this.loop=value;

if(this.isPlaying===true){

this.source.loop=this.loop;

}

return this;

},

getVolume:function getVolume(){

return this.gain.gain.value;

},

setVolume:function setVolume(value){

this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function PositionalAudio(listener){

Audio.call(this,listener);

this.panner=this.context.createPanner();
this.panner.panningModel='HRTF';
this.panner.connect(this.gain);

}

PositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{

constructor:PositionalAudio,

getOutput:function getOutput(){

return this.panner;

},

getRefDistance:function getRefDistance(){

return this.panner.refDistance;

},

setRefDistance:function setRefDistance(value){

this.panner.refDistance=value;

return this;

},

getRolloffFactor:function getRolloffFactor(){

return this.panner.rolloffFactor;

},

setRolloffFactor:function setRolloffFactor(value){

this.panner.rolloffFactor=value;

return this;

},

getDistanceModel:function getDistanceModel(){

return this.panner.distanceModel;

},

setDistanceModel:function setDistanceModel(value){

this.panner.distanceModel=value;

return this;

},

getMaxDistance:function getMaxDistance(){

return this.panner.maxDistance;

},

setMaxDistance:function setMaxDistance(value){

this.panner.maxDistance=value;

return this;

},

setDirectionalCone:function setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){

this.panner.coneInnerAngle=coneInnerAngle;
this.panner.coneOuterAngle=coneOuterAngle;
this.panner.coneOuterGain=coneOuterGain;

return this;

},

updateMatrixWorld:function(){

var position=new Vector3();
var quaternion=new Quaternion();
var scale=new Vector3();

var orientation=new Vector3();

return function updateMatrixWorld(force){

Object3D.prototype.updateMatrixWorld.call(this,force);

if(this.hasPlaybackControl===true&&this.isPlaying===false)return;

this.matrixWorld.decompose(position,quaternion,scale);

orientation.set(0,0,1).applyQuaternion(quaternion);

var panner=this.panner;

if(panner.positionX){

// code path for Chrome and Firefox (see #14393)

var endTime=this.context.currentTime+this.listener.timeDelta;

panner.positionX.linearRampToValueAtTime(position.x,endTime);
panner.positionY.linearRampToValueAtTime(position.y,endTime);
panner.positionZ.linearRampToValueAtTime(position.z,endTime);
panner.orientationX.linearRampToValueAtTime(orientation.x,endTime);
panner.orientationY.linearRampToValueAtTime(orientation.y,endTime);
panner.orientationZ.linearRampToValueAtTime(orientation.z,endTime);

}else{

panner.setPosition(position.x,position.y,position.z);
panner.setOrientation(orientation.x,orientation.y,orientation.z);

}

};

}()});




/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser(audio,fftSize){

this.analyser=audio.context.createAnalyser();
this.analyser.fftSize=fftSize!==undefined?fftSize:2048;

this.data=new Uint8Array(this.analyser.frequencyBinCount);

audio.getOutput().connect(this.analyser);

}

Object.assign(AudioAnalyser.prototype,{

getFrequencyData:function getFrequencyData(){

this.analyser.getByteFrequencyData(this.data);

return this.data;

},

getAverageFrequency:function getAverageFrequency(){

var value=0,data=this.getFrequencyData();

for(var i=0;i<data.length;i++){

value+=data[i];

}

return value/data.length;

}});



/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer(binding,typeName,valueSize){

this.binding=binding;
this.valueSize=valueSize;

var bufferType=Float64Array,
mixFunction;

switch(typeName){

case'quaternion':
mixFunction=this._slerp;
break;

case'string':
case'bool':
bufferType=Array;
mixFunction=this._select;
break;

default:
mixFunction=this._lerp;}



this.buffer=new bufferType(valueSize*4);
// layout: [ incoming | accu0 | accu1 | orig ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property

this._mixBufferRegion=mixFunction;

this.cumulativeWeight=0;

this.useCount=0;
this.referenceCount=0;

}

Object.assign(PropertyMixer.prototype,{

// accumulate data in the 'incoming' region into 'accu<i>'
accumulate:function accumulate(accuIndex,weight){

// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place

var buffer=this.buffer,
stride=this.valueSize,
offset=accuIndex*stride+stride,

currentWeight=this.cumulativeWeight;

if(currentWeight===0){

// accuN := incoming * weight

for(var i=0;i!==stride;++i){

buffer[offset+i]=buffer[i];

}

currentWeight=weight;

}else{

// accuN := accuN + incoming * weight

currentWeight+=weight;
var mix=weight/currentWeight;
this._mixBufferRegion(buffer,offset,0,mix,stride);

}

this.cumulativeWeight=currentWeight;

},

// apply the state of 'accu<i>' to the binding when accus differ
apply:function apply(accuIndex){

var stride=this.valueSize,
buffer=this.buffer,
offset=accuIndex*stride+stride,

weight=this.cumulativeWeight,

binding=this.binding;

this.cumulativeWeight=0;

if(weight<1){

// accuN := accuN + original * ( 1 - cumulativeWeight )

var originalValueOffset=stride*3;

this._mixBufferRegion(
buffer,offset,originalValueOffset,1-weight,stride);

}

for(var i=stride,e=stride+stride;i!==e;++i){

if(buffer[i]!==buffer[i+stride]){

// value has changed -> update scene graph

binding.setValue(buffer,offset);
break;

}

}

},

// remember the state of the bound property and copy it to both accus
saveOriginalState:function saveOriginalState(){

var binding=this.binding;

var buffer=this.buffer,
stride=this.valueSize,

originalValueOffset=stride*3;

binding.getValue(buffer,originalValueOffset);

// accu[0..1] := orig -- initially detect changes against the original
for(var i=stride,e=originalValueOffset;i!==e;++i){

buffer[i]=buffer[originalValueOffset+i%stride];

}

this.cumulativeWeight=0;

},

// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState:function restoreOriginalState(){

var originalValueOffset=this.valueSize*3;
this.binding.setValue(this.buffer,originalValueOffset);

},


// mix functions

_select:function _select(buffer,dstOffset,srcOffset,t,stride){

if(t>=0.5){

for(var i=0;i!==stride;++i){

buffer[dstOffset+i]=buffer[srcOffset+i];

}

}

},

_slerp:function _slerp(buffer,dstOffset,srcOffset,t){

Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);

},

_lerp:function _lerp(buffer,dstOffset,srcOffset,t,stride){

var s=1-t;

for(var i=0;i!==stride;++i){

var j=dstOffset+i;

buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;

}

}});



/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

// Characters [].:/ are reserved for track binding syntax.
var RESERVED_CHARS_RE='\\[\\]\\.:\\/';

function Composite(targetGroup,path,optionalParsedPath){

var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);

this._targetGroup=targetGroup;
this._bindings=targetGroup.subscribe_(path,parsedPath);

}

Object.assign(Composite.prototype,{

getValue:function getValue(array,offset){

this.bind();// bind all binding

var firstValidIndex=this._targetGroup.nCachedObjects_,
binding=this._bindings[firstValidIndex];

// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);

},

setValue:function setValue(array,offset){

var bindings=this._bindings;

for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){

bindings[i].setValue(array,offset);

}

},

bind:function bind(){

var bindings=this._bindings;

for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){

bindings[i].bind();

}

},

unbind:function unbind(){

var bindings=this._bindings;

for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){

bindings[i].unbind();

}

}});




function PropertyBinding(rootNode,path,parsedPath){

this.path=path;
this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);

this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;

this.rootNode=rootNode;

}

Object.assign(PropertyBinding,{

Composite:Composite,

create:function create(root,path,parsedPath){

if(!(root&&root.isAnimationObjectGroup)){

return new PropertyBinding(root,path,parsedPath);

}else{

return new PropertyBinding.Composite(root,path,parsedPath);

}

},

/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
sanitizeNodeName:function(){

var reservedRe=new RegExp('['+RESERVED_CHARS_RE+']','g');

return function sanitizeNodeName(name){

return name.replace(/\s/g,'_').replace(reservedRe,'');

};

}(),

parseTrackName:function(){

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
var wordChar='[^'+RESERVED_CHARS_RE+']';
var wordCharOrDot='[^'+RESERVED_CHARS_RE.replace('\\.','')+']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',wordChar);

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var nodeRe=/(WCOD+)?/.source.replace('WCOD',wordCharOrDot);

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
var objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',wordChar);

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
var propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',wordChar);

var trackRe=new RegExp(''+
'^'+
directoryRe+
nodeRe+
objectRe+
propertyRe+
'$');


var supportedObjectNames=['material','materials','bones'];

return function parseTrackName(trackName){

var matches=trackRe.exec(trackName);

if(!matches){

throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);

}

var results={
// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],
objectName:matches[3],
objectIndex:matches[4],
propertyName:matches[5],// required
propertyIndex:matches[6]};


var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');

if(lastDot!==undefined&&lastDot!==-1){

var objectName=results.nodeName.substring(lastDot+1);

// Object names must be checked against a whitelist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
if(supportedObjectNames.indexOf(objectName)!==-1){

results.nodeName=results.nodeName.substring(0,lastDot);
results.objectName=objectName;

}

}

if(results.propertyName===null||results.propertyName.length===0){

throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);

}

return results;

};

}(),

findNode:function findNode(root,nodeName){

if(!nodeName||nodeName===""||nodeName==="root"||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){

return root;

}

// search into skeleton bones.
if(root.skeleton){

var bone=root.skeleton.getBoneByName(nodeName);

if(bone!==undefined){

return bone;

}

}

// search into node subtree.
if(root.children){

var searchNodeSubtree=function searchNodeSubtree(children){

for(var i=0;i<children.length;i++){

var childNode=children[i];

if(childNode.name===nodeName||childNode.uuid===nodeName){

return childNode;

}

var result=searchNodeSubtree(childNode.children);

if(result)return result;

}

return null;

};

var subTreeNode=searchNodeSubtree(root.children);

if(subTreeNode){

return subTreeNode;

}

}

return null;

}});



Object.assign(PropertyBinding.prototype,{// prototype, continued

// these are used to "bind" a nonexistent property
_getValue_unavailable:function _getValue_unavailable(){},
_setValue_unavailable:function _setValue_unavailable(){},

BindingType:{
Direct:0,
EntireArray:1,
ArrayElement:2,
HasFromToArray:3},


Versioning:{
None:0,
NeedsUpdate:1,
MatrixWorldNeedsUpdate:2},


GetterByBindingType:[

function getValue_direct(buffer,offset){

buffer[offset]=this.node[this.propertyName];

},

function getValue_array(buffer,offset){

var source=this.resolvedProperty;

for(var i=0,n=source.length;i!==n;++i){

buffer[offset++]=source[i];

}

},

function getValue_arrayElement(buffer,offset){

buffer[offset]=this.resolvedProperty[this.propertyIndex];

},

function getValue_toArray(buffer,offset){

this.resolvedProperty.toArray(buffer,offset);

}],



SetterByBindingTypeAndVersioning:[

[
// Direct

function setValue_direct(buffer,offset){

this.targetObject[this.propertyName]=buffer[offset];

},

function setValue_direct_setNeedsUpdate(buffer,offset){

this.targetObject[this.propertyName]=buffer[offset];
this.targetObject.needsUpdate=true;

},

function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){

this.targetObject[this.propertyName]=buffer[offset];
this.targetObject.matrixWorldNeedsUpdate=true;

}],

[

// EntireArray

function setValue_array(buffer,offset){

var dest=this.resolvedProperty;

for(var i=0,n=dest.length;i!==n;++i){

dest[i]=buffer[offset++];

}

},

function setValue_array_setNeedsUpdate(buffer,offset){

var dest=this.resolvedProperty;

for(var i=0,n=dest.length;i!==n;++i){

dest[i]=buffer[offset++];

}

this.targetObject.needsUpdate=true;

},

function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){

var dest=this.resolvedProperty;

for(var i=0,n=dest.length;i!==n;++i){

dest[i]=buffer[offset++];

}

this.targetObject.matrixWorldNeedsUpdate=true;

}],

[

// ArrayElement

function setValue_arrayElement(buffer,offset){

this.resolvedProperty[this.propertyIndex]=buffer[offset];

},

function setValue_arrayElement_setNeedsUpdate(buffer,offset){

this.resolvedProperty[this.propertyIndex]=buffer[offset];
this.targetObject.needsUpdate=true;

},

function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){

this.resolvedProperty[this.propertyIndex]=buffer[offset];
this.targetObject.matrixWorldNeedsUpdate=true;

}],

[

// HasToFromArray

function setValue_fromArray(buffer,offset){

this.resolvedProperty.fromArray(buffer,offset);

},

function setValue_fromArray_setNeedsUpdate(buffer,offset){

this.resolvedProperty.fromArray(buffer,offset);
this.targetObject.needsUpdate=true;

},

function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){

this.resolvedProperty.fromArray(buffer,offset);
this.targetObject.matrixWorldNeedsUpdate=true;

}]],





getValue:function getValue_unbound(targetArray,offset){

this.bind();
this.getValue(targetArray,offset);

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.

},

setValue:function getValue_unbound(sourceArray,offset){

this.bind();
this.setValue(sourceArray,offset);

},

// create getter / setter pair for a property in the scene graph
bind:function bind(){

var targetObject=this.node,
parsedPath=this.parsedPath,

objectName=parsedPath.objectName,
propertyName=parsedPath.propertyName,
propertyIndex=parsedPath.propertyIndex;

if(!targetObject){

targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;

this.node=targetObject;

}

// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;
this.setValue=this._setValue_unavailable;

// ensure there is a value node
if(!targetObject){

console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');
return;

}

if(objectName){

var objectIndex=parsedPath.objectIndex;

// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){

case'materials':

if(!targetObject.material){

console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);
return;

}

if(!targetObject.material.materials){

console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);
return;

}

targetObject=targetObject.material.materials;

break;

case'bones':

if(!targetObject.skeleton){

console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);
return;

}

// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.

targetObject=targetObject.skeleton.bones;

// support resolving morphTarget names into indices.
for(var i=0;i<targetObject.length;i++){

if(targetObject[i].name===objectIndex){

objectIndex=i;
break;

}

}

break;

default:

if(targetObject[objectName]===undefined){

console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);
return;

}

targetObject=targetObject[objectName];}




if(objectIndex!==undefined){

if(targetObject[objectIndex]===undefined){

console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);
return;

}

targetObject=targetObject[objectIndex];

}

}

// resolve property
var nodeProperty=targetObject[propertyName];

if(nodeProperty===undefined){

var nodeName=parsedPath.nodeName;

console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+
'.'+propertyName+' but it wasn\'t found.',targetObject);
return;

}

// determine versioning scheme
var versioning=this.Versioning.None;

this.targetObject=targetObject;

if(targetObject.needsUpdate!==undefined){// material

versioning=this.Versioning.NeedsUpdate;

}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform

versioning=this.Versioning.MatrixWorldNeedsUpdate;

}

// determine how the property gets bound
var bindingType=this.BindingType.Direct;

if(propertyIndex!==undefined){

// access a sub element of the property array (only primitives are supported right now)

if(propertyName==="morphTargetInfluences"){

// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

// support resolving morphTarget names into indices.
if(!targetObject.geometry){

console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);
return;

}

if(targetObject.geometry.isBufferGeometry){

if(!targetObject.geometry.morphAttributes){

console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);
return;

}

for(var i=0;i<this.node.geometry.morphAttributes.position.length;i++){

if(targetObject.geometry.morphAttributes.position[i].name===propertyIndex){

propertyIndex=i;
break;

}

}


}else{

if(!targetObject.geometry.morphTargets){

console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',this);
return;

}

for(var i=0;i<this.node.geometry.morphTargets.length;i++){

if(targetObject.geometry.morphTargets[i].name===propertyIndex){

propertyIndex=i;
break;

}

}

}

}

bindingType=this.BindingType.ArrayElement;

this.resolvedProperty=nodeProperty;
this.propertyIndex=propertyIndex;

}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){

// must use copy for Object3D.Euler/Quaternion

bindingType=this.BindingType.HasFromToArray;

this.resolvedProperty=nodeProperty;

}else if(Array.isArray(nodeProperty)){

bindingType=this.BindingType.EntireArray;

this.resolvedProperty=nodeProperty;

}else{

this.propertyName=propertyName;

}

// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];
this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];

},

unbind:function unbind(){

this.node=null;

// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;
this.setValue=this._setValue_unbound;

}});



//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype,{

// initial state of these methods that calls 'bind'
_getValue_unbound:PropertyBinding.prototype.getValue,
_setValue_unbound:PropertyBinding.prototype.setValue});



/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup(){

this.uuid=_Math.generateUUID();

// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);

this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite

var indices={};
this._indicesByUUID=indices;// for bookkeeping

for(var i=0,n=arguments.length;i!==n;++i){

indices[arguments[i].uuid]=i;

}

this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays

var scope=this;

this.stats={

objects:{
get total(){

return scope._objects.length;

},
get inUse(){

return this.total-scope.nCachedObjects_;

}},

get bindingsPerObject(){

return scope._bindings.length;

}};



}

Object.assign(AnimationObjectGroup.prototype,{

isAnimationObjectGroup:true,

add:function add(){

var objects=this._objects,
nObjects=objects.length,
nCachedObjects=this.nCachedObjects_,
indicesByUUID=this._indicesByUUID,
paths=this._paths,
parsedPaths=this._parsedPaths,
bindings=this._bindings,
nBindings=bindings.length,
knownObject=undefined;

for(var i=0,n=arguments.length;i!==n;++i){

var object=arguments[i],
uuid=object.uuid,
index=indicesByUUID[uuid];

if(index===undefined){

// unknown object -> add it to the ACTIVE region

index=nObjects++;
indicesByUUID[uuid]=index;
objects.push(object);

// accounting is done, now do the same for all bindings

for(var j=0,m=nBindings;j!==m;++j){

bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));

}

}else if(index<nCachedObjects){

knownObject=objects[index];

// move existing object to the ACTIVE region

var firstActiveIndex=--nCachedObjects,
lastCachedObject=objects[firstActiveIndex];

indicesByUUID[lastCachedObject.uuid]=index;
objects[index]=lastCachedObject;

indicesByUUID[uuid]=firstActiveIndex;
objects[firstActiveIndex]=object;

// accounting is done, now do the same for all bindings

for(var j=0,m=nBindings;j!==m;++j){

var bindingsForPath=bindings[j],
lastCached=bindingsForPath[firstActiveIndex],
binding=bindingsForPath[index];

bindingsForPath[index]=lastCached;

if(binding===undefined){

// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist

binding=new PropertyBinding(object,paths[j],parsedPaths[j]);

}

bindingsForPath[firstActiveIndex]=binding;

}

}else if(objects[index]!==knownObject){

console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+
'detected. Clean the caches or recreate your infrastructure when reloading scenes.');

}// else the object is already where we want it to be

}// for arguments

this.nCachedObjects_=nCachedObjects;

},

remove:function remove(){

var objects=this._objects,
nCachedObjects=this.nCachedObjects_,
indicesByUUID=this._indicesByUUID,
bindings=this._bindings,
nBindings=bindings.length;

for(var i=0,n=arguments.length;i!==n;++i){

var object=arguments[i],
uuid=object.uuid,
index=indicesByUUID[uuid];

if(index!==undefined&&index>=nCachedObjects){

// move existing object into the CACHED region

var lastCachedIndex=nCachedObjects++,
firstActiveObject=objects[lastCachedIndex];

indicesByUUID[firstActiveObject.uuid]=index;
objects[index]=firstActiveObject;

indicesByUUID[uuid]=lastCachedIndex;
objects[lastCachedIndex]=object;

// accounting is done, now do the same for all bindings

for(var j=0,m=nBindings;j!==m;++j){

var bindingsForPath=bindings[j],
firstActive=bindingsForPath[lastCachedIndex],
binding=bindingsForPath[index];

bindingsForPath[index]=firstActive;
bindingsForPath[lastCachedIndex]=binding;

}

}

}// for arguments

this.nCachedObjects_=nCachedObjects;

},

// remove & forget
uncache:function uncache(){

var objects=this._objects,
nObjects=objects.length,
nCachedObjects=this.nCachedObjects_,
indicesByUUID=this._indicesByUUID,
bindings=this._bindings,
nBindings=bindings.length;

for(var i=0,n=arguments.length;i!==n;++i){

var object=arguments[i],
uuid=object.uuid,
index=indicesByUUID[uuid];

if(index!==undefined){

delete indicesByUUID[uuid];

if(index<nCachedObjects){

// object is cached, shrink the CACHED region

var firstActiveIndex=--nCachedObjects,
lastCachedObject=objects[firstActiveIndex],
lastIndex=--nObjects,
lastObject=objects[lastIndex];

// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;
objects[index]=lastCachedObject;

// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;
objects[firstActiveIndex]=lastObject;
objects.pop();

// accounting is done, now do the same for all bindings

for(var j=0,m=nBindings;j!==m;++j){

var bindingsForPath=bindings[j],
lastCached=bindingsForPath[firstActiveIndex],
last=bindingsForPath[lastIndex];

bindingsForPath[index]=lastCached;
bindingsForPath[firstActiveIndex]=last;
bindingsForPath.pop();

}

}else{

// object is active, just swap with the last and pop

var lastIndex=--nObjects,
lastObject=objects[lastIndex];

indicesByUUID[lastObject.uuid]=index;
objects[index]=lastObject;
objects.pop();

// accounting is done, now do the same for all bindings

for(var j=0,m=nBindings;j!==m;++j){

var bindingsForPath=bindings[j];

bindingsForPath[index]=bindingsForPath[lastIndex];
bindingsForPath.pop();

}

}// cached or active

}// if object is known

}// for arguments

this.nCachedObjects_=nCachedObjects;

},

// Internal interface used by befriended PropertyBinding.Composite:

subscribe_:function subscribe_(path,parsedPath){

// returns an array of bindings for the given path that is changed
// according to the contained objects in the group

var indicesByPath=this._bindingsIndicesByPath,
index=indicesByPath[path],
bindings=this._bindings;

if(index!==undefined)return bindings[index];

var paths=this._paths,
parsedPaths=this._parsedPaths,
objects=this._objects,
nObjects=objects.length,
nCachedObjects=this.nCachedObjects_,
bindingsForPath=new Array(nObjects);

index=bindings.length;

indicesByPath[path]=index;

paths.push(path);
parsedPaths.push(parsedPath);
bindings.push(bindingsForPath);

for(var i=nCachedObjects,n=objects.length;i!==n;++i){

var object=objects[i];
bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);

}

return bindingsForPath;

},

unsubscribe_:function unsubscribe_(path){

// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'

var indicesByPath=this._bindingsIndicesByPath,
index=indicesByPath[path];

if(index!==undefined){

var paths=this._paths,
parsedPaths=this._parsedPaths,
bindings=this._bindings,
lastBindingsIndex=bindings.length-1,
lastBindings=bindings[lastBindingsIndex],
lastBindingsPath=path[lastBindingsIndex];

indicesByPath[lastBindingsPath]=index;

bindings[index]=lastBindings;
bindings.pop();

parsedPaths[index]=parsedPaths[lastBindingsIndex];
parsedPaths.pop();

paths[index]=paths[lastBindingsIndex];
paths.pop();

}

}});



/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction(mixer,clip,localRoot){

this._mixer=mixer;
this._clip=clip;
this._localRoot=localRoot||null;

var tracks=clip.tracks,
nTracks=tracks.length,
interpolants=new Array(nTracks);

var interpolantSettings={
endingStart:ZeroCurvatureEnding,
endingEnd:ZeroCurvatureEnding};


for(var i=0;i!==nTracks;++i){

var interpolant=tracks[i].createInterpolant(null);
interpolants[i]=interpolant;
interpolant.settings=interpolantSettings;

}

this._interpolantSettings=interpolantSettings;

this._interpolants=interpolants;// bound by the mixer

// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);

this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager

this._timeScaleInterpolant=null;
this._weightInterpolant=null;

this.loop=LoopRepeat;
this._loopCount=-1;

// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;

// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;

this.timeScale=1;
this._effectiveTimeScale=1;

this.weight=1;
this._effectiveWeight=1;

this.repetitions=Infinity;// no. of repetitions when looping

this.paused=false;// true -> zero effective time scale
this.enabled=true;// false -> zero effective weight

this.clampWhenFinished=false;// keep feeding the last frame?

this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end

}

Object.assign(AnimationAction.prototype,{

// State & Scheduling

play:function play(){

this._mixer._activateAction(this);

return this;

},

stop:function stop(){

this._mixer._deactivateAction(this);

return this.reset();

},

reset:function reset(){

this.paused=false;
this.enabled=true;

this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling

return this.stopFading().stopWarping();

},

isRunning:function isRunning(){

return this.enabled&&!this.paused&&this.timeScale!==0&&
this._startTime===null&&this._mixer._isActiveAction(this);

},

// return true when play has been called
isScheduled:function isScheduled(){

return this._mixer._isActiveAction(this);

},

startAt:function startAt(time){

this._startTime=time;

return this;

},

setLoop:function setLoop(mode,repetitions){

this.loop=mode;
this.repetitions=repetitions;

return this;

},

// Weight

// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight:function setEffectiveWeight(weight){

this.weight=weight;

// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;

return this.stopFading();

},

// return the weight considering fading and .enabled
getEffectiveWeight:function getEffectiveWeight(){

return this._effectiveWeight;

},

fadeIn:function fadeIn(duration){

return this._scheduleFading(duration,0,1);

},

fadeOut:function fadeOut(duration){

return this._scheduleFading(duration,1,0);

},

crossFadeFrom:function crossFadeFrom(fadeOutAction,duration,warp){

fadeOutAction.fadeOut(duration);
this.fadeIn(duration);

if(warp){

var fadeInDuration=this._clip.duration,
fadeOutDuration=fadeOutAction._clip.duration,

startEndRatio=fadeOutDuration/fadeInDuration,
endStartRatio=fadeInDuration/fadeOutDuration;

fadeOutAction.warp(1.0,startEndRatio,duration);
this.warp(endStartRatio,1.0,duration);

}

return this;

},

crossFadeTo:function crossFadeTo(fadeInAction,duration,warp){

return fadeInAction.crossFadeFrom(this,duration,warp);

},

stopFading:function stopFading(){

var weightInterpolant=this._weightInterpolant;

if(weightInterpolant!==null){

this._weightInterpolant=null;
this._mixer._takeBackControlInterpolant(weightInterpolant);

}

return this;

},

// Time Scale Control

// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale:function setEffectiveTimeScale(timeScale){

this.timeScale=timeScale;
this._effectiveTimeScale=this.paused?0:timeScale;

return this.stopWarping();

},

// return the time scale considering warping and .paused
getEffectiveTimeScale:function getEffectiveTimeScale(){

return this._effectiveTimeScale;

},

setDuration:function setDuration(duration){

this.timeScale=this._clip.duration/duration;

return this.stopWarping();

},

syncWith:function syncWith(action){

this.time=action.time;
this.timeScale=action.timeScale;

return this.stopWarping();

},

halt:function halt(duration){

return this.warp(this._effectiveTimeScale,0,duration);

},

warp:function warp(startTimeScale,endTimeScale,duration){

var mixer=this._mixer,now=mixer.time,
interpolant=this._timeScaleInterpolant,

timeScale=this.timeScale;

if(interpolant===null){

interpolant=mixer._lendControlInterpolant();
this._timeScaleInterpolant=interpolant;

}

var times=interpolant.parameterPositions,
values=interpolant.sampleValues;

times[0]=now;
times[1]=now+duration;

values[0]=startTimeScale/timeScale;
values[1]=endTimeScale/timeScale;

return this;

},

stopWarping:function stopWarping(){

var timeScaleInterpolant=this._timeScaleInterpolant;

if(timeScaleInterpolant!==null){

this._timeScaleInterpolant=null;
this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

}

return this;

},

// Object Accessors

getMixer:function getMixer(){

return this._mixer;

},

getClip:function getClip(){

return this._clip;

},

getRoot:function getRoot(){

return this._localRoot||this._mixer._root;

},

// Interna

_update:function _update(time,deltaTime,timeDirection,accuIndex){

// called by the mixer

if(!this.enabled){

// call ._updateWeight() to update ._effectiveWeight

this._updateWeight(time);
return;

}

var startTime=this._startTime;

if(startTime!==null){

// check for scheduled start of action

var timeRunning=(time-startTime)*timeDirection;
if(timeRunning<0||timeDirection===0){

return;// yet to come / don't decide when delta = 0

}

// start

this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;

}

// apply time scale and advance time

deltaTime*=this._updateTimeScale(time);
var clipTime=this._updateTime(deltaTime);

// note: _updateTime may disable the action resulting in
// an effective weight of 0

var weight=this._updateWeight(time);

if(weight>0){

var interpolants=this._interpolants;
var propertyMixers=this._propertyBindings;

for(var j=0,m=interpolants.length;j!==m;++j){

interpolants[j].evaluate(clipTime);
propertyMixers[j].accumulate(accuIndex,weight);

}

}

},

_updateWeight:function _updateWeight(time){

var weight=0;

if(this.enabled){

weight=this.weight;
var interpolant=this._weightInterpolant;

if(interpolant!==null){

var interpolantValue=interpolant.evaluate(time)[0];

weight*=interpolantValue;

if(time>interpolant.parameterPositions[1]){

this.stopFading();

if(interpolantValue===0){

// faded out, disable
this.enabled=false;

}

}

}

}

this._effectiveWeight=weight;
return weight;

},

_updateTimeScale:function _updateTimeScale(time){

var timeScale=0;

if(!this.paused){

timeScale=this.timeScale;

var interpolant=this._timeScaleInterpolant;

if(interpolant!==null){

var interpolantValue=interpolant.evaluate(time)[0];

timeScale*=interpolantValue;

if(time>interpolant.parameterPositions[1]){

this.stopWarping();

if(timeScale===0){

// motion has halted, pause
this.paused=true;

}else{

// warp done - apply final time scale
this.timeScale=timeScale;

}

}

}

}

this._effectiveTimeScale=timeScale;
return timeScale;

},

_updateTime:function _updateTime(deltaTime){

var time=this.time+deltaTime;
var duration=this._clip.duration;
var loop=this.loop;
var loopCount=this._loopCount;

var pingPong=loop===LoopPingPong;

if(deltaTime===0){

if(loopCount===-1)return time;

return pingPong&&(loopCount&1)===1?duration-time:time;

}

if(loop===LoopOnce){

if(loopCount===-1){

// just started

this._loopCount=0;
this._setEndings(true,true,false);

}

handle_stop:{

if(time>=duration){

time=duration;

}else if(time<0){

time=0;

}else{

this.time=time;

break handle_stop;

}

if(this.clampWhenFinished)this.paused=true;else
this.enabled=false;

this.time=time;

this._mixer.dispatchEvent({
type:'finished',action:this,
direction:deltaTime<0?-1:1});


}

}else{// repetitive Repeat or PingPong

if(loopCount===-1){

// just started

if(deltaTime>=0){

loopCount=0;

this._setEndings(true,this.repetitions===0,pingPong);

}else{

// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1

this._setEndings(this.repetitions===0,true,pingPong);

}

}

if(time>=duration||time<0){

// wrap around

var loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;

loopCount+=Math.abs(loopDelta);

var pending=this.repetitions-loopCount;

if(pending<=0){

// have to stop (switch state, clamp time, fire event)

if(this.clampWhenFinished)this.paused=true;else
this.enabled=false;

time=deltaTime>0?duration:0;

this.time=time;

this._mixer.dispatchEvent({
type:'finished',action:this,
direction:deltaTime>0?1:-1});


}else{

// keep running

if(pending===1){

// entering the last round

var atStart=deltaTime<0;
this._setEndings(atStart,!atStart,pingPong);

}else{

this._setEndings(false,false,pingPong);

}

this._loopCount=loopCount;

this.time=time;

this._mixer.dispatchEvent({
type:'loop',action:this,loopDelta:loopDelta});


}

}else{

this.time=time;

}

if(pingPong&&(loopCount&1)===1){

// invert time for the "pong round"

return duration-time;

}

}

return time;

},

_setEndings:function _setEndings(atStart,atEnd,pingPong){

var settings=this._interpolantSettings;

if(pingPong){

settings.endingStart=ZeroSlopeEnding;
settings.endingEnd=ZeroSlopeEnding;

}else{

// assuming for LoopOnce atStart == atEnd == true

if(atStart){

settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;

}else{

settings.endingStart=WrapAroundEnding;

}

if(atEnd){

settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;

}else{

settings.endingEnd=WrapAroundEnding;

}

}

},

_scheduleFading:function _scheduleFading(duration,weightNow,weightThen){

var mixer=this._mixer,now=mixer.time,
interpolant=this._weightInterpolant;

if(interpolant===null){

interpolant=mixer._lendControlInterpolant();
this._weightInterpolant=interpolant;

}

var times=interpolant.parameterPositions,
values=interpolant.sampleValues;

times[0]=now;
values[0]=weightNow;
times[1]=now+duration;
values[1]=weightThen;

return this;

}});



/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer(root){

this._root=root;
this._initMemoryManager();
this._accuIndex=0;

this.time=0;

this.timeScale=1.0;

}

AnimationMixer.prototype=Object.assign(Object.create(EventDispatcher.prototype),{

constructor:AnimationMixer,

_bindAction:function _bindAction(action,prototypeAction){

var root=action._localRoot||this._root,
tracks=action._clip.tracks,
nTracks=tracks.length,
bindings=action._propertyBindings,
interpolants=action._interpolants,
rootUuid=root.uuid,
bindingsByRoot=this._bindingsByRootAndName,
bindingsByName=bindingsByRoot[rootUuid];

if(bindingsByName===undefined){

bindingsByName={};
bindingsByRoot[rootUuid]=bindingsByName;

}

for(var i=0;i!==nTracks;++i){

var track=tracks[i],
trackName=track.name,
binding=bindingsByName[trackName];

if(binding!==undefined){

bindings[i]=binding;

}else{

binding=bindings[i];

if(binding!==undefined){

// existing binding, make sure the cache knows

if(binding._cacheIndex===null){

++binding.referenceCount;
this._addInactiveBinding(binding,rootUuid,trackName);

}

continue;

}

var path=prototypeAction&&prototypeAction.
_propertyBindings[i].binding.parsedPath;

binding=new PropertyMixer(
PropertyBinding.create(root,trackName,path),
track.ValueTypeName,track.getValueSize());

++binding.referenceCount;
this._addInactiveBinding(binding,rootUuid,trackName);

bindings[i]=binding;

}

interpolants[i].resultBuffer=binding.buffer;

}

},

_activateAction:function _activateAction(action){

if(!this._isActiveAction(action)){

if(action._cacheIndex===null){

// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind

var rootUuid=(action._localRoot||this._root).uuid,
clipUuid=action._clip.uuid,
actionsForClip=this._actionsByClip[clipUuid];

this._bindAction(action,
actionsForClip&&actionsForClip.knownActions[0]);

this._addInactiveAction(action,clipUuid,rootUuid);

}

var bindings=action._propertyBindings;

// increment reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){

var binding=bindings[i];

if(binding.useCount++===0){

this._lendBinding(binding);
binding.saveOriginalState();

}

}

this._lendAction(action);

}

},

_deactivateAction:function _deactivateAction(action){

if(this._isActiveAction(action)){

var bindings=action._propertyBindings;

// decrement reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){

var binding=bindings[i];

if(--binding.useCount===0){

binding.restoreOriginalState();
this._takeBackBinding(binding);

}

}

this._takeBackAction(action);

}

},

// Memory manager

_initMemoryManager:function _initMemoryManager(){

this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;

this._actionsByClip={};
// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }


this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;

this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >


this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;

var scope=this;

this.stats={

actions:{
get total(){

return scope._actions.length;

},
get inUse(){

return scope._nActiveActions;

}},

bindings:{
get total(){

return scope._bindings.length;

},
get inUse(){

return scope._nActiveBindings;

}},

controlInterpolants:{
get total(){

return scope._controlInterpolants.length;

},
get inUse(){

return scope._nActiveControlInterpolants;

}}};




},

// Memory management for AnimationAction objects

_isActiveAction:function _isActiveAction(action){

var index=action._cacheIndex;
return index!==null&&index<this._nActiveActions;

},

_addInactiveAction:function _addInactiveAction(action,clipUuid,rootUuid){

var actions=this._actions,
actionsByClip=this._actionsByClip,
actionsForClip=actionsByClip[clipUuid];

if(actionsForClip===undefined){

actionsForClip={

knownActions:[action],
actionByRoot:{}};



action._byClipCacheIndex=0;

actionsByClip[clipUuid]=actionsForClip;

}else{

var knownActions=actionsForClip.knownActions;

action._byClipCacheIndex=knownActions.length;
knownActions.push(action);

}

action._cacheIndex=actions.length;
actions.push(action);

actionsForClip.actionByRoot[rootUuid]=action;

},

_removeInactiveAction:function _removeInactiveAction(action){

var actions=this._actions,
lastInactiveAction=actions[actions.length-1],
cacheIndex=action._cacheIndex;

lastInactiveAction._cacheIndex=cacheIndex;
actions[cacheIndex]=lastInactiveAction;
actions.pop();

action._cacheIndex=null;


var clipUuid=action._clip.uuid,
actionsByClip=this._actionsByClip,
actionsForClip=actionsByClip[clipUuid],
knownActionsForClip=actionsForClip.knownActions,

lastKnownAction=
knownActionsForClip[knownActionsForClip.length-1],

byClipCacheIndex=action._byClipCacheIndex;

lastKnownAction._byClipCacheIndex=byClipCacheIndex;
knownActionsForClip[byClipCacheIndex]=lastKnownAction;
knownActionsForClip.pop();

action._byClipCacheIndex=null;


var actionByRoot=actionsForClip.actionByRoot,
rootUuid=(action._localRoot||this._root).uuid;

delete actionByRoot[rootUuid];

if(knownActionsForClip.length===0){

delete actionsByClip[clipUuid];

}

this._removeInactiveBindingsForAction(action);

},

_removeInactiveBindingsForAction:function _removeInactiveBindingsForAction(action){

var bindings=action._propertyBindings;
for(var i=0,n=bindings.length;i!==n;++i){

var binding=bindings[i];

if(--binding.referenceCount===0){

this._removeInactiveBinding(binding);

}

}

},

_lendAction:function _lendAction(action){

// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s

var actions=this._actions,
prevIndex=action._cacheIndex,

lastActiveIndex=this._nActiveActions++,

firstInactiveAction=actions[lastActiveIndex];

action._cacheIndex=lastActiveIndex;
actions[lastActiveIndex]=action;

firstInactiveAction._cacheIndex=prevIndex;
actions[prevIndex]=firstInactiveAction;

},

_takeBackAction:function _takeBackAction(action){

// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a

var actions=this._actions,
prevIndex=action._cacheIndex,

firstInactiveIndex=--this._nActiveActions,

lastActiveAction=actions[firstInactiveIndex];

action._cacheIndex=firstInactiveIndex;
actions[firstInactiveIndex]=action;

lastActiveAction._cacheIndex=prevIndex;
actions[prevIndex]=lastActiveAction;

},

// Memory management for PropertyMixer objects

_addInactiveBinding:function _addInactiveBinding(binding,rootUuid,trackName){

var bindingsByRoot=this._bindingsByRootAndName,
bindingByName=bindingsByRoot[rootUuid],

bindings=this._bindings;

if(bindingByName===undefined){

bindingByName={};
bindingsByRoot[rootUuid]=bindingByName;

}

bindingByName[trackName]=binding;

binding._cacheIndex=bindings.length;
bindings.push(binding);

},

_removeInactiveBinding:function _removeInactiveBinding(binding){

var bindings=this._bindings,
propBinding=binding.binding,
rootUuid=propBinding.rootNode.uuid,
trackName=propBinding.path,
bindingsByRoot=this._bindingsByRootAndName,
bindingByName=bindingsByRoot[rootUuid],

lastInactiveBinding=bindings[bindings.length-1],
cacheIndex=binding._cacheIndex;

lastInactiveBinding._cacheIndex=cacheIndex;
bindings[cacheIndex]=lastInactiveBinding;
bindings.pop();

delete bindingByName[trackName];

remove_empty_map:{

for(var _ in bindingByName){break remove_empty_map;}// eslint-disable-line no-unused-vars

delete bindingsByRoot[rootUuid];

}

},

_lendBinding:function _lendBinding(binding){

var bindings=this._bindings,
prevIndex=binding._cacheIndex,

lastActiveIndex=this._nActiveBindings++,

firstInactiveBinding=bindings[lastActiveIndex];

binding._cacheIndex=lastActiveIndex;
bindings[lastActiveIndex]=binding;

firstInactiveBinding._cacheIndex=prevIndex;
bindings[prevIndex]=firstInactiveBinding;

},

_takeBackBinding:function _takeBackBinding(binding){

var bindings=this._bindings,
prevIndex=binding._cacheIndex,

firstInactiveIndex=--this._nActiveBindings,

lastActiveBinding=bindings[firstInactiveIndex];

binding._cacheIndex=firstInactiveIndex;
bindings[firstInactiveIndex]=binding;

lastActiveBinding._cacheIndex=prevIndex;
bindings[prevIndex]=lastActiveBinding;

},


// Memory management of Interpolants for weight and time scale

_lendControlInterpolant:function _lendControlInterpolant(){

var interpolants=this._controlInterpolants,
lastActiveIndex=this._nActiveControlInterpolants++,
interpolant=interpolants[lastActiveIndex];

if(interpolant===undefined){

interpolant=new LinearInterpolant(
new Float32Array(2),new Float32Array(2),
1,this._controlInterpolantsResultBuffer);

interpolant.__cacheIndex=lastActiveIndex;
interpolants[lastActiveIndex]=interpolant;

}

return interpolant;

},

_takeBackControlInterpolant:function _takeBackControlInterpolant(interpolant){

var interpolants=this._controlInterpolants,
prevIndex=interpolant.__cacheIndex,

firstInactiveIndex=--this._nActiveControlInterpolants,

lastActiveInterpolant=interpolants[firstInactiveIndex];

interpolant.__cacheIndex=firstInactiveIndex;
interpolants[firstInactiveIndex]=interpolant;

lastActiveInterpolant.__cacheIndex=prevIndex;
interpolants[prevIndex]=lastActiveInterpolant;

},

_controlInterpolantsResultBuffer:new Float32Array(1),

// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction:function clipAction(clip,optionalRoot){

var root=optionalRoot||this._root,
rootUuid=root.uuid,

clipObject=typeof clip==='string'?
AnimationClip.findByName(root,clip):clip,

clipUuid=clipObject!==null?clipObject.uuid:clip,

actionsForClip=this._actionsByClip[clipUuid],
prototypeAction=null;

if(actionsForClip!==undefined){

var existingAction=
actionsForClip.actionByRoot[rootUuid];

if(existingAction!==undefined){

return existingAction;

}

// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];

// also, take the clip from the prototype action
if(clipObject===null)
clipObject=prototypeAction._clip;

}

// clip must be known when specified via string
if(clipObject===null)return null;

// allocate all resources required to run it
var newAction=new AnimationAction(this,clipObject,optionalRoot);

this._bindAction(newAction,prototypeAction);

// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);

return newAction;

},

// get an existing action
existingAction:function existingAction(clip,optionalRoot){

var root=optionalRoot||this._root,
rootUuid=root.uuid,

clipObject=typeof clip==='string'?
AnimationClip.findByName(root,clip):clip,

clipUuid=clipObject?clipObject.uuid:clip,

actionsForClip=this._actionsByClip[clipUuid];

if(actionsForClip!==undefined){

return actionsForClip.actionByRoot[rootUuid]||null;

}

return null;

},

// deactivates all previously scheduled actions
stopAllAction:function stopAllAction(){

var actions=this._actions,
nActions=this._nActiveActions,
bindings=this._bindings,
nBindings=this._nActiveBindings;

this._nActiveActions=0;
this._nActiveBindings=0;

for(var i=0;i!==nActions;++i){

actions[i].reset();

}

for(var i=0;i!==nBindings;++i){

bindings[i].useCount=0;

}

return this;

},

// advance the time and update apply the animation
update:function update(deltaTime){

deltaTime*=this.timeScale;

var actions=this._actions,
nActions=this._nActiveActions,

time=this.time+=deltaTime,
timeDirection=Math.sign(deltaTime),

accuIndex=this._accuIndex^=1;

// run active actions

for(var i=0;i!==nActions;++i){

var action=actions[i];

action._update(time,deltaTime,timeDirection,accuIndex);

}

// update scene graph

var bindings=this._bindings,
nBindings=this._nActiveBindings;

for(var i=0;i!==nBindings;++i){

bindings[i].apply(accuIndex);

}

return this;

},

// return this mixer's root target object
getRoot:function getRoot(){

return this._root;

},

// free all resources specific to a particular clip
uncacheClip:function uncacheClip(clip){

var actions=this._actions,
clipUuid=clip.uuid,
actionsByClip=this._actionsByClip,
actionsForClip=actionsByClip[clipUuid];

if(actionsForClip!==undefined){

// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away

var actionsToRemove=actionsForClip.knownActions;

for(var i=0,n=actionsToRemove.length;i!==n;++i){

var action=actionsToRemove[i];

this._deactivateAction(action);

var cacheIndex=action._cacheIndex,
lastInactiveAction=actions[actions.length-1];

action._cacheIndex=null;
action._byClipCacheIndex=null;

lastInactiveAction._cacheIndex=cacheIndex;
actions[cacheIndex]=lastInactiveAction;
actions.pop();

this._removeInactiveBindingsForAction(action);

}

delete actionsByClip[clipUuid];

}

},

// free all resources specific to a particular root target object
uncacheRoot:function uncacheRoot(root){

var rootUuid=root.uuid,
actionsByClip=this._actionsByClip;

for(var clipUuid in actionsByClip){

var actionByRoot=actionsByClip[clipUuid].actionByRoot,
action=actionByRoot[rootUuid];

if(action!==undefined){

this._deactivateAction(action);
this._removeInactiveAction(action);

}

}

var bindingsByRoot=this._bindingsByRootAndName,
bindingByName=bindingsByRoot[rootUuid];

if(bindingByName!==undefined){

for(var trackName in bindingByName){

var binding=bindingByName[trackName];
binding.restoreOriginalState();
this._removeInactiveBinding(binding);

}

}

},

// remove a targeted clip from the cache
uncacheAction:function uncacheAction(clip,optionalRoot){

var action=this.existingAction(clip,optionalRoot);

if(action!==null){

this._deactivateAction(action);
this._removeInactiveAction(action);

}

}});



/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform(value){

if(typeof value==='string'){

console.warn('THREE.Uniform: Type parameter is no longer needed.');
value=arguments[1];

}

this.value=value;

}

Uniform.prototype.clone=function(){

return new Uniform(this.value.clone===undefined?this.value:this.value.clone());

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer(array,stride,meshPerAttribute){

InterleavedBuffer.call(this,array,stride);

this.meshPerAttribute=meshPerAttribute||1;

}

InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{

constructor:InstancedInterleavedBuffer,

isInstancedInterleavedBuffer:true,

copy:function copy(source){

InterleavedBuffer.prototype.copy.call(this,source);

this.meshPerAttribute=source.meshPerAttribute;

return this;

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster(origin,direction,near,far){

this.ray=new Ray(origin,direction);
// direction is assumed to be normalized (for accurate distance calculations)

this.near=near||0;
this.far=far||Infinity;

this.params={
Mesh:{},
Line:{},
LOD:{},
Points:{threshold:1},
Sprite:{}};


Object.defineProperties(this.params,{
PointCloud:{
get:function get(){

console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
return this.Points;

}}});



}

function ascSort(a,b){

return a.distance-b.distance;

}

function _intersectObject(object,raycaster,intersects,recursive){

if(object.visible===false)return;

object.raycast(raycaster,intersects);

if(recursive===true){

var children=object.children;

for(var i=0,l=children.length;i<l;i++){

_intersectObject(children[i],raycaster,intersects,true);

}

}

}

Object.assign(Raycaster.prototype,{

linePrecision:1,

set:function set(origin,direction){

// direction is assumed to be normalized (for accurate distance calculations)

this.ray.set(origin,direction);

},

setFromCamera:function setFromCamera(coords,camera){

if(camera&&camera.isPerspectiveCamera){

this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();

}else if(camera&&camera.isOrthographicCamera){

this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);

}else{

console.error('THREE.Raycaster: Unsupported camera type.');

}

},

intersectObject:function intersectObject(object,recursive,optionalTarget){

var intersects=optionalTarget||[];

_intersectObject(object,this,intersects,recursive);

intersects.sort(ascSort);

return intersects;

},

intersectObjects:function intersectObjects(objects,recursive,optionalTarget){

var intersects=optionalTarget||[];

if(Array.isArray(objects)===false){

console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
return intersects;

}

for(var i=0,l=objects.length;i<l;i++){

_intersectObject(objects[i],this,intersects,recursive);

}

intersects.sort(ascSort);

return intersects;

}});



/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axiz.
 */

function Spherical(radius,phi,theta){

this.radius=radius!==undefined?radius:1.0;
this.phi=phi!==undefined?phi:0;// polar angle
this.theta=theta!==undefined?theta:0;// azimuthal angle

return this;

}

Object.assign(Spherical.prototype,{

set:function set(radius,phi,theta){

this.radius=radius;
this.phi=phi;
this.theta=theta;

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(other){

this.radius=other.radius;
this.phi=other.phi;
this.theta=other.theta;

return this;

},

// restrict phi to be betwee EPS and PI-EPS
makeSafe:function makeSafe(){

var EPS=0.000001;
this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));

return this;

},

setFromVector3:function setFromVector3(v){

return this.setFromCartesianCoords(v.x,v.y,v.z);

},

setFromCartesianCoords:function setFromCartesianCoords(x,y,z){

this.radius=Math.sqrt(x*x+y*y+z*z);

if(this.radius===0){

this.theta=0;
this.phi=0;

}else{

this.theta=Math.atan2(x,z);
this.phi=Math.acos(_Math.clamp(y/this.radius,-1,1));

}

return this;

}});



/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical(radius,theta,y){

this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y!==undefined?y:0;// height above the x-z plane

return this;

}

Object.assign(Cylindrical.prototype,{

set:function set(radius,theta,y){

this.radius=radius;
this.theta=theta;
this.y=y;

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(other){

this.radius=other.radius;
this.theta=other.theta;
this.y=other.y;

return this;

},

setFromVector3:function setFromVector3(v){

return this.setFromCartesianCoords(v.x,v.y,v.z);

},

setFromCartesianCoords:function setFromCartesianCoords(x,y,z){

this.radius=Math.sqrt(x*x+z*z);
this.theta=Math.atan2(x,z);
this.y=y;

return this;

}});



/**
 * @author bhouston / http://clara.io
 */

function Box2(min,max){

this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);
this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);

}

Object.assign(Box2.prototype,{

set:function set(min,max){

this.min.copy(min);
this.max.copy(max);

return this;

},

setFromPoints:function setFromPoints(points){

this.makeEmpty();

for(var i=0,il=points.length;i<il;i++){

this.expandByPoint(points[i]);

}

return this;

},

setFromCenterAndSize:function(){

var v1=new Vector2();

return function setFromCenterAndSize(center,size){

var halfSize=v1.copy(size).multiplyScalar(0.5);
this.min.copy(center).sub(halfSize);
this.max.copy(center).add(halfSize);

return this;

};

}(),

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(box){

this.min.copy(box.min);
this.max.copy(box.max);

return this;

},

makeEmpty:function makeEmpty(){

this.min.x=this.min.y=+Infinity;
this.max.x=this.max.y=-Infinity;

return this;

},

isEmpty:function isEmpty(){

// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

return this.max.x<this.min.x||this.max.y<this.min.y;

},

getCenter:function getCenter(target){

if(target===undefined){

console.warn('THREE.Box2: .getCenter() target is now required');
target=new Vector2();

}

return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);

},

getSize:function getSize(target){

if(target===undefined){

console.warn('THREE.Box2: .getSize() target is now required');
target=new Vector2();

}

return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min);

},

expandByPoint:function expandByPoint(point){

this.min.min(point);
this.max.max(point);

return this;

},

expandByVector:function expandByVector(vector){

this.min.sub(vector);
this.max.add(vector);

return this;

},

expandByScalar:function expandByScalar(scalar){

this.min.addScalar(-scalar);
this.max.addScalar(scalar);

return this;

},

containsPoint:function containsPoint(point){

return point.x<this.min.x||point.x>this.max.x||
point.y<this.min.y||point.y>this.max.y?false:true;

},

containsBox:function containsBox(box){

return this.min.x<=box.min.x&&box.max.x<=this.max.x&&
this.min.y<=box.min.y&&box.max.y<=this.max.y;

},

getParameter:function getParameter(point,target){

// This can potentially have a divide by zero if the box
// has a size dimension of 0.

if(target===undefined){

console.warn('THREE.Box2: .getParameter() target is now required');
target=new Vector2();

}

return target.set(
(point.x-this.min.x)/(this.max.x-this.min.x),
(point.y-this.min.y)/(this.max.y-this.min.y));


},

intersectsBox:function intersectsBox(box){

// using 4 splitting planes to rule out intersections

return box.max.x<this.min.x||box.min.x>this.max.x||
box.max.y<this.min.y||box.min.y>this.max.y?false:true;

},

clampPoint:function clampPoint(point,target){

if(target===undefined){

console.warn('THREE.Box2: .clampPoint() target is now required');
target=new Vector2();

}

return target.copy(point).clamp(this.min,this.max);

},

distanceToPoint:function(){

var v1=new Vector2();

return function distanceToPoint(point){

var clampedPoint=v1.copy(point).clamp(this.min,this.max);
return clampedPoint.sub(point).length();

};

}(),

intersect:function intersect(box){

this.min.max(box.min);
this.max.min(box.max);

return this;

},

union:function union(box){

this.min.min(box.min);
this.max.max(box.max);

return this;

},

translate:function translate(offset){

this.min.add(offset);
this.max.add(offset);

return this;

},

equals:function equals(box){

return box.min.equals(this.min)&&box.max.equals(this.max);

}});



/**
 * @author bhouston / http://clara.io
 */

function Line3(start,end){

this.start=start!==undefined?start:new Vector3();
this.end=end!==undefined?end:new Vector3();

}

Object.assign(Line3.prototype,{

set:function set(start,end){

this.start.copy(start);
this.end.copy(end);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

},

copy:function copy(line){

this.start.copy(line.start);
this.end.copy(line.end);

return this;

},

getCenter:function getCenter(target){

if(target===undefined){

console.warn('THREE.Line3: .getCenter() target is now required');
target=new Vector3();

}

return target.addVectors(this.start,this.end).multiplyScalar(0.5);

},

delta:function delta(target){

if(target===undefined){

console.warn('THREE.Line3: .delta() target is now required');
target=new Vector3();

}

return target.subVectors(this.end,this.start);

},

distanceSq:function distanceSq(){

return this.start.distanceToSquared(this.end);

},

distance:function distance(){

return this.start.distanceTo(this.end);

},

at:function at(t,target){

if(target===undefined){

console.warn('THREE.Line3: .at() target is now required');
target=new Vector3();

}

return this.delta(target).multiplyScalar(t).add(this.start);

},

closestPointToPointParameter:function(){

var startP=new Vector3();
var startEnd=new Vector3();

return function closestPointToPointParameter(point,clampToLine){

startP.subVectors(point,this.start);
startEnd.subVectors(this.end,this.start);

var startEnd2=startEnd.dot(startEnd);
var startEnd_startP=startEnd.dot(startP);

var t=startEnd_startP/startEnd2;

if(clampToLine){

t=_Math.clamp(t,0,1);

}

return t;

};

}(),

closestPointToPoint:function closestPointToPoint(point,clampToLine,target){

var t=this.closestPointToPointParameter(point,clampToLine);

if(target===undefined){

console.warn('THREE.Line3: .closestPointToPoint() target is now required');
target=new Vector3();

}

return this.delta(target).multiplyScalar(t).add(this.start);

},

applyMatrix4:function applyMatrix4(matrix){

this.start.applyMatrix4(matrix);
this.end.applyMatrix4(matrix);

return this;

},

equals:function equals(line){

return line.start.equals(this.start)&&line.end.equals(this.end);

}});



/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject(material){

Object3D.call(this);

this.material=material;
this.render=function()/* renderCallback */{};

}

ImmediateRenderObject.prototype=Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject=true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function VertexNormalsHelper(object,size,hex,linewidth){

this.object=object;

this.size=size!==undefined?size:1;

var color=hex!==undefined?hex:0xff0000;

var width=linewidth!==undefined?linewidth:1;

//

var nNormals=0;

var objGeometry=this.object.geometry;

if(objGeometry&&objGeometry.isGeometry){

nNormals=objGeometry.faces.length*3;

}else if(objGeometry&&objGeometry.isBufferGeometry){

nNormals=objGeometry.attributes.normal.count;

}

//

var geometry=new BufferGeometry();

var positions=new Float32BufferAttribute(nNormals*2*3,3);

geometry.addAttribute('position',positions);

LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));

//

this.matrixAutoUpdate=false;

this.update();

}

VertexNormalsHelper.prototype=Object.create(LineSegments.prototype);
VertexNormalsHelper.prototype.constructor=VertexNormalsHelper;

VertexNormalsHelper.prototype.update=function(){

var v1=new Vector3();
var v2=new Vector3();
var normalMatrix=new Matrix3();

return function update(){

var keys=['a','b','c'];

this.object.updateMatrixWorld(true);

normalMatrix.getNormalMatrix(this.object.matrixWorld);

var matrixWorld=this.object.matrixWorld;

var position=this.geometry.attributes.position;

//

var objGeometry=this.object.geometry;

if(objGeometry&&objGeometry.isGeometry){

var vertices=objGeometry.vertices;

var faces=objGeometry.faces;

var idx=0;

for(var i=0,l=faces.length;i<l;i++){

var face=faces[i];

for(var j=0,jl=face.vertexNormals.length;j<jl;j++){

var vertex=vertices[face[keys[j]]];

var normal=face.vertexNormals[j];

v1.copy(vertex).applyMatrix4(matrixWorld);

v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

position.setXYZ(idx,v1.x,v1.y,v1.z);

idx=idx+1;

position.setXYZ(idx,v2.x,v2.y,v2.z);

idx=idx+1;

}

}

}else if(objGeometry&&objGeometry.isBufferGeometry){

var objPos=objGeometry.attributes.position;

var objNorm=objGeometry.attributes.normal;

var idx=0;

// for simplicity, ignore index and drawcalls, and render every normal

for(var j=0,jl=objPos.count;j<jl;j++){

v1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);

v2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));

v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

position.setXYZ(idx,v1.x,v1.y,v1.z);

idx=idx+1;

position.setXYZ(idx,v2.x,v2.y,v2.z);

idx=idx+1;

}

}

position.needsUpdate=true;

};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function SpotLightHelper(light,color){

Object3D.call(this);

this.light=light;
this.light.updateMatrixWorld();

this.matrix=light.matrixWorld;
this.matrixAutoUpdate=false;

this.color=color;

var geometry=new BufferGeometry();

var positions=[
0,0,0,0,0,1,
0,0,0,1,0,1,
0,0,0,-1,0,1,
0,0,0,0,1,1,
0,0,0,0,-1,1];


for(var i=0,j=1,l=32;i<l;i++,j++){

var p1=i/l*Math.PI*2;
var p2=j/l*Math.PI*2;

positions.push(
Math.cos(p1),Math.sin(p1),1,
Math.cos(p2),Math.sin(p2),1);


}

geometry.addAttribute('position',new Float32BufferAttribute(positions,3));

var material=new LineBasicMaterial({fog:false});

this.cone=new LineSegments(geometry,material);
this.add(this.cone);

this.update();

}

SpotLightHelper.prototype=Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor=SpotLightHelper;

SpotLightHelper.prototype.dispose=function(){

this.cone.geometry.dispose();
this.cone.material.dispose();

};

SpotLightHelper.prototype.update=function(){

var vector=new Vector3();

return function update(){

this.light.updateMatrixWorld();

var coneLength=this.light.distance?this.light.distance:1000;
var coneWidth=coneLength*Math.tan(this.light.angle);

this.cone.scale.set(coneWidth,coneWidth,coneLength);

vector.setFromMatrixPosition(this.light.target.matrixWorld);

this.cone.lookAt(vector);

if(this.color!==undefined){

this.cone.material.color.set(this.color);

}else{

this.cone.material.color.copy(this.light.color);

}

};

}();

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

function getBoneList(object){

var boneList=[];

if(object&&object.isBone){

boneList.push(object);

}

for(var i=0;i<object.children.length;i++){

boneList.push.apply(boneList,getBoneList(object.children[i]));

}

return boneList;

}

function SkeletonHelper(object){

var bones=getBoneList(object);

var geometry=new BufferGeometry();

var vertices=[];
var colors=[];

var color1=new Color(0,0,1);
var color2=new Color(0,1,0);

for(var i=0;i<bones.length;i++){

var bone=bones[i];

if(bone.parent&&bone.parent.isBone){

vertices.push(0,0,0);
vertices.push(0,0,0);
colors.push(color1.r,color1.g,color1.b);
colors.push(color2.r,color2.g,color2.b);

}

}

geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('color',new Float32BufferAttribute(colors,3));

var material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});

LineSegments.call(this,geometry,material);

this.root=object;
this.bones=bones;

this.matrix=object.matrixWorld;
this.matrixAutoUpdate=false;

}

SkeletonHelper.prototype=Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor=SkeletonHelper;

SkeletonHelper.prototype.updateMatrixWorld=function(){

var vector=new Vector3();

var boneMatrix=new Matrix4();
var matrixWorldInv=new Matrix4();

return function updateMatrixWorld(force){

var bones=this.bones;

var geometry=this.geometry;
var position=geometry.getAttribute('position');

matrixWorldInv.getInverse(this.root.matrixWorld);

for(var i=0,j=0;i<bones.length;i++){

var bone=bones[i];

if(bone.parent&&bone.parent.isBone){

boneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);
vector.setFromMatrixPosition(boneMatrix);
position.setXYZ(j,vector.x,vector.y,vector.z);

boneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);
vector.setFromMatrixPosition(boneMatrix);
position.setXYZ(j+1,vector.x,vector.y,vector.z);

j+=2;

}

}

geometry.getAttribute('position').needsUpdate=true;

Object3D.prototype.updateMatrixWorld.call(this,force);

};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper(light,sphereSize,color){

this.light=light;
this.light.updateMatrixWorld();

this.color=color;

var geometry=new SphereBufferGeometry(sphereSize,4,2);
var material=new MeshBasicMaterial({wireframe:true,fog:false});

Mesh.call(this,geometry,material);

this.matrix=this.light.matrixWorld;
this.matrixAutoUpdate=false;

this.update();


/*
	var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype=Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor=PointLightHelper;

PointLightHelper.prototype.dispose=function(){

this.geometry.dispose();
this.material.dispose();

};

PointLightHelper.prototype.update=function(){

if(this.color!==undefined){

this.material.color.set(this.color);

}else{

this.material.color.copy(this.light.color);

}

/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 * @author WestLangley / http://github.com/WestLangley
 *
 *  This helper must be added as a child of the light
 */

function RectAreaLightHelper(light,color){

this.type='RectAreaLightHelper';

this.light=light;

this.color=color;// optional hardwired color for the helper

var positions=[1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0];

var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute(positions,3));
geometry.computeBoundingSphere();

var material=new LineBasicMaterial({fog:false});

Line.call(this,geometry,material);

//

var positions2=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0];

var geometry2=new BufferGeometry();
geometry2.addAttribute('position',new Float32BufferAttribute(positions2,3));
geometry2.computeBoundingSphere();

this.add(new Mesh(geometry2,new MeshBasicMaterial({side:BackSide,fog:false})));

this.update();

}

RectAreaLightHelper.prototype=Object.create(Line.prototype);
RectAreaLightHelper.prototype.constructor=RectAreaLightHelper;

RectAreaLightHelper.prototype.update=function(){

this.scale.set(0.5*this.light.width,0.5*this.light.height,1);

if(this.color!==undefined){

this.material.color.set(this.color);
this.children[0].material.color.set(this.color);

}else{

this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

// prevent hue shift
var c=this.material.color;
var max=Math.max(c.r,c.g,c.b);
if(max>1)c.multiplyScalar(1/max);

this.children[0].material.color.copy(this.material.color);

}

};

RectAreaLightHelper.prototype.dispose=function(){

this.geometry.dispose();
this.material.dispose();
this.children[0].geometry.dispose();
this.children[0].material.dispose();

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function HemisphereLightHelper(light,size,color){

Object3D.call(this);

this.light=light;
this.light.updateMatrixWorld();

this.matrix=light.matrixWorld;
this.matrixAutoUpdate=false;

this.color=color;

var geometry=new OctahedronBufferGeometry(size);
geometry.rotateY(Math.PI*0.5);

this.material=new MeshBasicMaterial({wireframe:true,fog:false});
if(this.color===undefined)this.material.vertexColors=VertexColors;

var position=geometry.getAttribute('position');
var colors=new Float32Array(position.count*3);

geometry.addAttribute('color',new BufferAttribute(colors,3));

this.add(new Mesh(geometry,this.material));

this.update();

}

HemisphereLightHelper.prototype=Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose=function(){

this.children[0].geometry.dispose();
this.children[0].material.dispose();

};

HemisphereLightHelper.prototype.update=function(){

var vector=new Vector3();

var color1=new Color();
var color2=new Color();

return function update(){

var mesh=this.children[0];

if(this.color!==undefined){

this.material.color.set(this.color);

}else{

var colors=mesh.geometry.getAttribute('color');

color1.copy(this.light.color);
color2.copy(this.light.groundColor);

for(var i=0,l=colors.count;i<l;i++){

var color=i<l/2?color1:color2;

colors.setXYZ(i,color.r,color.g,color.b);

}

colors.needsUpdate=true;

}

mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());

};

}();

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function LightProbeHelper(lightProbe,size){

this.lightProbe=lightProbe;

this.size=size;

var defines={};
defines['GAMMA_OUTPUT']="";

// material
var material=new ShaderMaterial({

defines:defines,

uniforms:{

sh:{value:this.lightProbe.sh.coefficients},// by reference

intensity:{value:this.lightProbe.intensity}},



vertexShader:[

'varying vec3 vNormal;',

'void main() {',

'	vNormal = normalize( normalMatrix * normal );',

'	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',

'}'].

join('\n'),

fragmentShader:[

'#define RECIPROCAL_PI 0.318309886',

'vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {',

'	// matrix is assumed to be orthogonal',

'	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );',

'}',

'vec3 linearToOutput( in vec3 a ) {',

'	#ifdef GAMMA_OUTPUT',

'		return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );',

'	#else',

'		return a;',

'	#endif',

'}',

'// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf',
'vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {',

'	// normal is assumed to have unit length',

'	float x = normal.x, y = normal.y, z = normal.z;',

'	// band 0',
'	vec3 result = shCoefficients[ 0 ] * 0.886227;',

'	// band 1',
'	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;',
'	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;',
'	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;',

'	// band 2',
'	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;',
'	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;',
'	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );',
'	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;',
'	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );',

'	return result;',

'}',

'uniform vec3 sh[ 9 ]; // sh coefficients',

'uniform float intensity; // light probe intensity',

'varying vec3 vNormal;',

'void main() {',

'	vec3 normal = normalize( vNormal );',

'	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );',

'	vec3 irradiance = shGetIrradianceAt( worldNormal, sh );',

'	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',

'	outgoingLight = linearToOutput( outgoingLight );',

'	gl_FragColor = vec4( outgoingLight, 1.0 );',

'}'].

join('\n')});



var geometry=new SphereBufferGeometry(1,32,16);

Mesh.call(this,geometry,material);

this.onBeforeRender();

}

LightProbeHelper.prototype=Object.create(Mesh.prototype);
LightProbeHelper.prototype.constructor=LightProbeHelper;

LightProbeHelper.prototype.dispose=function(){

this.geometry.dispose();
this.material.dispose();

};

LightProbeHelper.prototype.onBeforeRender=function(){

return function update(){

this.position.copy(this.lightProbe.position);

this.scale.set(1,1,1).multiplyScalar(this.size);

this.material.uniforms.intensity.value=this.lightProbe.intensity;

};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper(size,divisions,color1,color2){

size=size||10;
divisions=divisions||10;
color1=new Color(color1!==undefined?color1:0x444444);
color2=new Color(color2!==undefined?color2:0x888888);

var center=divisions/2;
var step=size/divisions;
var halfSize=size/2;

var vertices=[],colors=[];

for(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){

vertices.push(-halfSize,0,k,halfSize,0,k);
vertices.push(k,0,-halfSize,k,0,halfSize);

var color=i===center?color1:color2;

color.toArray(colors,j);j+=3;
color.toArray(colors,j);j+=3;
color.toArray(colors,j);j+=3;
color.toArray(colors,j);j+=3;

}

var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('color',new Float32BufferAttribute(colors,3));

var material=new LineBasicMaterial({vertexColors:VertexColors});

LineSegments.call(this,geometry,material);

}

GridHelper.prototype=Object.assign(Object.create(LineSegments.prototype),{

constructor:GridHelper,

copy:function copy(source){

LineSegments.prototype.copy.call(this,source);

this.geometry.copy(source.geometry);
this.material.copy(source.material);

return this;

},

clone:function clone(){

return new this.constructor().copy(this);

}});



/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper(radius,radials,circles,divisions,color1,color2){

radius=radius||10;
radials=radials||16;
circles=circles||8;
divisions=divisions||64;
color1=new Color(color1!==undefined?color1:0x444444);
color2=new Color(color2!==undefined?color2:0x888888);

var vertices=[];
var colors=[];

var x,z;
var v,i,j,r,color;

// create the radials

for(i=0;i<=radials;i++){

v=i/radials*(Math.PI*2);

x=Math.sin(v)*radius;
z=Math.cos(v)*radius;

vertices.push(0,0,0);
vertices.push(x,0,z);

color=i&1?color1:color2;

colors.push(color.r,color.g,color.b);
colors.push(color.r,color.g,color.b);

}

// create the circles

for(i=0;i<=circles;i++){

color=i&1?color1:color2;

r=radius-radius/circles*i;

for(j=0;j<divisions;j++){

// first vertex

v=j/divisions*(Math.PI*2);

x=Math.sin(v)*r;
z=Math.cos(v)*r;

vertices.push(x,0,z);
colors.push(color.r,color.g,color.b);

// second vertex

v=(j+1)/divisions*(Math.PI*2);

x=Math.sin(v)*r;
z=Math.cos(v)*r;

vertices.push(x,0,z);
colors.push(color.r,color.g,color.b);

}

}

var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('color',new Float32BufferAttribute(colors,3));

var material=new LineBasicMaterial({vertexColors:VertexColors});

LineSegments.call(this,geometry,material);

}

PolarGridHelper.prototype=Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor=PolarGridHelper;

/**
 * @author Mugen87 / http://github.com/Mugen87
 */

function PositionalAudioHelper(audio,range,divisionsInnerAngle,divisionsOuterAngle){

this.audio=audio;
this.range=range||1;
this.divisionsInnerAngle=divisionsInnerAngle||16;
this.divisionsOuterAngle=divisionsOuterAngle||2;

var geometry=new BufferGeometry();
var divisions=this.divisionsInnerAngle+this.divisionsOuterAngle*2;
var positions=new Float32Array((divisions*3+3)*3);
geometry.addAttribute('position',new BufferAttribute(positions,3));

var materialInnerAngle=new LineBasicMaterial({color:0x00ff00});
var materialOuterAngle=new LineBasicMaterial({color:0xffff00});

Line.call(this,geometry,[materialOuterAngle,materialInnerAngle]);

this.update();

}

PositionalAudioHelper.prototype=Object.create(Line.prototype);
PositionalAudioHelper.prototype.constructor=PositionalAudioHelper;

PositionalAudioHelper.prototype.update=function(){

var audio=this.audio;
var range=this.range;
var divisionsInnerAngle=this.divisionsInnerAngle;
var divisionsOuterAngle=this.divisionsOuterAngle;

var coneInnerAngle=_Math.degToRad(audio.panner.coneInnerAngle);
var coneOuterAngle=_Math.degToRad(audio.panner.coneOuterAngle);

var halfConeInnerAngle=coneInnerAngle/2;
var halfConeOuterAngle=coneOuterAngle/2;

var start=0;
var count=0;
var i,stride;

var geometry=this.geometry;
var positionAttribute=geometry.attributes.position;

geometry.clearGroups();

//

function generateSegment(from,to,divisions,materialIndex){

var step=(to-from)/divisions;

positionAttribute.setXYZ(start,0,0,0);
count++;

for(i=from;i<to;i+=step){

stride=start+count;

positionAttribute.setXYZ(stride,Math.sin(i)*range,0,Math.cos(i)*range);
positionAttribute.setXYZ(stride+1,Math.sin(Math.min(i+step,to))*range,0,Math.cos(Math.min(i+step,to))*range);
positionAttribute.setXYZ(stride+2,0,0,0);

count+=3;

}

geometry.addGroup(start,count,materialIndex);

start+=count;
count=0;

}

//

generateSegment(-halfConeOuterAngle,-halfConeInnerAngle,divisionsOuterAngle,0);
generateSegment(-halfConeInnerAngle,halfConeInnerAngle,divisionsInnerAngle,1);
generateSegment(halfConeInnerAngle,halfConeOuterAngle,divisionsOuterAngle,0);

//

positionAttribute.needsUpdate=true;

if(coneInnerAngle===coneOuterAngle)this.material[0].visible=false;

};

PositionalAudioHelper.prototype.dispose=function(){

this.geometry.dispose();
this.material[0].dispose();
this.material[1].dispose();

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function FaceNormalsHelper(object,size,hex,linewidth){

// FaceNormalsHelper only supports THREE.Geometry

this.object=object;

this.size=size!==undefined?size:1;

var color=hex!==undefined?hex:0xffff00;

var width=linewidth!==undefined?linewidth:1;

//

var nNormals=0;

var objGeometry=this.object.geometry;

if(objGeometry&&objGeometry.isGeometry){

nNormals=objGeometry.faces.length;

}else{

console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');

}

//

var geometry=new BufferGeometry();

var positions=new Float32BufferAttribute(nNormals*2*3,3);

geometry.addAttribute('position',positions);

LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));

//

this.matrixAutoUpdate=false;
this.update();

}

FaceNormalsHelper.prototype=Object.create(LineSegments.prototype);
FaceNormalsHelper.prototype.constructor=FaceNormalsHelper;

FaceNormalsHelper.prototype.update=function(){

var v1=new Vector3();
var v2=new Vector3();
var normalMatrix=new Matrix3();

return function update(){

this.object.updateMatrixWorld(true);

normalMatrix.getNormalMatrix(this.object.matrixWorld);

var matrixWorld=this.object.matrixWorld;

var position=this.geometry.attributes.position;

//

var objGeometry=this.object.geometry;

var vertices=objGeometry.vertices;

var faces=objGeometry.faces;

var idx=0;

for(var i=0,l=faces.length;i<l;i++){

var face=faces[i];

var normal=face.normal;

v1.copy(vertices[face.a]).
add(vertices[face.b]).
add(vertices[face.c]).
divideScalar(3).
applyMatrix4(matrixWorld);

v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

position.setXYZ(idx,v1.x,v1.y,v1.z);

idx=idx+1;

position.setXYZ(idx,v2.x,v2.y,v2.z);

idx=idx+1;

}

position.needsUpdate=true;

};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function DirectionalLightHelper(light,size,color){

Object3D.call(this);

this.light=light;
this.light.updateMatrixWorld();

this.matrix=light.matrixWorld;
this.matrixAutoUpdate=false;

this.color=color;

if(size===undefined)size=1;

var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute([
-size,size,0,
size,size,0,
size,-size,0,
-size,-size,0,
-size,size,0],
3));

var material=new LineBasicMaterial({fog:false});

this.lightPlane=new Line(geometry,material);
this.add(this.lightPlane);

geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));

this.targetLine=new Line(geometry,material);
this.add(this.targetLine);

this.update();

}

DirectionalLightHelper.prototype=Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose=function(){

this.lightPlane.geometry.dispose();
this.lightPlane.material.dispose();
this.targetLine.geometry.dispose();
this.targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update=function(){

var v1=new Vector3();
var v2=new Vector3();
var v3=new Vector3();

return function update(){

v1.setFromMatrixPosition(this.light.matrixWorld);
v2.setFromMatrixPosition(this.light.target.matrixWorld);
v3.subVectors(v2,v1);

this.lightPlane.lookAt(v2);

if(this.color!==undefined){

this.lightPlane.material.color.set(this.color);
this.targetLine.material.color.set(this.color);

}else{

this.lightPlane.material.color.copy(this.light.color);
this.targetLine.material.color.copy(this.light.color);

}

this.targetLine.lookAt(v2);
this.targetLine.scale.z=v3.length();

};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

function CameraHelper(camera){

var geometry=new BufferGeometry();
var material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});

var vertices=[];
var colors=[];

var pointMap={};

// colors

var colorFrustum=new Color(0xffaa00);
var colorCone=new Color(0xff0000);
var colorUp=new Color(0x00aaff);
var colorTarget=new Color(0xffffff);
var colorCross=new Color(0x333333);

// near

addLine('n1','n2',colorFrustum);
addLine('n2','n4',colorFrustum);
addLine('n4','n3',colorFrustum);
addLine('n3','n1',colorFrustum);

// far

addLine('f1','f2',colorFrustum);
addLine('f2','f4',colorFrustum);
addLine('f4','f3',colorFrustum);
addLine('f3','f1',colorFrustum);

// sides

addLine('n1','f1',colorFrustum);
addLine('n2','f2',colorFrustum);
addLine('n3','f3',colorFrustum);
addLine('n4','f4',colorFrustum);

// cone

addLine('p','n1',colorCone);
addLine('p','n2',colorCone);
addLine('p','n3',colorCone);
addLine('p','n4',colorCone);

// up

addLine('u1','u2',colorUp);
addLine('u2','u3',colorUp);
addLine('u3','u1',colorUp);

// target

addLine('c','t',colorTarget);
addLine('p','c',colorCross);

// cross

addLine('cn1','cn2',colorCross);
addLine('cn3','cn4',colorCross);

addLine('cf1','cf2',colorCross);
addLine('cf3','cf4',colorCross);

function addLine(a,b,color){

addPoint(a,color);
addPoint(b,color);

}

function addPoint(id,color){

vertices.push(0,0,0);
colors.push(color.r,color.g,color.b);

if(pointMap[id]===undefined){

pointMap[id]=[];

}

pointMap[id].push(vertices.length/3-1);

}

geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('color',new Float32BufferAttribute(colors,3));

LineSegments.call(this,geometry,material);

this.camera=camera;
if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();

this.matrix=camera.matrixWorld;
this.matrixAutoUpdate=false;

this.pointMap=pointMap;

this.update();

}

CameraHelper.prototype=Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor=CameraHelper;

CameraHelper.prototype.update=function(){

var geometry,pointMap;

var vector=new Vector3();
var camera=new Camera();

function setPoint(point,x,y,z){

vector.set(x,y,z).unproject(camera);

var points=pointMap[point];

if(points!==undefined){

var position=geometry.getAttribute('position');

for(var i=0,l=points.length;i<l;i++){

position.setXYZ(points[i],vector.x,vector.y,vector.z);

}

}

}

return function update(){

geometry=this.geometry;
pointMap=this.pointMap;

var w=1,h=1;

// we need just camera projection matrix inverse
// world matrix must be identity

camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

// center / target

setPoint('c',0,0,-1);
setPoint('t',0,0,1);

// near

setPoint('n1',-w,-h,-1);
setPoint('n2',w,-h,-1);
setPoint('n3',-w,h,-1);
setPoint('n4',w,h,-1);

// far

setPoint('f1',-w,-h,1);
setPoint('f2',w,-h,1);
setPoint('f3',-w,h,1);
setPoint('f4',w,h,1);

// up

setPoint('u1',w*0.7,h*1.1,-1);
setPoint('u2',-w*0.7,h*1.1,-1);
setPoint('u3',0,h*2,-1);

// cross

setPoint('cf1',-w,0,1);
setPoint('cf2',w,0,1);
setPoint('cf3',0,-h,1);
setPoint('cf4',0,h,1);

setPoint('cn1',-w,0,-1);
setPoint('cn2',w,0,-1);
setPoint('cn3',0,-h,-1);
setPoint('cn4',0,h,-1);

geometry.getAttribute('position').needsUpdate=true;

};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */

function BoxHelper(object,color){

this.object=object;

if(color===undefined)color=0xffff00;

var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);
var positions=new Float32Array(8*3);

var geometry=new BufferGeometry();
geometry.setIndex(new BufferAttribute(indices,1));
geometry.addAttribute('position',new BufferAttribute(positions,3));

LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));

this.matrixAutoUpdate=false;

this.update();

}

BoxHelper.prototype=Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor=BoxHelper;

BoxHelper.prototype.update=function(){

var box=new Box3();

return function update(object){

if(object!==undefined){

console.warn('THREE.BoxHelper: .update() has no longer arguments.');

}

if(this.object!==undefined){

box.setFromObject(this.object);

}

if(box.isEmpty())return;

var min=box.min;
var max=box.max;

/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

var position=this.geometry.attributes.position;
var array=position.array;

array[0]=max.x;array[1]=max.y;array[2]=max.z;
array[3]=min.x;array[4]=max.y;array[5]=max.z;
array[6]=min.x;array[7]=min.y;array[8]=max.z;
array[9]=max.x;array[10]=min.y;array[11]=max.z;
array[12]=max.x;array[13]=max.y;array[14]=min.z;
array[15]=min.x;array[16]=max.y;array[17]=min.z;
array[18]=min.x;array[19]=min.y;array[20]=min.z;
array[21]=max.x;array[22]=min.y;array[23]=min.z;

position.needsUpdate=true;

this.geometry.computeBoundingSphere();

};

}();

BoxHelper.prototype.setFromObject=function(object){

this.object=object;
this.update();

return this;

};

BoxHelper.prototype.copy=function(source){

LineSegments.prototype.copy.call(this,source);

this.object=source.object;

return this;

};

BoxHelper.prototype.clone=function(){

return new this.constructor().copy(this);

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3Helper(box,hex){

this.type='Box3Helper';

this.box=box;

var color=hex!==undefined?hex:0xffff00;

var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);

var positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];

var geometry=new BufferGeometry();

geometry.setIndex(new BufferAttribute(indices,1));

geometry.addAttribute('position',new Float32BufferAttribute(positions,3));

LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));

this.geometry.computeBoundingSphere();

}

Box3Helper.prototype=Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor=Box3Helper;

Box3Helper.prototype.updateMatrixWorld=function(force){

var box=this.box;

if(box.isEmpty())return;

box.getCenter(this.position);

box.getSize(this.scale);

this.scale.multiplyScalar(0.5);

Object3D.prototype.updateMatrixWorld.call(this,force);

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function PlaneHelper(plane,size,hex){

this.type='PlaneHelper';

this.plane=plane;

this.size=size===undefined?1:size;

var color=hex!==undefined?hex:0xffff00;

var positions=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];

var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute(positions,3));
geometry.computeBoundingSphere();

Line.call(this,geometry,new LineBasicMaterial({color:color}));

//

var positions2=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];

var geometry2=new BufferGeometry();
geometry2.addAttribute('position',new Float32BufferAttribute(positions2,3));
geometry2.computeBoundingSphere();

this.add(new Mesh(geometry2,new MeshBasicMaterial({color:color,opacity:0.2,transparent:true,depthWrite:false})));

}

PlaneHelper.prototype=Object.create(Line.prototype);
PlaneHelper.prototype.constructor=PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld=function(force){

var scale=-this.plane.constant;

if(Math.abs(scale)<1e-8)scale=1e-8;// sign does not matter

this.scale.set(0.5*this.size,0.5*this.size,scale);

this.children[0].material.side=scale<0?BackSide:FrontSide;// renderer flips side when determinant < 0; flipping not wanted here

this.lookAt(this.plane.normal);

Object3D.prototype.updateMatrixWorld.call(this,force);

};

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var lineGeometry,coneGeometry;

function ArrowHelper(dir,origin,length,color,headLength,headWidth){

// dir is assumed to be normalized

Object3D.call(this);

if(dir===undefined)dir=new Vector3(0,0,1);
if(origin===undefined)origin=new Vector3(0,0,0);
if(length===undefined)length=1;
if(color===undefined)color=0xffff00;
if(headLength===undefined)headLength=0.2*length;
if(headWidth===undefined)headWidth=0.2*headLength;

if(lineGeometry===undefined){

lineGeometry=new BufferGeometry();
lineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));

coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);
coneGeometry.translate(0,-0.5,0);

}

this.position.copy(origin);

this.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));
this.line.matrixAutoUpdate=false;
this.add(this.line);

this.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));
this.cone.matrixAutoUpdate=false;
this.add(this.cone);

this.setDirection(dir);
this.setLength(length,headLength,headWidth);

}

ArrowHelper.prototype=Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor=ArrowHelper;

ArrowHelper.prototype.setDirection=function(){

var axis=new Vector3();
var radians;

return function setDirection(dir){

// dir is assumed to be normalized

if(dir.y>0.99999){

this.quaternion.set(0,0,0,1);

}else if(dir.y<-0.99999){

this.quaternion.set(1,0,0,0);

}else{

axis.set(dir.z,0,-dir.x).normalize();

radians=Math.acos(dir.y);

this.quaternion.setFromAxisAngle(axis,radians);

}

};

}();

ArrowHelper.prototype.setLength=function(length,headLength,headWidth){

if(headLength===undefined)headLength=0.2*length;
if(headWidth===undefined)headWidth=0.2*headLength;

this.line.scale.set(1,Math.max(0,length-headLength),1);
this.line.updateMatrix();

this.cone.scale.set(headWidth,headLength,headWidth);
this.cone.position.y=length;
this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor=function(color){

this.line.material.color.copy(color);
this.cone.material.color.copy(color);

};

ArrowHelper.prototype.copy=function(source){

Object3D.prototype.copy.call(this,source,false);

this.line.copy(source.line);
this.cone.copy(source.cone);

return this;

};

ArrowHelper.prototype.clone=function(){

return new this.constructor().copy(this);

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxesHelper(size){

size=size||1;

var vertices=[
0,0,0,size,0,0,
0,0,0,0,size,0,
0,0,0,0,0,size];


var colors=[
1,0,0,1,0.6,0,
0,1,0,0.6,1,0,
0,0,1,0,0.6,1];


var geometry=new BufferGeometry();
geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('color',new Float32BufferAttribute(colors,3));

var material=new LineBasicMaterial({vertexColors:VertexColors});

LineSegments.call(this,geometry,material);

}

AxesHelper.prototype=Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor=AxesHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4(a,b,c,d,normal,color,materialIndex){

console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
return new Face3(a,b,c,normal,color,materialIndex);

}

var LineStrip=0;

var LinePieces=1;

function MeshFaceMaterial(materials){

console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
return materials;

}

function MultiMaterial(materials){

if(materials===undefined)materials=[];

console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
materials.isMultiMaterial=true;
materials.materials=materials;
materials.clone=function(){

return materials.slice();

};
return materials;

}

function PointCloud(geometry,material){

console.warn('THREE.PointCloud has been renamed to THREE.Points.');
return new Points(geometry,material);

}

function Particle(material){

console.warn('THREE.Particle has been renamed to THREE.Sprite.');
return new Sprite(material);

}

function ParticleSystem(geometry,material){

console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
return new Points(geometry,material);

}

function PointCloudMaterial(parameters){

console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);

}

function ParticleBasicMaterial(parameters){

console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);

}

function ParticleSystemMaterial(parameters){

console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
return new PointsMaterial(parameters);

}

function Vertex(x,y,z){

console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
return new Vector3(x,y,z);

}

//

function DynamicBufferAttribute(array,itemSize){

console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
return new BufferAttribute(array,itemSize).setDynamic(true);

}

function Int8Attribute(array,itemSize){

console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
return new Int8BufferAttribute(array,itemSize);

}

function Uint8Attribute(array,itemSize){

console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
return new Uint8BufferAttribute(array,itemSize);

}

function Uint8ClampedAttribute(array,itemSize){

console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
return new Uint8ClampedBufferAttribute(array,itemSize);

}

function Int16Attribute(array,itemSize){

console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
return new Int16BufferAttribute(array,itemSize);

}

function Uint16Attribute(array,itemSize){

console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
return new Uint16BufferAttribute(array,itemSize);

}

function Int32Attribute(array,itemSize){

console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
return new Int32BufferAttribute(array,itemSize);

}

function Uint32Attribute(array,itemSize){

console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
return new Uint32BufferAttribute(array,itemSize);

}

function Float32Attribute(array,itemSize){

console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
return new Float32BufferAttribute(array,itemSize);

}

function Float64Attribute(array,itemSize){

console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
return new Float64BufferAttribute(array,itemSize);

}

//

Curve.create=function(construct,getPoint){

console.log('THREE.Curve.create() has been deprecated');

construct.prototype=Object.create(Curve.prototype);
construct.prototype.constructor=construct;
construct.prototype.getPoint=getPoint;

return construct;

};

//

Object.assign(CurvePath.prototype,{

createPointsGeometry:function createPointsGeometry(divisions){

console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

// generate geometry from path points (for Line or Points objects)

var pts=this.getPoints(divisions);
return this.createGeometry(pts);

},

createSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){

console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

// generate geometry from equidistant sampling along the path

var pts=this.getSpacedPoints(divisions);
return this.createGeometry(pts);

},

createGeometry:function createGeometry(points){

console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

var geometry=new Geometry();

for(var i=0,l=points.length;i<l;i++){

var point=points[i];
geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));

}

return geometry;

}});



//

Object.assign(Path.prototype,{

fromPoints:function fromPoints(points){

console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
this.setFromPoints(points);

}});



//

function ClosedSplineCurve3(points){

console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

CatmullRomCurve3.call(this,points);
this.type='catmullrom';
this.closed=true;

}

ClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);

//

function SplineCurve3(points){

console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

CatmullRomCurve3.call(this,points);
this.type='catmullrom';

}

SplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);

//

function Spline(points){

console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');

CatmullRomCurve3.call(this,points);
this.type='catmullrom';

}

Spline.prototype=Object.create(CatmullRomCurve3.prototype);

Object.assign(Spline.prototype,{

initFromArray:function initFromArray()/* a */{

console.error('THREE.Spline: .initFromArray() has been removed.');

},
getControlPointsArray:function getControlPointsArray()/* optionalTarget */{

console.error('THREE.Spline: .getControlPointsArray() has been removed.');

},
reparametrizeByArcLength:function reparametrizeByArcLength()/* samplingCoef */{

console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');

}});



//

function AxisHelper(size){

console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
return new AxesHelper(size);

}

function BoundingBoxHelper(object,color){

console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
return new BoxHelper(object,color);

}

function EdgesHelper(object,hex){

console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));

}

GridHelper.prototype.setColors=function(){

console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');

};

SkeletonHelper.prototype.update=function(){

console.error('THREE.SkeletonHelper: update() no longer needs to be called.');

};

function WireframeHelper(object,hex){

console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));

}

//

Object.assign(Loader.prototype,{

extractUrlBase:function extractUrlBase(url){

console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
return LoaderUtils.extractUrlBase(url);

}});



function XHRLoader(manager){

console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
return new FileLoader(manager);

}

function BinaryTextureLoader(manager){

console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
return new DataTextureLoader(manager);

}

Object.assign(ObjectLoader.prototype,{

setTexturePath:function setTexturePath(value){

console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
return this.setResourcePath(value);

}});



//

Object.assign(Box2.prototype,{

center:function center(optionalTarget){

console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
return this.getCenter(optionalTarget);

},
empty:function empty(){

console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
return this.isEmpty();

},
isIntersectionBox:function isIntersectionBox(box){

console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);

},
size:function size(optionalTarget){

console.warn('THREE.Box2: .size() has been renamed to .getSize().');
return this.getSize(optionalTarget);

}});


Object.assign(Box3.prototype,{

center:function center(optionalTarget){

console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
return this.getCenter(optionalTarget);

},
empty:function empty(){

console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
return this.isEmpty();

},
isIntersectionBox:function isIntersectionBox(box){

console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);

},
isIntersectionSphere:function isIntersectionSphere(sphere){

console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
return this.intersectsSphere(sphere);

},
size:function size(optionalTarget){

console.warn('THREE.Box3: .size() has been renamed to .getSize().');
return this.getSize(optionalTarget);

}});


Line3.prototype.center=function(optionalTarget){

console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
return this.getCenter(optionalTarget);

};

Object.assign(_Math,{

random16:function random16(){

console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
return Math.random();

},

nearestPowerOfTwo:function nearestPowerOfTwo(value){

console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
return _Math.floorPowerOfTwo(value);

},

nextPowerOfTwo:function nextPowerOfTwo(value){

console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
return _Math.ceilPowerOfTwo(value);

}});



Object.assign(Matrix3.prototype,{

flattenToArrayOffset:function flattenToArrayOffset(array,offset){

console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
return this.toArray(array,offset);

},
multiplyVector3:function multiplyVector3(vector){

console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
return vector.applyMatrix3(this);

},
multiplyVector3Array:function multiplyVector3Array()/* a */{

console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');

},
applyToBuffer:function applyToBuffer(buffer/*, offset, length */){

console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
return this.applyToBufferAttribute(buffer);

},
applyToVector3Array:function applyToVector3Array()/* array, offset, length */{

console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');

}});



Object.assign(Matrix4.prototype,{

extractPosition:function extractPosition(m){

console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
return this.copyPosition(m);

},
flattenToArrayOffset:function flattenToArrayOffset(array,offset){

console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
return this.toArray(array,offset);

},
getPosition:function(){

var v1;

return function getPosition(){

if(v1===undefined)v1=new Vector3();
console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
return v1.setFromMatrixColumn(this,3);

};

}(),
setRotationFromQuaternion:function setRotationFromQuaternion(q){

console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
return this.makeRotationFromQuaternion(q);

},
multiplyToArray:function multiplyToArray(){

console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');

},
multiplyVector3:function multiplyVector3(vector){

console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
return vector.applyMatrix4(this);

},
multiplyVector4:function multiplyVector4(vector){

console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
return vector.applyMatrix4(this);

},
multiplyVector3Array:function multiplyVector3Array()/* a */{

console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');

},
rotateAxis:function rotateAxis(v){

console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
v.transformDirection(this);

},
crossVector:function crossVector(vector){

console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
return vector.applyMatrix4(this);

},
translate:function translate(){

console.error('THREE.Matrix4: .translate() has been removed.');

},
rotateX:function rotateX(){

console.error('THREE.Matrix4: .rotateX() has been removed.');

},
rotateY:function rotateY(){

console.error('THREE.Matrix4: .rotateY() has been removed.');

},
rotateZ:function rotateZ(){

console.error('THREE.Matrix4: .rotateZ() has been removed.');

},
rotateByAxis:function rotateByAxis(){

console.error('THREE.Matrix4: .rotateByAxis() has been removed.');

},
applyToBuffer:function applyToBuffer(buffer/*, offset, length */){

console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
return this.applyToBufferAttribute(buffer);

},
applyToVector3Array:function applyToVector3Array()/* array, offset, length */{

console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');

},
makeFrustum:function makeFrustum(left,right,bottom,top,near,far){

console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
return this.makePerspective(left,right,top,bottom,near,far);

}});



Plane.prototype.isIntersectionLine=function(line){

console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
return this.intersectsLine(line);

};

Quaternion.prototype.multiplyVector3=function(vector){

console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
return vector.applyQuaternion(this);

};

Object.assign(Ray.prototype,{

isIntersectionBox:function isIntersectionBox(box){

console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
return this.intersectsBox(box);

},
isIntersectionPlane:function isIntersectionPlane(plane){

console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
return this.intersectsPlane(plane);

},
isIntersectionSphere:function isIntersectionSphere(sphere){

console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
return this.intersectsSphere(sphere);

}});



Object.assign(Triangle.prototype,{

area:function area(){

console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
return this.getArea();

},
barycoordFromPoint:function barycoordFromPoint(point,target){

console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
return this.getBarycoord(point,target);

},
midpoint:function midpoint(target){

console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
return this.getMidpoint(target);

},
normal:function normal(target){

console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
return this.getNormal(target);

},
plane:function plane(target){

console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
return this.getPlane(target);

}});



Object.assign(Triangle,{

barycoordFromPoint:function barycoordFromPoint(point,a,b,c,target){

console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
return Triangle.getBarycoord(point,a,b,c,target);

},
normal:function normal(a,b,c,target){

console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
return Triangle.getNormal(a,b,c,target);

}});



Object.assign(Shape.prototype,{

extractAllPoints:function extractAllPoints(divisions){

console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
return this.extractPoints(divisions);

},
extrude:function extrude(options){

console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
return new ExtrudeGeometry(this,options);

},
makeGeometry:function makeGeometry(options){

console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
return new ShapeGeometry(this,options);

}});



Object.assign(Vector2.prototype,{

fromAttribute:function fromAttribute(attribute,index,offset){

console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
return this.fromBufferAttribute(attribute,index,offset);

},
distanceToManhattan:function distanceToManhattan(v){

console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
return this.manhattanDistanceTo(v);

},
lengthManhattan:function lengthManhattan(){

console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
return this.manhattanLength();

}});



Object.assign(Vector3.prototype,{

setEulerFromRotationMatrix:function setEulerFromRotationMatrix(){

console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');

},
setEulerFromQuaternion:function setEulerFromQuaternion(){

console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');

},
getPositionFromMatrix:function getPositionFromMatrix(m){

console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
return this.setFromMatrixPosition(m);

},
getScaleFromMatrix:function getScaleFromMatrix(m){

console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
return this.setFromMatrixScale(m);

},
getColumnFromMatrix:function getColumnFromMatrix(index,matrix){

console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
return this.setFromMatrixColumn(matrix,index);

},
applyProjection:function applyProjection(m){

console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
return this.applyMatrix4(m);

},
fromAttribute:function fromAttribute(attribute,index,offset){

console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
return this.fromBufferAttribute(attribute,index,offset);

},
distanceToManhattan:function distanceToManhattan(v){

console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
return this.manhattanDistanceTo(v);

},
lengthManhattan:function lengthManhattan(){

console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
return this.manhattanLength();

}});



Object.assign(Vector4.prototype,{

fromAttribute:function fromAttribute(attribute,index,offset){

console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
return this.fromBufferAttribute(attribute,index,offset);

},
lengthManhattan:function lengthManhattan(){

console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
return this.manhattanLength();

}});



//

Object.assign(Geometry.prototype,{

computeTangents:function computeTangents(){

console.error('THREE.Geometry: .computeTangents() has been removed.');

},
computeLineDistances:function computeLineDistances(){

console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');

}});



Object.assign(Object3D.prototype,{

getChildByName:function getChildByName(name){

console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
return this.getObjectByName(name);

},
renderDepth:function renderDepth(){

console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');

},
translate:function translate(distance,axis){

console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
return this.translateOnAxis(axis,distance);

},
getWorldRotation:function getWorldRotation(){

console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');

}});



Object.defineProperties(Object3D.prototype,{

eulerOrder:{
get:function get(){

console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
return this.rotation.order;

},
set:function set(value){

console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
this.rotation.order=value;

}},

useQuaternion:{
get:function get(){

console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

},
set:function set(){

console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');

}}});




Object.defineProperties(LOD.prototype,{

objects:{
get:function get(){

console.warn('THREE.LOD: .objects has been renamed to .levels.');
return this.levels;

}}});




Object.defineProperty(Skeleton.prototype,'useVertexTexture',{

get:function get(){

console.warn('THREE.Skeleton: useVertexTexture has been removed.');

},
set:function set(){

console.warn('THREE.Skeleton: useVertexTexture has been removed.');

}});



SkinnedMesh.prototype.initBones=function(){

console.error('THREE.SkinnedMesh: initBones() has been removed.');

};

Object.defineProperty(Curve.prototype,'__arcLengthDivisions',{

get:function get(){

console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
return this.arcLengthDivisions;

},
set:function set(value){

console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
this.arcLengthDivisions=value;

}});



//

PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){

console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+
"Use .setFocalLength and .filmGauge for a photographic setup.");

if(filmGauge!==undefined)this.filmGauge=filmGauge;
this.setFocalLength(focalLength);

};

//

Object.defineProperties(Light.prototype,{
onlyShadow:{
set:function set(){

console.warn('THREE.Light: .onlyShadow has been removed.');

}},

shadowCameraFov:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
this.shadow.camera.fov=value;

}},

shadowCameraLeft:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
this.shadow.camera.left=value;

}},

shadowCameraRight:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
this.shadow.camera.right=value;

}},

shadowCameraTop:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
this.shadow.camera.top=value;

}},

shadowCameraBottom:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
this.shadow.camera.bottom=value;

}},

shadowCameraNear:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
this.shadow.camera.near=value;

}},

shadowCameraFar:{
set:function set(value){

console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
this.shadow.camera.far=value;

}},

shadowCameraVisible:{
set:function set(){

console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');

}},

shadowBias:{
set:function set(value){

console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
this.shadow.bias=value;

}},

shadowDarkness:{
set:function set(){

console.warn('THREE.Light: .shadowDarkness has been removed.');

}},

shadowMapWidth:{
set:function set(value){

console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
this.shadow.mapSize.width=value;

}},

shadowMapHeight:{
set:function set(value){

console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
this.shadow.mapSize.height=value;

}}});



//

Object.defineProperties(BufferAttribute.prototype,{

length:{
get:function get(){

console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
return this.array.length;

}},

copyIndicesArray:function copyIndicesArray()/* indices */{

console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');

}});



Object.assign(BufferGeometry.prototype,{

addIndex:function addIndex(index){

console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
this.setIndex(index);

},
addDrawCall:function addDrawCall(start,count,indexOffset){

if(indexOffset!==undefined){

console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');

}
console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
this.addGroup(start,count);

},
clearDrawCalls:function clearDrawCalls(){

console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
this.clearGroups();

},
computeTangents:function computeTangents(){

console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');

},
computeOffsets:function computeOffsets(){

console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');

}});



Object.defineProperties(BufferGeometry.prototype,{

drawcalls:{
get:function get(){

console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
return this.groups;

}},

offsets:{
get:function get(){

console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
return this.groups;

}}});




//

Object.assign(ExtrudeBufferGeometry.prototype,{

getArrays:function getArrays(){

console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');

},

addShapeList:function addShapeList(){

console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');

},

addShape:function addShape(){

console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');

}});



//

Object.defineProperties(Uniform.prototype,{

dynamic:{
set:function set(){

console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');

}},

onUpdate:{
value:function value(){

console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
return this;

}}});




//

Object.defineProperties(Material.prototype,{

wrapAround:{
get:function get(){

console.warn('THREE.Material: .wrapAround has been removed.');

},
set:function set(){

console.warn('THREE.Material: .wrapAround has been removed.');

}},


overdraw:{
get:function get(){

console.warn('THREE.Material: .overdraw has been removed.');

},
set:function set(){

console.warn('THREE.Material: .overdraw has been removed.');

}},


wrapRGB:{
get:function get(){

console.warn('THREE.Material: .wrapRGB has been removed.');
return new Color();

}},


shading:{
get:function get(){

console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');

},
set:function set(value){

console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');
this.flatShading=value===FlatShading;

}}});




Object.defineProperties(MeshPhongMaterial.prototype,{

metal:{
get:function get(){

console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
return false;

},
set:function set(){

console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');

}}});




Object.defineProperties(ShaderMaterial.prototype,{

derivatives:{
get:function get(){

console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
return this.extensions.derivatives;

},
set:function set(value){

console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
this.extensions.derivatives=value;

}}});




//

Object.assign(WebGLRenderer.prototype,{

clearTarget:function clearTarget(renderTarget,color,depth,stencil){

console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
this.setRenderTarget(renderTarget);
this.clear(color,depth,stencil);

},
animate:function animate(callback){

console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
this.setAnimationLoop(callback);

},
getCurrentRenderTarget:function getCurrentRenderTarget(){

console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
return this.getRenderTarget();

},
getMaxAnisotropy:function getMaxAnisotropy(){

console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
return this.capabilities.getMaxAnisotropy();

},
getPrecision:function getPrecision(){

console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
return this.capabilities.precision;

},
resetGLState:function resetGLState(){

console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
return this.state.reset();

},
supportsFloatTextures:function supportsFloatTextures(){

console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
return this.extensions.get('OES_texture_float');

},
supportsHalfFloatTextures:function supportsHalfFloatTextures(){

console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
return this.extensions.get('OES_texture_half_float');

},
supportsStandardDerivatives:function supportsStandardDerivatives(){

console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
return this.extensions.get('OES_standard_derivatives');

},
supportsCompressedTextureS3TC:function supportsCompressedTextureS3TC(){

console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
return this.extensions.get('WEBGL_compressed_texture_s3tc');

},
supportsCompressedTexturePVRTC:function supportsCompressedTexturePVRTC(){

console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
return this.extensions.get('WEBGL_compressed_texture_pvrtc');

},
supportsBlendMinMax:function supportsBlendMinMax(){

console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
return this.extensions.get('EXT_blend_minmax');

},
supportsVertexTextures:function supportsVertexTextures(){

console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
return this.capabilities.vertexTextures;

},
supportsInstancedArrays:function supportsInstancedArrays(){

console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
return this.extensions.get('ANGLE_instanced_arrays');

},
enableScissorTest:function enableScissorTest(boolean){

console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
this.setScissorTest(boolean);

},
initMaterial:function initMaterial(){

console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');

},
addPrePlugin:function addPrePlugin(){

console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');

},
addPostPlugin:function addPostPlugin(){

console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');

},
updateShadowMap:function updateShadowMap(){

console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');

},
setFaceCulling:function setFaceCulling(){

console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');

},
allocTextureUnit:function allocTextureUnit(){

console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');

},
setTexture:function setTexture(){

console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');

},
setTexture2D:function setTexture2D(){

console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');

},
setTextureCube:function setTextureCube(){

console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');

}});



Object.defineProperties(WebGLRenderer.prototype,{

shadowMapEnabled:{
get:function get(){

return this.shadowMap.enabled;

},
set:function set(value){

console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
this.shadowMap.enabled=value;

}},

shadowMapType:{
get:function get(){

return this.shadowMap.type;

},
set:function set(value){

console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
this.shadowMap.type=value;

}},

shadowMapCullFace:{
get:function get(){

console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
return undefined;

},
set:function set()/* value */{

console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');

}}});



Object.defineProperties(WebGLShadowMap.prototype,{

cullFace:{
get:function get(){

console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
return undefined;

},
set:function set()/* cullFace */{

console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');

}},

renderReverseSided:{
get:function get(){

console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
return undefined;

},
set:function set(){

console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');

}},

renderSingleSided:{
get:function get(){

console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
return undefined;

},
set:function set(){

console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');

}}});




//

Object.defineProperties(WebGLRenderTargetCube.prototype,{

activeCubeFace:{
set:function set()/* value */{

console.warn('THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().');

}},

activeMipMapLevel:{
set:function set()/* value */{

console.warn('THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().');

}}});




//

Object.defineProperties(WebGLRenderTarget.prototype,{

wrapS:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
return this.texture.wrapS;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
this.texture.wrapS=value;

}},

wrapT:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
return this.texture.wrapT;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
this.texture.wrapT=value;

}},

magFilter:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
return this.texture.magFilter;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
this.texture.magFilter=value;

}},

minFilter:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
return this.texture.minFilter;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
this.texture.minFilter=value;

}},

anisotropy:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
return this.texture.anisotropy;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
this.texture.anisotropy=value;

}},

offset:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
return this.texture.offset;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
this.texture.offset=value;

}},

repeat:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
return this.texture.repeat;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
this.texture.repeat=value;

}},

format:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
return this.texture.format;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
this.texture.format=value;

}},

type:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
return this.texture.type;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
this.texture.type=value;

}},

generateMipmaps:{
get:function get(){

console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
return this.texture.generateMipmaps;

},
set:function set(value){

console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
this.texture.generateMipmaps=value;

}}});




//

Object.defineProperties(WebVRManager.prototype,{

standing:{
set:function set()/* value */{

console.warn('THREE.WebVRManager: .standing has been removed.');

}},

userHeight:{
set:function set()/* value */{

console.warn('THREE.WebVRManager: .userHeight has been removed.');

}}});




//

Audio.prototype.load=function(file){

console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
var scope=this;
var audioLoader=new AudioLoader();
audioLoader.load(file,function(buffer){

scope.setBuffer(buffer);

});
return this;

};

AudioAnalyser.prototype.getData=function(){

console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap=function(renderer,scene){

console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
return this.update(renderer,scene);

};

//

var GeometryUtils={

merge:function merge(geometry1,geometry2,materialIndexOffset){

console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
var matrix;

if(geometry2.isMesh){

geometry2.matrixAutoUpdate&&geometry2.updateMatrix();

matrix=geometry2.matrix;
geometry2=geometry2.geometry;

}

geometry1.merge(geometry2,matrix,materialIndexOffset);

},

center:function center(geometry){

console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
return geometry.center();

}};



ImageUtils.crossOrigin=undefined;

ImageUtils.loadTexture=function(url,mapping,onLoad,onError){

console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

var loader=new TextureLoader();
loader.setCrossOrigin(this.crossOrigin);

var texture=loader.load(url,onLoad,undefined,onError);

if(mapping)texture.mapping=mapping;

return texture;

};

ImageUtils.loadTextureCube=function(urls,mapping,onLoad,onError){

console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

var loader=new CubeTextureLoader();
loader.setCrossOrigin(this.crossOrigin);

var texture=loader.load(urls,onLoad,undefined,onError);

if(mapping)texture.mapping=mapping;

return texture;

};

ImageUtils.loadCompressedTexture=function(){

console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');

};

ImageUtils.loadCompressedTextureCube=function(){

console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');

};

//

function CanvasRenderer(){

console.error('THREE.CanvasRenderer has been removed');

}

//

function JSONLoader(){

console.error('THREE.JSONLoader has been removed.');

}

//

var SceneUtils={

createMultiMaterialObject:function createMultiMaterialObject()/* geometry, materials */{

console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');

},

detach:function detach()/* child, parent, scene */{

console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');

},

attach:function attach()/* child, scene, parent */{

console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');

}};



//

function LensFlare(){

console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');

}



// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/OBJLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 */



var OBJLoader_OBJLoader=function(){

// o object_name | g group_name
var object_pattern=/^[og]\s*(.+)?/;
// mtllib file_reference
var material_library_pattern=/^mtllib /;
// usemtl material_name
var material_use_pattern=/^usemtl /;

function ParserState(){

var state={
objects:[],
object:{},

vertices:[],
normals:[],
colors:[],
uvs:[],

materialLibraries:[],

startObject:function startObject(name,fromDeclaration){

// If the current object (initial from reset) is not from a g/o declaration in the parsed
// file. We need to use it for the first parsed g/o to keep things in sync.
if(this.object&&this.object.fromDeclaration===false){

this.object.name=name;
this.object.fromDeclaration=fromDeclaration!==false;
return;

}

var previousMaterial=this.object&&typeof this.object.currentMaterial==='function'?this.object.currentMaterial():undefined;

if(this.object&&typeof this.object._finalize==='function'){

this.object._finalize(true);

}

this.object={
name:name||'',
fromDeclaration:fromDeclaration!==false,

geometry:{
vertices:[],
normals:[],
colors:[],
uvs:[]},

materials:[],
smooth:true,

startMaterial:function startMaterial(name,libraries){

var previous=this._finalize(false);

// New usemtl declaration overwrites an inherited material, except if faces were declared
// after the material, then it must be preserved for proper MultiMaterial continuation.
if(previous&&(previous.inherited||previous.groupCount<=0)){

this.materials.splice(previous.index,1);

}

var material={
index:this.materials.length,
name:name||'',
mtllib:Array.isArray(libraries)&&libraries.length>0?libraries[libraries.length-1]:'',
smooth:previous!==undefined?previous.smooth:this.smooth,
groupStart:previous!==undefined?previous.groupEnd:0,
groupEnd:-1,
groupCount:-1,
inherited:false,

clone:function clone(index){

var cloned={
index:typeof index==='number'?index:this.index,
name:this.name,
mtllib:this.mtllib,
smooth:this.smooth,
groupStart:0,
groupEnd:-1,
groupCount:-1,
inherited:false};

cloned.clone=this.clone.bind(cloned);
return cloned;

}};


this.materials.push(material);

return material;

},

currentMaterial:function currentMaterial(){

if(this.materials.length>0){

return this.materials[this.materials.length-1];

}

return undefined;

},

_finalize:function _finalize(end){

var lastMultiMaterial=this.currentMaterial();
if(lastMultiMaterial&&lastMultiMaterial.groupEnd===-1){

lastMultiMaterial.groupEnd=this.geometry.vertices.length/3;
lastMultiMaterial.groupCount=lastMultiMaterial.groupEnd-lastMultiMaterial.groupStart;
lastMultiMaterial.inherited=false;

}

// Ignore objects tail materials if no face declarations followed them before a new o/g started.
if(end&&this.materials.length>1){

for(var mi=this.materials.length-1;mi>=0;mi--){

if(this.materials[mi].groupCount<=0){

this.materials.splice(mi,1);

}

}

}

// Guarantee at least one empty material, this makes the creation later more straight forward.
if(end&&this.materials.length===0){

this.materials.push({
name:'',
smooth:this.smooth});


}

return lastMultiMaterial;

}};


// Inherit previous objects material.
// Spec tells us that a declared material must be set to all objects until a new material is declared.
// If a usemtl declaration is encountered while this new object is being parsed, it will
// overwrite the inherited material. Exception being that there was already face declarations
// to the inherited material, then it will be preserved for proper MultiMaterial continuation.

if(previousMaterial&&previousMaterial.name&&typeof previousMaterial.clone==='function'){

var declared=previousMaterial.clone(0);
declared.inherited=true;
this.object.materials.push(declared);

}

this.objects.push(this.object);

},

finalize:function finalize(){

if(this.object&&typeof this.object._finalize==='function'){

this.object._finalize(true);

}

},

parseVertexIndex:function parseVertexIndex(value,len){

var index=parseInt(value,10);
return(index>=0?index-1:index+len/3)*3;

},

parseNormalIndex:function parseNormalIndex(value,len){

var index=parseInt(value,10);
return(index>=0?index-1:index+len/3)*3;

},

parseUVIndex:function parseUVIndex(value,len){

var index=parseInt(value,10);
return(index>=0?index-1:index+len/2)*2;

},

addVertex:function addVertex(a,b,c){

var src=this.vertices;
var dst=this.object.geometry.vertices;

dst.push(src[a+0],src[a+1],src[a+2]);
dst.push(src[b+0],src[b+1],src[b+2]);
dst.push(src[c+0],src[c+1],src[c+2]);

},

addVertexPoint:function addVertexPoint(a){

var src=this.vertices;
var dst=this.object.geometry.vertices;

dst.push(src[a+0],src[a+1],src[a+2]);

},

addVertexLine:function addVertexLine(a){

var src=this.vertices;
var dst=this.object.geometry.vertices;

dst.push(src[a+0],src[a+1],src[a+2]);

},

addNormal:function addNormal(a,b,c){

var src=this.normals;
var dst=this.object.geometry.normals;

dst.push(src[a+0],src[a+1],src[a+2]);
dst.push(src[b+0],src[b+1],src[b+2]);
dst.push(src[c+0],src[c+1],src[c+2]);

},

addColor:function addColor(a,b,c){

var src=this.colors;
var dst=this.object.geometry.colors;

dst.push(src[a+0],src[a+1],src[a+2]);
dst.push(src[b+0],src[b+1],src[b+2]);
dst.push(src[c+0],src[c+1],src[c+2]);

},

addUV:function addUV(a,b,c){

var src=this.uvs;
var dst=this.object.geometry.uvs;

dst.push(src[a+0],src[a+1]);
dst.push(src[b+0],src[b+1]);
dst.push(src[c+0],src[c+1]);

},

addUVLine:function addUVLine(a){

var src=this.uvs;
var dst=this.object.geometry.uvs;

dst.push(src[a+0],src[a+1]);

},

addFace:function addFace(a,b,c,ua,ub,uc,na,nb,nc){

var vLen=this.vertices.length;

var ia=this.parseVertexIndex(a,vLen);
var ib=this.parseVertexIndex(b,vLen);
var ic=this.parseVertexIndex(c,vLen);

this.addVertex(ia,ib,ic);

if(ua!==undefined&&ua!==''){

var uvLen=this.uvs.length;
ia=this.parseUVIndex(ua,uvLen);
ib=this.parseUVIndex(ub,uvLen);
ic=this.parseUVIndex(uc,uvLen);
this.addUV(ia,ib,ic);

}

if(na!==undefined&&na!==''){

// Normals are many times the same. If so, skip function call and parseInt.
var nLen=this.normals.length;
ia=this.parseNormalIndex(na,nLen);

ib=na===nb?ia:this.parseNormalIndex(nb,nLen);
ic=na===nc?ia:this.parseNormalIndex(nc,nLen);

this.addNormal(ia,ib,ic);

}

if(this.colors.length>0){

this.addColor(ia,ib,ic);

}

},

addPointGeometry:function addPointGeometry(vertices){

this.object.geometry.type='Points';

var vLen=this.vertices.length;

for(var vi=0,l=vertices.length;vi<l;vi++){

this.addVertexPoint(this.parseVertexIndex(vertices[vi],vLen));

}

},

addLineGeometry:function addLineGeometry(vertices,uvs){

this.object.geometry.type='Line';

var vLen=this.vertices.length;
var uvLen=this.uvs.length;

for(var vi=0,l=vertices.length;vi<l;vi++){

this.addVertexLine(this.parseVertexIndex(vertices[vi],vLen));

}

for(var uvi=0,l=uvs.length;uvi<l;uvi++){

this.addUVLine(this.parseUVIndex(uvs[uvi],uvLen));

}

}};



state.startObject('',false);

return state;

}

//

function OBJLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

this.materials=null;

}

OBJLoader.prototype={

constructor:OBJLoader,

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(scope.manager);
loader.setPath(this.path);
loader.load(url,function(text){

onLoad(scope.parse(text));

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;

return this;

},

setMaterials:function setMaterials(materials){

this.materials=materials;

return this;

},

parse:function parse(text){

console.time('OBJLoader');

var state=new ParserState();

if(text.indexOf('\r\n')!==-1){

// This is faster than String.split with regex that splits on both
text=text.replace(/\r\n/g,'\n');

}

if(text.indexOf('\\\n')!==-1){

// join lines separated by a line continuation character (\)
text=text.replace(/\\\n/g,'');

}

var lines=text.split('\n');
var line='',lineFirstChar='';
var lineLength=0;
var result=[];

// Faster to just trim left side of the line. Use if available.
var trimLeft=typeof''.trimLeft==='function';

for(var i=0,l=lines.length;i<l;i++){

line=lines[i];

line=trimLeft?line.trimLeft():line.trim();

lineLength=line.length;

if(lineLength===0)continue;

lineFirstChar=line.charAt(0);

// @todo invoke passed in handler if any
if(lineFirstChar==='#')continue;

if(lineFirstChar==='v'){

var data=line.split(/\s+/);

switch(data[0]){

case'v':
state.vertices.push(
parseFloat(data[1]),
parseFloat(data[2]),
parseFloat(data[3]));

if(data.length===8){

state.colors.push(
parseFloat(data[4]),
parseFloat(data[5]),
parseFloat(data[6]));



}
break;
case'vn':
state.normals.push(
parseFloat(data[1]),
parseFloat(data[2]),
parseFloat(data[3]));

break;
case'vt':
state.uvs.push(
parseFloat(data[1]),
parseFloat(data[2]));

break;}



}else if(lineFirstChar==='f'){

var lineData=line.substr(1).trim();
var vertexData=lineData.split(/\s+/);
var faceVertices=[];

// Parse the face vertex data into an easy to work with format

for(var j=0,jl=vertexData.length;j<jl;j++){

var vertex=vertexData[j];

if(vertex.length>0){

var vertexParts=vertex.split('/');
faceVertices.push(vertexParts);

}

}

// Draw an edge between the first vertex and all subsequent vertices to form an n-gon

var v1=faceVertices[0];

for(var j=1,jl=faceVertices.length-1;j<jl;j++){

var v2=faceVertices[j];
var v3=faceVertices[j+1];

state.addFace(
v1[0],v2[0],v3[0],
v1[1],v2[1],v3[1],
v1[2],v2[2],v3[2]);


}

}else if(lineFirstChar==='l'){

var lineParts=line.substring(1).trim().split(" ");
var lineVertices=[],lineUVs=[];

if(line.indexOf("/")===-1){

lineVertices=lineParts;

}else{

for(var li=0,llen=lineParts.length;li<llen;li++){

var parts=lineParts[li].split("/");

if(parts[0]!=="")lineVertices.push(parts[0]);
if(parts[1]!=="")lineUVs.push(parts[1]);

}

}
state.addLineGeometry(lineVertices,lineUVs);

}else if(lineFirstChar==='p'){

var lineData=line.substr(1).trim();
var pointData=lineData.split(" ");

state.addPointGeometry(pointData);

}else if((result=object_pattern.exec(line))!==null){

// o object_name
// or
// g group_name

// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
// var name = result[ 0 ].substr( 1 ).trim();
var name=(" "+result[0].substr(1).trim()).substr(1);

state.startObject(name);

}else if(material_use_pattern.test(line)){

// material

state.object.startMaterial(line.substring(7).trim(),state.materialLibraries);

}else if(material_library_pattern.test(line)){

// mtl file

state.materialLibraries.push(line.substring(7).trim());

}else if(lineFirstChar==='s'){

result=line.split(' ');

// smooth shading

// @todo Handle files that have varying smooth values for a set of faces inside one geometry,
// but does not define a usemtl for each face set.
// This should be detected and a dummy material created (later MultiMaterial and geometry groups).
// This requires some care to not create extra material on each smooth value for "normal" obj files.
// where explicit usemtl defines geometry groups.
// Example asset: examples/models/obj/cerberus/Cerberus.obj

/*
					 * http://paulbourke.net/dataformats/obj/
					 * or
					 * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
					 *
					 * From chapter "Grouping" Syntax explanation "s group_number":
					 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
					 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
					 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
					 * than 0."
					 */
if(result.length>1){

var value=result[1].trim().toLowerCase();
state.object.smooth=value!=='0'&&value!=='off';

}else{

// ZBrush can produce "s" lines #11707
state.object.smooth=true;

}
var material=state.object.currentMaterial();
if(material)material.smooth=state.object.smooth;

}else{

// Handle null terminated files without exception
if(line==='\0')continue;

throw new Error('THREE.OBJLoader: Unexpected line: "'+line+'"');

}

}

state.finalize();

var container=new Group();
container.materialLibraries=[].concat(state.materialLibraries);

for(var i=0,l=state.objects.length;i<l;i++){

var object=state.objects[i];
var geometry=object.geometry;
var materials=object.materials;
var isLine=geometry.type==='Line';
var isPoints=geometry.type==='Points';
var hasVertexColors=false;

// Skip o/g line declarations that did not follow with any faces
if(geometry.vertices.length===0)continue;

var buffergeometry=new BufferGeometry();

buffergeometry.addAttribute('position',new Float32BufferAttribute(geometry.vertices,3));

if(geometry.normals.length>0){

buffergeometry.addAttribute('normal',new Float32BufferAttribute(geometry.normals,3));

}else{

buffergeometry.computeVertexNormals();

}

if(geometry.colors.length>0){

hasVertexColors=true;
buffergeometry.addAttribute('color',new Float32BufferAttribute(geometry.colors,3));

}

if(geometry.uvs.length>0){

buffergeometry.addAttribute('uv',new Float32BufferAttribute(geometry.uvs,2));

}

// Create materials

var createdMaterials=[];

for(var mi=0,miLen=materials.length;mi<miLen;mi++){

var sourceMaterial=materials[mi];
var material=undefined;

if(this.materials!==null){

material=this.materials.create(sourceMaterial.name);

// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
if(isLine&&material&&!(material instanceof LineBasicMaterial)){

var materialLine=new LineBasicMaterial();
Material.prototype.copy.call(materialLine,material);
materialLine.color.copy(material.color);
materialLine.lights=false;
material=materialLine;

}else if(isPoints&&material&&!(material instanceof PointsMaterial)){

var materialPoints=new PointsMaterial({size:10,sizeAttenuation:false});
Material.prototype.copy.call(materialPoints,material);
materialPoints.color.copy(material.color);
materialPoints.map=material.map;
materialPoints.lights=false;
material=materialPoints;

}

}

if(!material){

if(isLine){

material=new LineBasicMaterial();

}else if(isPoints){

material=new PointsMaterial({size:1,sizeAttenuation:false});

}else{

material=new MeshPhongMaterial();

}

material.name=sourceMaterial.name;

}

material.flatShading=sourceMaterial.smooth?false:true;
material.vertexColors=hasVertexColors?VertexColors:NoColors;

createdMaterials.push(material);

}

// Create mesh

var mesh;

if(createdMaterials.length>1){

for(var mi=0,miLen=materials.length;mi<miLen;mi++){

var sourceMaterial=materials[mi];
buffergeometry.addGroup(sourceMaterial.groupStart,sourceMaterial.groupCount,mi);

}

if(isLine){

mesh=new LineSegments(buffergeometry,createdMaterials);

}else if(isPoints){

mesh=new Points(buffergeometry,createdMaterials);

}else{

mesh=new Mesh(buffergeometry,createdMaterials);

}

}else{

if(isLine){

mesh=new LineSegments(buffergeometry,createdMaterials[0]);

}else if(isPoints){

mesh=new Points(buffergeometry,createdMaterials[0]);

}else{

mesh=new Mesh(buffergeometry,createdMaterials[0]);

}

}

mesh.name=object.name;

container.add(mesh);

}

console.timeEnd('OBJLoader');

return container;

}};



return OBJLoader;

}();



// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/MTLLoader.js
/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */



var MTLLoader=function MTLLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

};

MTLLoader.prototype={

constructor:MTLLoader,

crossOrigin:'anonymous',

/**
	 * Loads and parses a MTL asset from a URL.
	 *
	 * @param {String} url - URL to the MTL file.
	 * @param {Function} [onLoad] - Callback invoked with the loaded object.
	 * @param {Function} [onProgress] - Callback for download progress.
	 * @param {Function} [onError] - Callback for download errors.
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to load.
	 */
load:function load(url,onLoad,onProgress,onError){

var scope=this;

var path=this.path===undefined?LoaderUtils.extractUrlBase(url):this.path;

var loader=new FileLoader(this.manager);
loader.setPath(this.path);
loader.load(url,function(text){

onLoad(scope.parse(text,path));

},onProgress,onError);

},

/**
	 * Set base path for resolving references.
	 * If set this path will be prepended to each loaded and found reference.
	 *
	 * @see setResourcePath
	 * @param {String} path
	 * @return {MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
setPath:function setPath(path){

this.path=path;
return this;

},

/**
	 * Set base path for additional resources like textures.
	 *
	 * @see setPath
	 * @param {String} path
	 * @return {MTLLoader}
	 *
	 * @example
	 *     mtlLoader.setPath( 'assets/obj/' );
	 *     mtlLoader.setResourcePath( 'assets/textures/' );
	 *     mtlLoader.load( 'my.mtl', ... );
	 */
setResourcePath:function setResourcePath(path){

this.resourcePath=path;
return this;

},

setTexturePath:function setTexturePath(path){

console.warn('THREE.MTLLoader: .setTexturePath() has been renamed to .setResourcePath().');
return this.setResourcePath(path);

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setMaterialOptions:function setMaterialOptions(value){

this.materialOptions=value;
return this;

},

/**
	 * Parses a MTL file.
	 *
	 * @param {String} text - Content of MTL file
	 * @return {MTLLoader.MaterialCreator}
	 *
	 * @see setPath setResourcePath
	 *
	 * @note In order for relative texture references to resolve correctly
	 * you must call setResourcePath() explicitly prior to parse.
	 */
parse:function parse(text,path){

var lines=text.split('\n');
var info={};
var delimiter_pattern=/\s+/;
var materialsInfo={};

for(var i=0;i<lines.length;i++){

var line=lines[i];
line=line.trim();

if(line.length===0||line.charAt(0)==='#'){

// Blank line or comment ignore
continue;

}

var pos=line.indexOf(' ');

var key=pos>=0?line.substring(0,pos):line;
key=key.toLowerCase();

var value=pos>=0?line.substring(pos+1):'';
value=value.trim();

if(key==='newmtl'){

// New material

info={name:value};
materialsInfo[value]=info;

}else{

if(key==='ka'||key==='kd'||key==='ks'||key==='ke'){

var ss=value.split(delimiter_pattern,3);
info[key]=[parseFloat(ss[0]),parseFloat(ss[1]),parseFloat(ss[2])];

}else{

info[key]=value;

}

}

}

var materialCreator=new MTLLoader.MaterialCreator(this.resourcePath||path,this.materialOptions);
materialCreator.setCrossOrigin(this.crossOrigin);
materialCreator.setManager(this.manager);
materialCreator.setMaterials(materialsInfo);
return materialCreator;

}};



/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

MTLLoader.MaterialCreator=function(baseUrl,options){

this.baseUrl=baseUrl||'';
this.options=options;
this.materialsInfo={};
this.materials={};
this.materialsArray=[];
this.nameLookup={};

this.side=this.options&&this.options.side?this.options.side:FrontSide;
this.wrap=this.options&&this.options.wrap?this.options.wrap:RepeatWrapping;

};

MTLLoader.MaterialCreator.prototype={

constructor:MTLLoader.MaterialCreator,

crossOrigin:'anonymous',

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setManager:function setManager(value){

this.manager=value;

},

setMaterials:function setMaterials(materialsInfo){

this.materialsInfo=this.convert(materialsInfo);
this.materials={};
this.materialsArray=[];
this.nameLookup={};

},

convert:function convert(materialsInfo){

if(!this.options)return materialsInfo;

var converted={};

for(var mn in materialsInfo){

// Convert materials info into normalized form based on options

var mat=materialsInfo[mn];

var covmat={};

converted[mn]=covmat;

for(var prop in mat){

var save=true;
var value=mat[prop];
var lprop=prop.toLowerCase();

switch(lprop){

case'kd':
case'ka':
case'ks':

// Diffuse color (color under white light) using RGB values

if(this.options&&this.options.normalizeRGB){

value=[value[0]/255,value[1]/255,value[2]/255];

}

if(this.options&&this.options.ignoreZeroRGBs){

if(value[0]===0&&value[1]===0&&value[2]===0){

// ignore

save=false;

}

}

break;

default:

break;}



if(save){

covmat[lprop]=value;

}

}

}

return converted;

},

preload:function preload(){

for(var mn in this.materialsInfo){

this.create(mn);

}

},

getIndex:function getIndex(materialName){

return this.nameLookup[materialName];

},

getAsArray:function getAsArray(){

var index=0;

for(var mn in this.materialsInfo){

this.materialsArray[index]=this.create(mn);
this.nameLookup[mn]=index;
index++;

}

return this.materialsArray;

},

create:function create(materialName){

if(this.materials[materialName]===undefined){

this.createMaterial_(materialName);

}

return this.materials[materialName];

},

createMaterial_:function createMaterial_(materialName){

// Create material

var scope=this;
var mat=this.materialsInfo[materialName];
var params={

name:materialName,
side:this.side};



function resolveURL(baseUrl,url){

if(typeof url!=='string'||url==='')
return'';

// Absolute URL
if(/^https?:\/\//i.test(url))return url;

return baseUrl+url;

}

function setMapForType(mapType,value){

if(params[mapType])return;// Keep the first encountered texture

var texParams=scope.getTextureParams(value,params);
var map=scope.loadTexture(resolveURL(scope.baseUrl,texParams.url));

map.repeat.copy(texParams.scale);
map.offset.copy(texParams.offset);

map.wrapS=scope.wrap;
map.wrapT=scope.wrap;

params[mapType]=map;

}

for(var prop in mat){

var value=mat[prop];
var n;

if(value==='')continue;

switch(prop.toLowerCase()){

// Ns is material specular exponent

case'kd':

// Diffuse color (color under white light) using RGB values

params.color=new Color().fromArray(value);

break;

case'ks':

// Specular color (color when light is reflected from shiny surface) using RGB values
params.specular=new Color().fromArray(value);

break;

case'ke':

// Emissive using RGB values
params.emissive=new Color().fromArray(value);

break;

case'map_kd':

// Diffuse texture map

setMapForType("map",value);

break;

case'map_ks':

// Specular map

setMapForType("specularMap",value);

break;

case'map_ke':

// Emissive map

setMapForType("emissiveMap",value);

break;

case'norm':

setMapForType("normalMap",value);

break;

case'map_bump':
case'bump':

// Bump texture map

setMapForType("bumpMap",value);

break;

case'map_d':

// Alpha map

setMapForType("alphaMap",value);
params.transparent=true;

break;

case'ns':

// The specular exponent (defines the focus of the specular highlight)
// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

params.shininess=parseFloat(value);

break;

case'd':
n=parseFloat(value);

if(n<1){

params.opacity=n;
params.transparent=true;

}

break;

case'tr':
n=parseFloat(value);

if(this.options&&this.options.invertTrProperty)n=1-n;

if(n>0){

params.opacity=1-n;
params.transparent=true;

}

break;

default:
break;}



}

this.materials[materialName]=new MeshPhongMaterial(params);
return this.materials[materialName];

},

getTextureParams:function getTextureParams(value,matParams){

var texParams={

scale:new Vector2(1,1),
offset:new Vector2(0,0)};



var items=value.split(/\s+/);
var pos;

pos=items.indexOf('-bm');

if(pos>=0){

matParams.bumpScale=parseFloat(items[pos+1]);
items.splice(pos,2);

}

pos=items.indexOf('-s');

if(pos>=0){

texParams.scale.set(parseFloat(items[pos+1]),parseFloat(items[pos+2]));
items.splice(pos,4);// we expect 3 parameters here!

}

pos=items.indexOf('-o');

if(pos>=0){

texParams.offset.set(parseFloat(items[pos+1]),parseFloat(items[pos+2]));
items.splice(pos,4);// we expect 3 parameters here!

}

texParams.url=items.join(' ').trim();
return texParams;

},

loadTexture:function loadTexture(url,mapping,onLoad,onProgress,onError){

var texture;
var loader=Loader.Handlers.get(url);
var manager=this.manager!==undefined?this.manager:DefaultLoadingManager;

if(loader===null){

loader=new TextureLoader(manager);

}

if(loader.setCrossOrigin)loader.setCrossOrigin(this.crossOrigin);
texture=loader.load(url,onLoad,onProgress,onError);

if(mapping!==undefined)texture.mapping=mapping;

return texture;

}};





// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/DDSLoader.js
/*
 * @author mrdoob / http://mrdoob.com/
 */



var DDSLoader=function DDSLoader(manager){

CompressedTextureLoader.call(this,manager);

this._parser=DDSLoader.parse;

};

DDSLoader.prototype=Object.create(CompressedTextureLoader.prototype);
DDSLoader.prototype.constructor=DDSLoader;

DDSLoader.parse=function(buffer,loadMipmaps){

var dds={mipmaps:[],width:0,height:0,format:null,mipmapCount:1};

// Adapted from @toji's DDS utils
// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

// All values and structures referenced from:
// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

var DDS_MAGIC=0x20534444;

var DDSD_CAPS=0x1,
DDSD_HEIGHT=0x2,
DDSD_WIDTH=0x4,
DDSD_PITCH=0x8,
DDSD_PIXELFORMAT=0x1000,
DDSD_MIPMAPCOUNT=0x20000,
DDSD_LINEARSIZE=0x80000,
DDSD_DEPTH=0x800000;

var DDSCAPS_COMPLEX=0x8,
DDSCAPS_MIPMAP=0x400000,
DDSCAPS_TEXTURE=0x1000;

var DDSCAPS2_CUBEMAP=0x200,
DDSCAPS2_CUBEMAP_POSITIVEX=0x400,
DDSCAPS2_CUBEMAP_NEGATIVEX=0x800,
DDSCAPS2_CUBEMAP_POSITIVEY=0x1000,
DDSCAPS2_CUBEMAP_NEGATIVEY=0x2000,
DDSCAPS2_CUBEMAP_POSITIVEZ=0x4000,
DDSCAPS2_CUBEMAP_NEGATIVEZ=0x8000,
DDSCAPS2_VOLUME=0x200000;

var DDPF_ALPHAPIXELS=0x1,
DDPF_ALPHA=0x2,
DDPF_FOURCC=0x4,
DDPF_RGB=0x40,
DDPF_YUV=0x200,
DDPF_LUMINANCE=0x20000;

function fourCCToInt32(value){

return value.charCodeAt(0)+(
value.charCodeAt(1)<<8)+(
value.charCodeAt(2)<<16)+(
value.charCodeAt(3)<<24);

}

function int32ToFourCC(value){

return String.fromCharCode(
value&0xff,
value>>8&0xff,
value>>16&0xff,
value>>24&0xff);


}

function loadARGBMip(buffer,dataOffset,width,height){

var dataLength=width*height*4;
var srcBuffer=new Uint8Array(buffer,dataOffset,dataLength);
var byteArray=new Uint8Array(dataLength);
var dst=0;
var src=0;
for(var y=0;y<height;y++){

for(var x=0;x<width;x++){

var b=srcBuffer[src];src++;
var g=srcBuffer[src];src++;
var r=srcBuffer[src];src++;
var a=srcBuffer[src];src++;
byteArray[dst]=r;dst++;//r
byteArray[dst]=g;dst++;//g
byteArray[dst]=b;dst++;//b
byteArray[dst]=a;dst++;//a

}

}
return byteArray;

}

var FOURCC_DXT1=fourCCToInt32("DXT1");
var FOURCC_DXT3=fourCCToInt32("DXT3");
var FOURCC_DXT5=fourCCToInt32("DXT5");
var FOURCC_ETC1=fourCCToInt32("ETC1");

var headerLengthInt=31;// The header length in 32 bit ints

// Offsets into the header array

var off_magic=0;

var off_size=1;
var off_flags=2;
var off_height=3;
var off_width=4;

var off_mipmapCount=7;

var off_pfFlags=20;
var off_pfFourCC=21;
var off_RGBBitCount=22;
var off_RBitMask=23;
var off_GBitMask=24;
var off_BBitMask=25;
var off_ABitMask=26;

var off_caps=27;
var off_caps2=28;
var off_caps3=29;
var off_caps4=30;

// Parse header

var header=new Int32Array(buffer,0,headerLengthInt);

if(header[off_magic]!==DDS_MAGIC){

console.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');
return dds;

}

if(!header[off_pfFlags]&DDPF_FOURCC){

console.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');
return dds;

}

var blockBytes;

var fourCC=header[off_pfFourCC];

var isRGBAUncompressed=false;

switch(fourCC){

case FOURCC_DXT1:

blockBytes=8;
dds.format=RGB_S3TC_DXT1_Format;
break;

case FOURCC_DXT3:

blockBytes=16;
dds.format=RGBA_S3TC_DXT3_Format;
break;

case FOURCC_DXT5:

blockBytes=16;
dds.format=RGBA_S3TC_DXT5_Format;
break;

case FOURCC_ETC1:

blockBytes=8;
dds.format=RGB_ETC1_Format;
break;

default:

if(header[off_RGBBitCount]===32&&
header[off_RBitMask]&0xff0000&&
header[off_GBitMask]&0xff00&&
header[off_BBitMask]&0xff&&
header[off_ABitMask]&0xff000000){

isRGBAUncompressed=true;
blockBytes=64;
dds.format=RGBAFormat;

}else{

console.error('THREE.DDSLoader.parse: Unsupported FourCC code ',int32ToFourCC(fourCC));
return dds;

}}



dds.mipmapCount=1;

if(header[off_flags]&DDSD_MIPMAPCOUNT&&loadMipmaps!==false){

dds.mipmapCount=Math.max(1,header[off_mipmapCount]);

}

var caps2=header[off_caps2];
dds.isCubemap=caps2&DDSCAPS2_CUBEMAP?true:false;
if(dds.isCubemap&&(
!(caps2&DDSCAPS2_CUBEMAP_POSITIVEX)||
!(caps2&DDSCAPS2_CUBEMAP_NEGATIVEX)||
!(caps2&DDSCAPS2_CUBEMAP_POSITIVEY)||
!(caps2&DDSCAPS2_CUBEMAP_NEGATIVEY)||
!(caps2&DDSCAPS2_CUBEMAP_POSITIVEZ)||
!(caps2&DDSCAPS2_CUBEMAP_NEGATIVEZ)))
{

console.error('THREE.DDSLoader.parse: Incomplete cubemap faces');
return dds;

}

dds.width=header[off_width];
dds.height=header[off_height];

var dataOffset=header[off_size]+4;

// Extract mipmaps buffers

var faces=dds.isCubemap?6:1;

for(var face=0;face<faces;face++){

var width=dds.width;
var height=dds.height;

for(var i=0;i<dds.mipmapCount;i++){

if(isRGBAUncompressed){

var byteArray=loadARGBMip(buffer,dataOffset,width,height);
var dataLength=byteArray.length;

}else{

var dataLength=Math.max(4,width)/4*Math.max(4,height)/4*blockBytes;
var byteArray=new Uint8Array(buffer,dataOffset,dataLength);

}

var mipmap={"data":byteArray,"width":width,"height":height};
dds.mipmaps.push(mipmap);

dataOffset+=dataLength;

width=Math.max(width>>1,1);
height=Math.max(height>>1,1);

}

}

return dds;

};



// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/es6.typed.uint32-array.js
var es6_typed_uint32_array=__webpack_require__("c615");

// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/es6.typed.float32-array.js
var es6_typed_float32_array=__webpack_require__("54c8");

// CONCATENATED MODULE: ./src/util.js




/* eslint-disable */

var box=new Box3();

function getSize(object){
box.setFromObject(object);
return box.getSize(new Vector3());
}

function getCenter(object){
box.setFromObject(object);
return box.getCenter(new Vector3());
}// function lightsDiff(lights, oldLights) {
// }


function toIndexed(bufferGeometry){
var rawPositions=bufferGeometry.getAttribute('position').array;
var rawUvs;
var hasUV=bufferGeometry.getAttribute('uv')!==undefined;
if(hasUV)rawUvs=bufferGeometry.getAttribute('uv').array;
var rawNormals;
var hasNormal=bufferGeometry.getAttribute('normal')!==undefined;
if(hasNormal)rawNormals=bufferGeometry.getAttribute('normal').array;
var indices=[];
var vertices=[];
var normals=[];
var uvs=[];
var face;
var faceNormalss;
var faceUvs;
var tmpIndices;
var v0=new Vector3();
var v1=new Vector3();
var v2=new Vector3();
var n0=new Vector3();
var n1=new Vector3();
var n2=new Vector3();
var uv0=new Vector2();
var uv1=new Vector2();
var uv2=new Vector2();

for(var i=0;i<rawPositions.length;i+=9){
v0.x=rawPositions[i];
v0.y=rawPositions[i+1];
v0.z=rawPositions[i+2];
v1.x=rawPositions[i+3];
v1.y=rawPositions[i+4];
v1.z=rawPositions[i+5];
v2.x=rawPositions[i+6];
v2.y=rawPositions[i+7];
v2.z=rawPositions[i+8];
face=[v0,v1,v2];

if(hasNormal){
n0.x=rawNormals[i];
n0.y=rawNormals[i+1];
n0.z=rawNormals[i+2];
n1.x=rawNormals[i+3];
n1.y=rawNormals[i+4];
n1.z=rawNormals[i+5];
n2.x=rawNormals[i+6];
n2.y=rawNormals[i+7];
n2.z=rawNormals[i+8];
faceNormalss=[n0,n1,n2];
}

if(hasUV){
uv0.x=rawUvs[i];
uv0.y=rawUvs[i+1];
uv1.x=rawUvs[i+2];
uv1.y=rawUvs[i+3];
uv2.x=rawUvs[i+4];
uv2.y=rawUvs[i+5];
faceUvs=[uv0,uv1,uv2];
}

tmpIndices=[];
face.forEach(function(v,i){
var id=exists(v,vertices);

if(id===-1){
id=vertices.length;
vertices.push(v.clone());
if(hasNormal)normals.push(faceNormalss[i].clone());
if(hasUV)uvs.push(faceUvs[i].clone());
}

tmpIndices.push(id);
});
indices.push(tmpIndices[0],tmpIndices[1],tmpIndices[2]);
}

var positionBuffer=new Float32Array(vertices.length*3);
var normalBuffer;
var uvBuffer;
if(hasNormal)normalBuffer=new Float32Array(vertices.length*3);
if(hasUV)uvBuffer=new Float32Array(vertices.length*2);
var i2=0;
var i3=0;

for(var _i=0;_i<vertices.length;_i++){
i3=_i*3;
positionBuffer[i3]=vertices[_i].x;
positionBuffer[i3+1]=vertices[_i].y;
positionBuffer[i3+2]=vertices[_i].z;

if(hasNormal){
normalBuffer[i3]=normals[_i].x;
normalBuffer[i3+1]=normals[_i].y;
normalBuffer[i3+2]=normals[_i].z;
}

if(hasUV){
i2=_i*2;
uvBuffer[i2]=uvs[_i].x;
uvBuffer[i2+1]=uvs[_i].y;
}
}

bufferGeometry.addAttribute('position',new BufferAttribute(positionBuffer,3));
if(hasNormal)bufferGeometry.addAttribute('normal',new BufferAttribute(normalBuffer,3));
if(hasUV)bufferGeometry.addAttribute('uv',new BufferAttribute(uvBuffer,2));
bufferGeometry.setIndex(new BufferAttribute(new Uint32Array(indices),1));
return bufferGeometry;

function exists(v,vertices){
for(var _i2=0;_i2<vertices.length;_i2++){
if(v.equals(vertices[_i2]))return _i2;
}

return-1;
}
}


// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"3da6f646-vue-loader-template"}!./node_modules/_vue-loader@15.7.0@vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-mixin.vue?vue&type=template&id=1392870a&
var render=function render(){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticStyle:{"width":"100%","height":"100%","margin":"0","border":"0","padding":"0"}},[_vm.suportWebGL?_c('canvas',{ref:"canvas",staticStyle:{"width":"100%","height":"100%"}}):_c('div',[_vm._t("default",[_vm._v("\n      Your browser does not seem to support "),_c('a',{staticStyle:{"color":"#000"},attrs:{"href":"http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation"}},[_vm._v("WebGL")]),_vm._v("."),_c('br'),_vm._v("'\n    ")])],2)]);};
var staticRenderFns=[];


// CONCATENATED MODULE: ./src/model-mixin.vue?vue&type=template&id=1392870a&

// CONCATENATED MODULE: ./node_modules/_@babel_runtime@7.4.5@@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr){
if(Array.isArray(arr)){
for(var i=0,arr2=new Array(arr.length);i<arr.length;i++){
arr2[i]=arr[i];
}

return arr2;
}
}
// CONCATENATED MODULE: ./node_modules/_@babel_runtime@7.4.5@@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter){
if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)==="[object Arguments]")return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/_@babel_runtime@7.4.5@@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread(){
throw new TypeError("Invalid attempt to spread non-iterable instance");
}
// CONCATENATED MODULE: ./node_modules/_@babel_runtime@7.4.5@@babel/runtime/helpers/esm/toConsumableArray.js



function _toConsumableArray(arr){
return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();
}
// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/es6.object.assign.js
var es6_object_assign=__webpack_require__("9604");

// EXTERNAL MODULE: ./node_modules/_core-js@2.6.9@core-js/modules/es6.number.constructor.js
var es6_number_constructor=__webpack_require__("d4d5");

// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/controls/OrbitControls.js
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */



// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

var OrbitControls=function OrbitControls(object,domElement){

this.object=object;

this.domElement=domElement!==undefined?domElement:document;

// Set to false to disable this control
this.enabled=true;

// "target" sets the location of focus, where the object orbits around
this.target=new Vector3();

// How far you can dolly in and out ( PerspectiveCamera only )
this.minDistance=0;
this.maxDistance=Infinity;

// How far you can zoom in and out ( OrthographicCamera only )
this.minZoom=0;
this.maxZoom=Infinity;

// How far you can orbit vertically, upper and lower limits.
// Range is 0 to Math.PI radians.
this.minPolarAngle=0;// radians
this.maxPolarAngle=Math.PI;// radians

// How far you can orbit horizontally, upper and lower limits.
// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
this.minAzimuthAngle=-Infinity;// radians
this.maxAzimuthAngle=Infinity;// radians

// Set to true to enable damping (inertia)
// If damping is enabled, you must call controls.update() in your animation loop
this.enableDamping=false;
this.dampingFactor=0.25;

// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
// Set to false to disable zooming
this.enableZoom=true;
this.zoomSpeed=1.0;

// Set to false to disable rotating
this.enableRotate=true;
this.rotateSpeed=1.0;

// Set to false to disable panning
this.enablePan=true;
this.panSpeed=1.0;
this.screenSpacePanning=false;// if true, pan in screen-space
this.keyPanSpeed=7.0;// pixels moved per arrow key push

// Set to true to automatically rotate around the target
// If auto-rotate is enabled, you must call controls.update() in your animation loop
this.autoRotate=false;
this.autoRotateSpeed=2.0;// 30 seconds per round when fps is 60

// Set to false to disable use of the keys
this.enableKeys=true;

// The four arrow keys
this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40};

// Mouse buttons
this.mouseButtons={LEFT:MOUSE.LEFT,MIDDLE:MOUSE.MIDDLE,RIGHT:MOUSE.RIGHT};

// for reset
this.target0=this.target.clone();
this.position0=this.object.position.clone();
this.zoom0=this.object.zoom;

//
// public methods
//

this.getPolarAngle=function(){

return spherical.phi;

};

this.getAzimuthalAngle=function(){

return spherical.theta;

};

this.saveState=function(){

scope.target0.copy(scope.target);
scope.position0.copy(scope.object.position);
scope.zoom0=scope.object.zoom;

};

this.reset=function(){

scope.target.copy(scope.target0);
scope.object.position.copy(scope.position0);
scope.object.zoom=scope.zoom0;

scope.object.updateProjectionMatrix();
scope.dispatchEvent(changeEvent);

scope.update();

state=STATE.NONE;

};

// this method is exposed, but perhaps it would be better if we can make it private...
this.update=function(){

var offset=new Vector3();

// so camera.up is the orbit axis
var quat=new Quaternion().setFromUnitVectors(object.up,new Vector3(0,1,0));
var quatInverse=quat.clone().inverse();

var lastPosition=new Vector3();
var lastQuaternion=new Quaternion();

return function update(){

var position=scope.object.position;

offset.copy(position).sub(scope.target);

// rotate offset to "y-axis-is-up" space
offset.applyQuaternion(quat);

// angle from z-axis around y-axis
spherical.setFromVector3(offset);

if(scope.autoRotate&&state===STATE.NONE){

rotateLeft(getAutoRotationAngle());

}

spherical.theta+=sphericalDelta.theta;
spherical.phi+=sphericalDelta.phi;

// restrict theta to be between desired limits
spherical.theta=Math.max(scope.minAzimuthAngle,Math.min(scope.maxAzimuthAngle,spherical.theta));

// restrict phi to be between desired limits
spherical.phi=Math.max(scope.minPolarAngle,Math.min(scope.maxPolarAngle,spherical.phi));

spherical.makeSafe();


spherical.radius*=scale;

// restrict radius to be between desired limits
spherical.radius=Math.max(scope.minDistance,Math.min(scope.maxDistance,spherical.radius));

// move target to panned location
scope.target.add(panOffset);

offset.setFromSpherical(spherical);

// rotate offset back to "camera-up-vector-is-up" space
offset.applyQuaternion(quatInverse);

position.copy(scope.target).add(offset);

scope.object.lookAt(scope.target);

if(scope.enableDamping===true){

sphericalDelta.theta*=1-scope.dampingFactor;
sphericalDelta.phi*=1-scope.dampingFactor;

panOffset.multiplyScalar(1-scope.dampingFactor);

}else{

sphericalDelta.set(0,0,0);

panOffset.set(0,0,0);

}

scale=1;

// update condition is:
// min(camera displacement, camera rotation in radians)^2 > EPS
// using small-angle approximation cos(x/2) = 1 - x^2 / 8

if(zoomChanged||
lastPosition.distanceToSquared(scope.object.position)>EPS||
8*(1-lastQuaternion.dot(scope.object.quaternion))>EPS){

scope.dispatchEvent(changeEvent);

lastPosition.copy(scope.object.position);
lastQuaternion.copy(scope.object.quaternion);
zoomChanged=false;

return true;

}

return false;

};

}();

this.dispose=function(){

scope.domElement.removeEventListener('contextmenu',onContextMenu,false);
scope.domElement.removeEventListener('mousedown',onMouseDown,false);
scope.domElement.removeEventListener('wheel',onMouseWheel,false);

scope.domElement.removeEventListener('touchstart',onTouchStart,false);
scope.domElement.removeEventListener('touchend',onTouchEnd,false);
scope.domElement.removeEventListener('touchmove',onTouchMove,false);

document.removeEventListener('mousemove',onMouseMove,false);
document.removeEventListener('mouseup',onMouseUp,false);

window.removeEventListener('keydown',onKeyDown,false);

//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

};

//
// internals
//

var scope=this;

var changeEvent={type:'change'};
var startEvent={type:'start'};
var endEvent={type:'end'};

var STATE={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY_PAN:4};

var state=STATE.NONE;

var EPS=0.000001;

// current position in spherical coordinates
var spherical=new Spherical();
var sphericalDelta=new Spherical();

var scale=1;
var panOffset=new Vector3();
var zoomChanged=false;

var rotateStart=new Vector2();
var rotateEnd=new Vector2();
var rotateDelta=new Vector2();

var panStart=new Vector2();
var panEnd=new Vector2();
var panDelta=new Vector2();

var dollyStart=new Vector2();
var dollyEnd=new Vector2();
var dollyDelta=new Vector2();

function getAutoRotationAngle(){

return 2*Math.PI/60/60*scope.autoRotateSpeed;

}

function getZoomScale(){

return Math.pow(0.95,scope.zoomSpeed);

}

function rotateLeft(angle){

sphericalDelta.theta-=angle;

}

function rotateUp(angle){

sphericalDelta.phi-=angle;

}

var panLeft=function(){

var v=new Vector3();

return function panLeft(distance,objectMatrix){

v.setFromMatrixColumn(objectMatrix,0);// get X column of objectMatrix
v.multiplyScalar(-distance);

panOffset.add(v);

};

}();

var panUp=function(){

var v=new Vector3();

return function panUp(distance,objectMatrix){

if(scope.screenSpacePanning===true){

v.setFromMatrixColumn(objectMatrix,1);

}else{

v.setFromMatrixColumn(objectMatrix,0);
v.crossVectors(scope.object.up,v);

}

v.multiplyScalar(distance);

panOffset.add(v);

};

}();

// deltaX and deltaY are in pixels; right and down are positive
var pan=function(){

var offset=new Vector3();

return function pan(deltaX,deltaY){

var element=scope.domElement===document?scope.domElement.body:scope.domElement;

if(scope.object.isPerspectiveCamera){

// perspective
var position=scope.object.position;
offset.copy(position).sub(scope.target);
var targetDistance=offset.length();

// half of the fov is center to top of screen
targetDistance*=Math.tan(scope.object.fov/2*Math.PI/180.0);

// we use only clientHeight here so aspect ratio does not distort speed
panLeft(2*deltaX*targetDistance/element.clientHeight,scope.object.matrix);
panUp(2*deltaY*targetDistance/element.clientHeight,scope.object.matrix);

}else if(scope.object.isOrthographicCamera){

// orthographic
panLeft(deltaX*(scope.object.right-scope.object.left)/scope.object.zoom/element.clientWidth,scope.object.matrix);
panUp(deltaY*(scope.object.top-scope.object.bottom)/scope.object.zoom/element.clientHeight,scope.object.matrix);

}else{

// camera neither orthographic nor perspective
console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
scope.enablePan=false;

}

};

}();

function dollyIn(dollyScale){

if(scope.object.isPerspectiveCamera){

scale/=dollyScale;

}else if(scope.object.isOrthographicCamera){

scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom*dollyScale));
scope.object.updateProjectionMatrix();
zoomChanged=true;

}else{

console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
scope.enableZoom=false;

}

}

function dollyOut(dollyScale){

if(scope.object.isPerspectiveCamera){

scale*=dollyScale;

}else if(scope.object.isOrthographicCamera){

scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom/dollyScale));
scope.object.updateProjectionMatrix();
zoomChanged=true;

}else{

console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
scope.enableZoom=false;

}

}

//
// event callbacks - update the object state
//

function handleMouseDownRotate(event){

//console.log( 'handleMouseDownRotate' );

rotateStart.set(event.clientX,event.clientY);

}

function handleMouseDownDolly(event){

//console.log( 'handleMouseDownDolly' );

dollyStart.set(event.clientX,event.clientY);

}

function handleMouseDownPan(event){

//console.log( 'handleMouseDownPan' );

panStart.set(event.clientX,event.clientY);

}

function handleMouseMoveRotate(event){

//console.log( 'handleMouseMoveRotate' );

rotateEnd.set(event.clientX,event.clientY);

rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);

var element=scope.domElement===document?scope.domElement.body:scope.domElement;

rotateLeft(2*Math.PI*rotateDelta.x/element.clientHeight);// yes, height

rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight);

rotateStart.copy(rotateEnd);

scope.update();

}

function handleMouseMoveDolly(event){

//console.log( 'handleMouseMoveDolly' );

dollyEnd.set(event.clientX,event.clientY);

dollyDelta.subVectors(dollyEnd,dollyStart);

if(dollyDelta.y>0){

dollyIn(getZoomScale());

}else if(dollyDelta.y<0){

dollyOut(getZoomScale());

}

dollyStart.copy(dollyEnd);

scope.update();

}

function handleMouseMovePan(event){

//console.log( 'handleMouseMovePan' );

panEnd.set(event.clientX,event.clientY);

panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed);

pan(panDelta.x,panDelta.y);

panStart.copy(panEnd);

scope.update();

}

function handleMouseUp(event){

// console.log( 'handleMouseUp' );

}

function handleMouseWheel(event){

// console.log( 'handleMouseWheel' );

if(event.deltaY<0){

dollyOut(getZoomScale());

}else if(event.deltaY>0){

dollyIn(getZoomScale());

}

scope.update();

}

function handleKeyDown(event){

// console.log( 'handleKeyDown' );

var needsUpdate=false;

switch(event.keyCode){

case scope.keys.UP:
pan(0,scope.keyPanSpeed);
needsUpdate=true;
break;

case scope.keys.BOTTOM:
pan(0,-scope.keyPanSpeed);
needsUpdate=true;
break;

case scope.keys.LEFT:
pan(scope.keyPanSpeed,0);
needsUpdate=true;
break;

case scope.keys.RIGHT:
pan(-scope.keyPanSpeed,0);
needsUpdate=true;
break;}



if(needsUpdate){

// prevent the browser from scrolling on cursor keys
event.preventDefault();

scope.update();

}


}

function handleTouchStartRotate(event){

//console.log( 'handleTouchStartRotate' );

rotateStart.set(event.touches[0].pageX,event.touches[0].pageY);

}

function handleTouchStartDollyPan(event){

//console.log( 'handleTouchStartDollyPan' );

if(scope.enableZoom){

var dx=event.touches[0].pageX-event.touches[1].pageX;
var dy=event.touches[0].pageY-event.touches[1].pageY;

var distance=Math.sqrt(dx*dx+dy*dy);

dollyStart.set(0,distance);

}

if(scope.enablePan){

var x=0.5*(event.touches[0].pageX+event.touches[1].pageX);
var y=0.5*(event.touches[0].pageY+event.touches[1].pageY);

panStart.set(x,y);

}

}

function handleTouchMoveRotate(event){

//console.log( 'handleTouchMoveRotate' );

rotateEnd.set(event.touches[0].pageX,event.touches[0].pageY);

rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);

var element=scope.domElement===document?scope.domElement.body:scope.domElement;

rotateLeft(2*Math.PI*rotateDelta.x/element.clientHeight);// yes, height

rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight);

rotateStart.copy(rotateEnd);

scope.update();

}

function handleTouchMoveDollyPan(event){

//console.log( 'handleTouchMoveDollyPan' );

if(scope.enableZoom){

var dx=event.touches[0].pageX-event.touches[1].pageX;
var dy=event.touches[0].pageY-event.touches[1].pageY;

var distance=Math.sqrt(dx*dx+dy*dy);

dollyEnd.set(0,distance);

dollyDelta.set(0,Math.pow(dollyEnd.y/dollyStart.y,scope.zoomSpeed));

dollyIn(dollyDelta.y);

dollyStart.copy(dollyEnd);

}

if(scope.enablePan){

var x=0.5*(event.touches[0].pageX+event.touches[1].pageX);
var y=0.5*(event.touches[0].pageY+event.touches[1].pageY);

panEnd.set(x,y);

panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed);

pan(panDelta.x,panDelta.y);

panStart.copy(panEnd);

}

scope.update();

}

function handleTouchEnd(event){



}//console.log( 'handleTouchEnd' );

//
// event handlers - FSM: listen for events and reset state
//

function onMouseDown(event){

if(scope.enabled===false)return;

// Prevent the browser from scrolling.

event.preventDefault();

// Manually set the focus since calling preventDefault above
// prevents the browser from setting it automatically.

scope.domElement.focus?scope.domElement.focus():window.focus();

switch(event.button){

case scope.mouseButtons.LEFT:

if(event.ctrlKey||event.metaKey||event.shiftKey){

if(scope.enablePan===false)return;

handleMouseDownPan(event);

state=STATE.PAN;

}else{

if(scope.enableRotate===false)return;

handleMouseDownRotate(event);

state=STATE.ROTATE;

}

break;

case scope.mouseButtons.MIDDLE:

if(scope.enableZoom===false)return;

handleMouseDownDolly(event);

state=STATE.DOLLY;

break;

case scope.mouseButtons.RIGHT:

if(scope.enablePan===false)return;

handleMouseDownPan(event);

state=STATE.PAN;

break;}



if(state!==STATE.NONE){

document.addEventListener('mousemove',onMouseMove,false);
document.addEventListener('mouseup',onMouseUp,false);

scope.dispatchEvent(startEvent);

}

}

function onMouseMove(event){

if(scope.enabled===false)return;

event.preventDefault();

switch(state){

case STATE.ROTATE:

if(scope.enableRotate===false)return;

handleMouseMoveRotate(event);

break;

case STATE.DOLLY:

if(scope.enableZoom===false)return;

handleMouseMoveDolly(event);

break;

case STATE.PAN:

if(scope.enablePan===false)return;

handleMouseMovePan(event);

break;}



}

function onMouseUp(event){

if(scope.enabled===false)return;

handleMouseUp(event);

document.removeEventListener('mousemove',onMouseMove,false);
document.removeEventListener('mouseup',onMouseUp,false);

scope.dispatchEvent(endEvent);

state=STATE.NONE;

}

function onMouseWheel(event){

if(scope.enabled===false||scope.enableZoom===false||state!==STATE.NONE&&state!==STATE.ROTATE)return;

event.preventDefault();
event.stopPropagation();

scope.dispatchEvent(startEvent);

handleMouseWheel(event);

scope.dispatchEvent(endEvent);

}

function onKeyDown(event){

if(scope.enabled===false||scope.enableKeys===false||scope.enablePan===false)return;

handleKeyDown(event);

}

function onTouchStart(event){

if(scope.enabled===false)return;

event.preventDefault();

switch(event.touches.length){

case 1:// one-fingered touch: rotate

if(scope.enableRotate===false)return;

handleTouchStartRotate(event);

state=STATE.TOUCH_ROTATE;

break;

case 2:// two-fingered touch: dolly-pan

if(scope.enableZoom===false&&scope.enablePan===false)return;

handleTouchStartDollyPan(event);

state=STATE.TOUCH_DOLLY_PAN;

break;

default:

state=STATE.NONE;}



if(state!==STATE.NONE){

scope.dispatchEvent(startEvent);

}

}

function onTouchMove(event){

if(scope.enabled===false)return;

event.preventDefault();
event.stopPropagation();

switch(event.touches.length){

case 1:// one-fingered touch: rotate

if(scope.enableRotate===false)return;
if(state!==STATE.TOUCH_ROTATE)return;// is this needed?

handleTouchMoveRotate(event);

break;

case 2:// two-fingered touch: dolly-pan

if(scope.enableZoom===false&&scope.enablePan===false)return;
if(state!==STATE.TOUCH_DOLLY_PAN)return;// is this needed?

handleTouchMoveDollyPan(event);

break;

default:

state=STATE.NONE;}



}

function onTouchEnd(event){

if(scope.enabled===false)return;

handleTouchEnd(event);

scope.dispatchEvent(endEvent);

state=STATE.NONE;

}

function onContextMenu(event){

if(scope.enabled===false)return;

event.preventDefault();

}

//

scope.domElement.addEventListener('contextmenu',onContextMenu,false);

scope.domElement.addEventListener('mousedown',onMouseDown,false);
scope.domElement.addEventListener('wheel',onMouseWheel,false);

scope.domElement.addEventListener('touchstart',onTouchStart,false);
scope.domElement.addEventListener('touchend',onTouchEnd,false);
scope.domElement.addEventListener('touchmove',onTouchMove,false);

window.addEventListener('keydown',onKeyDown,false);

// force an update at start

this.update();

};

OrbitControls.prototype=Object.create(EventDispatcher.prototype);
OrbitControls.prototype.constructor=OrbitControls;

Object.defineProperties(OrbitControls.prototype,{

center:{

get:function get(){

console.warn('THREE.OrbitControls: .center has been renamed to .target');
return this.target;

}},



// backward compatibility

noZoom:{

get:function get(){

console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
return!this.enableZoom;

},

set:function set(value){

console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
this.enableZoom=!value;

}},



noRotate:{

get:function get(){

console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
return!this.enableRotate;

},

set:function set(value){

console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
this.enableRotate=!value;

}},



noPan:{

get:function get(){

console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
return!this.enablePan;

},

set:function set(value){

console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
this.enablePan=!value;

}},



noKeys:{

get:function get(){

console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
return!this.enableKeys;

},

set:function set(value){

console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
this.enableKeys=!value;

}},



staticMoving:{

get:function get(){

console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
return!this.enableDamping;

},

set:function set(value){

console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
this.enableDamping=!value;

}},



dynamicDampingFactor:{

get:function get(){

console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
return this.dampingFactor;

},

set:function set(value){

console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
this.dampingFactor=value;

}}});







// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-mixin.vue?vue&type=script&lang=js&





//
//
//
//
//
//
//
//
//
//
//




var suportWebGL=function(){
try{
var canvas=document.createElement('canvas');
return!!(window.WebGLRenderingContext&&(canvas.getContext('webgl')||canvas.getContext('experimental-webgl')));
}catch(e){
return false;
}
}();

var DEFAULT_GL_OPTIONS={
antialias:true,
alpha:true};

/* harmony default export */var model_mixinvue_type_script_lang_js_={
props:{
src:{
type:String},

width:{
type:Number},

height:{
type:Number},

position:{
type:Object,
default:function _default(){
return{
x:0,
y:0,
z:0};

}},

rotation:{
type:Object,
default:function _default(){
return{
x:0,
y:0,
z:0};

}},

scale:{
type:Object,
default:function _default(){
return{
x:1,
y:1,
z:1};

}},

lights:{
type:Array,
default:function _default(){
return[];
}},

cameraPosition:{
type:Object,
default:function _default(){
return{
x:0,
y:0,
z:0};

}},

cameraRotation:{
type:Object,
default:function _default(){
return{
x:0,
y:0,
z:0};

}},

cameraUp:{
type:Object},

cameraLookAt:{
type:Object},

backgroundColor:{
default:0xffffff},

backgroundAlpha:{
type:Number,
default:1},

controllable:{
type:Boolean,
default:true},

crossOrigin:{
default:'anonymous'},

gammaOutput:{
type:Boolean,
default:false},

glOptions:{
type:Object}},


data:function data(){
return{
suportWebGL:suportWebGL,
size:{
width:this.width,
height:this.height},

object:null,
raycaster:new Raycaster(),
mouse:new Vector2(),
camera:new PerspectiveCamera(45,1,0.01,100000),
scene:new Scene(),
wrapper:new Object3D(),
renderer:null,
controls:null,
allLights:[],
clock:typeof performance==='undefined'?Date:performance,
reqId:null// requestAnimationFrame id
};

},
computed:{
hasListener:function hasListener(){
// 判断是否有鼠标事件监听，用于减少不必要的拾取判断

/* eslint-disable no-underscore-dangle */
var events=this._events;
var result={};
['on-mousemove','on-mouseup','on-mousedown','on-click'].forEach(function(name){
result[name]=!!events[name]&&events[name].length>0;
});
return result;
}},

mounted:function mounted(){
if(this.width===undefined||this.height===undefined){
this.size={
width:this.$el.offsetWidth,
height:this.$el.offsetHeight};

}

var options=Object.assign({},DEFAULT_GL_OPTIONS,this.glOptions,{
canvas:this.$refs.canvas});

this.renderer=new WebGLRenderer(options);
this.renderer.shadowMap.enabled=true;
this.renderer.gammaOutput=this.gammaOutput;
this.scene.add(this.wrapper);
this.load();
this.update();
this.$el.addEventListener('mousedown',this.onMouseDown,false);
this.$el.addEventListener('mousemove',this.onMouseMove,false);
this.$el.addEventListener('mouseup',this.onMouseUp,false);
this.$el.addEventListener('click',this.onClick,false);
window.addEventListener('resize',this.onResize,false);
this.animate();
},
beforeDestroy:function beforeDestroy(){
cancelAnimationFrame(this.reqId);
this.$el.removeEventListener('mousedown',this.onMouseDown,false);
this.$el.removeEventListener('mousemove',this.onMouseMove,false);
this.$el.removeEventListener('mouseup',this.onMouseUp,false);
this.$el.removeEventListener('click',this.onClick,false);
window.removeEventListener('resize',this.onResize,false);
},
watch:{
src:function src(){
this.load();
},
rotation:{
deep:true,
handler:function handler(val){
if(!this.object)return;
this.object.rotation.set(val.x,val.y,val.z);
}},

position:{
deep:true,
handler:function handler(val){
if(!this.object)return;
this.object.position.set(val.x,val.y,val.z);
}},

scale:{
deep:true,
handler:function handler(val){
if(!this.object)return;
this.object.scale.set(val.x,val.y,val.z);
}},

lights:{
deep:true,
handler:function handler(){
this.updateLights();
}},

size:{
deep:true,
handler:function handler(){
this.updateCamera();
this.updateRenderer();
}},

controllable:function controllable(){
this.updateControls();
},
backgroundAlpha:function backgroundAlpha(){
this.updateRenderer();
},
backgroundColor:function backgroundColor(){
this.updateRenderer();
}},

methods:{
onResize:function onResize(){
var _this=this;

if(this.width===undefined||this.height===undefined){
this.$nextTick(function(){
_this.size={
width:_this.$el.offsetWidth,
height:_this.$el.offsetHeight};

});
}
},
onMouseDown:function onMouseDown(event){
if(!this.hasListener['on-mousedown'])return;
var intersected=this.pick(event.clientX,event.clientY);
this.$emit('on-mousedown',intersected);
},
onMouseMove:function onMouseMove(event){
if(!this.hasListener['on-mousemove'])return;
var intersected=this.pick(event.clientX,event.clientY);
this.$emit('on-mousemove',intersected);
},
onMouseUp:function onMouseUp(event){
if(!this.hasListener['on-mouseup'])return;
var intersected=this.pick(event.clientX,event.clientY);
this.$emit('on-mouseup',intersected);
},
onClick:function onClick(event){
if(!this.hasListener['on-click'])return;
var intersected=this.pick(event.clientX,event.clientY);
this.$emit('on-click',intersected);
},
pick:function pick(x,y){
if(!this.object)return null;
var rect=this.$el.getBoundingClientRect();
x-=rect.left;
y-=rect.top;
this.mouse.x=x/this.size.width*2-1;
this.mouse.y=-(y/this.size.height)*2+1;
this.raycaster.setFromCamera(this.mouse,this.camera);
var intersects=this.raycaster.intersectObject(this.object,true);
return(intersects&&intersects.length)>0?intersects[0]:null;
},
update:function update(){
this.updateRenderer();
this.updateCamera();
this.updateLights();
this.updateControls();
},
updateModel:function updateModel(){
var object=this.object;
if(!object)return;
var position=this.position;
var rotation=this.rotation;
var scale=this.scale;
object.position.set(position.x,position.y,position.z);
object.rotation.set(rotation.x,rotation.y,rotation.z);
object.scale.set(scale.x,scale.y,scale.z);
},
updateRenderer:function updateRenderer(){
var renderer=this.renderer;
renderer.setSize(this.size.width,this.size.height);
renderer.setPixelRatio(window.devicePixelRatio||1);
renderer.setClearColor(new Color(this.backgroundColor).getHex());
renderer.setClearAlpha(this.backgroundAlpha);
},
updateCamera:function updateCamera(){
var camera=this.camera;
var object=this.object;
camera.aspect=this.size.width/this.size.height;
camera.updateProjectionMatrix();

if(!this.cameraLookAt&&!this.cameraUp){
if(!object)return;
var distance=getSize(object).length();
camera.position.set(this.cameraPosition.x,this.cameraPosition.y,this.cameraPosition.z);
camera.rotation.set(this.cameraRotation.x,this.cameraRotation.y,this.cameraRotation.z);

if(this.cameraPosition.x===0&&this.cameraPosition.y===0&&this.cameraPosition.z===0){
camera.position.z=distance;
}

camera.lookAt(new Vector3());
}else{
camera.position.set(this.cameraPosition.x,this.cameraPosition.y,this.cameraPosition.z);
camera.rotation.set(this.cameraRotation.x,this.cameraRotation.y,this.cameraRotation.z);
camera.up.set(this.cameraUp.x,this.cameraUp.y,this.cameraUp.z);
camera.lookAt(new Vector3(this.cameraLookAt.x,this.cameraLookAt.y,this.cameraLookAt.z));
}
},
updateLights:function updateLights(){
var _this$scene,
_this2=this;

(_this$scene=this.scene).remove.apply(_this$scene,_toConsumableArray(this.allLights));

this.allLights=[];
this.lights.forEach(function(item){
if(!item.type)return;
var type=item.type.toLowerCase();
var light=null;

if(type==='ambient'||type==='ambientlight'){
var color=item.color===0x000000?item.color:item.color||0x404040;
var intensity=item.intensity===0?item.intensity:item.intensity||1;
light=new AmbientLight(color,intensity);
}else if(type==='point'||type==='pointlight'){
var _color=item.color===0x000000?item.color:item.color||0xffffff;

var _intensity=item.intensity===0?item.intensity:item.intensity||1;

var distance=item.distance||0;
var decay=item.decay===0?item.decay:item.decay||1;
light=new PointLight(_color,_intensity,distance,decay);

if(item.position){
light.position.copy(item.position);
}
}else if(type==='directional'||type==='directionallight'){
var _color2=item.color===0x000000?item.color:item.color||0xffffff;

var _intensity2=item.intensity===0?item.intensity:item.intensity||1;

light=new DirectionalLight(_color2,_intensity2);

if(item.position){
light.position.copy(item.position);
}

if(item.target){
light.target.copy(item.target);
}
}else if(type==='hemisphere'||type==='hemispherelight'){
var skyColor=item.skyColor===0x000000?item.skyColor:item.skyColor||0xffffff;
var groundColor=item.groundColor===0x000000?item.groundColor:item.groundColor||0xffffff;

var _intensity3=item.intensity===0?item.intensity:item.intensity||1;

light=new HemisphereLight(skyColor,groundColor,_intensity3);

if(item.position){
light.position.copy(item.position);
}
}

_this2.allLights.push(light);

_this2.scene.add(light);
});
},
updateControls:function updateControls(){
if(this.controllable&&this.controls)return;

if(this.controllable){
if(this.controls)return;
this.controls=new OrbitControls(this.camera,this.$el);
this.controls.type='orbit';
}else if(this.controls){
this.controls.dispose();
this.controls=null;
}
},
load:function load(){
var _this3=this;

if(!this.src)return;

if(this.object){
this.wrapper.remove(this.object);
}

this.loader.load(this.src,function(){
var object=_this3.getObject.apply(_this3,arguments);

if(_this3.process){
_this3.process(object);
}

_this3.addObject(object);

_this3.$emit('on-load');
},function(xhr){
_this3.$emit('on-progress',xhr);
},function(err){
_this3.$emit('on-error',err);
});
},
getObject:function getObject(object){
return object;
},
addObject:function addObject(object){
var center=getCenter(object);// correction position

this.wrapper.position.copy(center.negate());
this.object=object;
this.wrapper.add(object);
this.updateCamera();
this.updateModel();
},
animate:function animate(){
this.reqId=requestAnimationFrame(this.animate);
this.render();
},
render:function render(){
this.renderer.render(this.scene,this.camera);
}}};


// CONCATENATED MODULE: ./src/model-mixin.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_mixinvue_type_script_lang_js_=model_mixinvue_type_script_lang_js_;
// CONCATENATED MODULE: ./node_modules/_vue-loader@15.7.0@vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent(
scriptExports,
render,
staticRenderFns,
functionalTemplate,
injectStyles,
scopeId,
moduleIdentifier,/* server only */
shadowMode/* vue-cli only */)
{
// Vue.extend constructor export interop
var options=typeof scriptExports==='function'?
scriptExports.options:
scriptExports;

// render functions
if(render){
options.render=render;
options.staticRenderFns=staticRenderFns;
options._compiled=true;
}

// functional template
if(functionalTemplate){
options.functional=true;
}

// scopedId
if(scopeId){
options._scopeId='data-v-'+scopeId;
}

var hook;
if(moduleIdentifier){// server build
hook=function hook(context){
// 2.3 injection
context=
context||// cached call
this.$vnode&&this.$vnode.ssrContext||// stateful
this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext;// functional
// 2.2 with runInNewContext: true
if(!context&&typeof __VUE_SSR_CONTEXT__!=='undefined'){
context=__VUE_SSR_CONTEXT__;
}
// inject component styles
if(injectStyles){
injectStyles.call(this,context);
}
// register component module identifier for async chunk inferrence
if(context&&context._registeredComponents){
context._registeredComponents.add(moduleIdentifier);
}
};
// used by ssr in case component is cached and beforeCreate
// never gets called
options._ssrRegister=hook;
}else if(injectStyles){
hook=shadowMode?
function(){injectStyles.call(this,this.$root.$options.shadowRoot);}:
injectStyles;
}

if(hook){
if(options.functional){
// for template-only hot-reload because in that case the render fn doesn't
// go through the normalizer
options._injectStyles=hook;
// register for functioal component in vue file
var originalRender=options.render;
options.render=function renderWithStyleInjection(h,context){
hook.call(context);
return originalRender(h,context);
};
}else{
// inject component registration as beforeCreate hook
var existing=options.beforeCreate;
options.beforeCreate=existing?
[].concat(existing,hook):
[hook];
}
}

return{
exports:scriptExports,
options:options};

}

// CONCATENATED MODULE: ./src/model-mixin.vue





/* normalize component */

var component=normalizeComponent(
src_model_mixinvue_type_script_lang_js_,
render,
staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_mixin=component.exports;
// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-obj.vue?vue&type=script&lang=js&





// TODO: Better way to handle texture formats

Loader.Handlers.add(/\.dds$/i,new DDSLoader());
/* harmony default export */var model_objvue_type_script_lang_js_={
name:'model-obj',
mixins:[model_mixin],
props:{
lights:{
type:Array,
default:function _default(){
return[{
type:'HemisphereLight',
position:{
x:0,
y:1,
z:0},

skyColor:0xaaaaff,
groundColor:0x806060,
intensity:0.2},
{
type:'DirectionalLight',
position:{
x:1,
y:1,
z:1},

color:0xffffff,
intensity:0.8}];

}},

smoothing:{
type:Boolean,
default:false},

mtlPath:{
type:String},

mtl:{
type:String}},


data:function data(){
var objLoader=new OBJLoader_OBJLoader();
var mtlLoader=new MTLLoader();
mtlLoader.setCrossOrigin(this.crossOrigin);
return{
loader:objLoader,
mtlLoader:mtlLoader};

},
watch:{
mtl:function mtl(){
this.load();
}},

methods:{
process:function process(object){
if(this.smoothing){
object.traverse(function(child){
if(child.geometry){
child.geometry=toIndexed(child.geometry);
child.geometry.computeVertexNormals();
}
});
}
},
load:function load(){
var _this=this;

if(!this.src)return;

if(this.object){
this.wrapper.remove(this.object);
}

var onLoad=function onLoad(object){
if(_this.process){
_this.process(object);
}

_this.addObject(object);

_this.$emit('on-load');
};

var onProgress=function onProgress(xhr){
_this.$emit('on-progress',xhr);
};

var onError=function onError(err){
_this.$emit('on-error',err);
};

if(this.mtl){
var mtlPath=this.mtlPath;
var mtlSrc=this.mtl;

if(!this.mtlPath){
var result=/^(.*\/)([^/]*)$/.exec(this.mtl);

if(result){
mtlPath=result[1];
mtlSrc=result[2];
}
}

if(mtlPath){
this.mtlLoader.setPath(mtlPath);
}

this.mtlLoader.load(mtlSrc,function(materials){
materials.preload();

_this.loader.setMaterials(materials).load(_this.src,onLoad,onProgress,onError);
},function(){},onError);
}else{
this.loader.load(this.src,onLoad,onProgress,onError);
}
}}};


// CONCATENATED MODULE: ./src/model-obj.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_objvue_type_script_lang_js_=model_objvue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-obj.vue
var model_obj_render,model_obj_staticRenderFns;




/* normalize component */

var model_obj_component=normalizeComponent(
src_model_objvue_type_script_lang_js_,
model_obj_render,
model_obj_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_obj=model_obj_component.exports;
// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-three.vue?vue&type=script&lang=js&


/* harmony default export */var model_threevue_type_script_lang_js_={
name:'model-three',
mixins:[model_mixin],
data:function data(){
var loader=new ObjectLoader();
loader.setCrossOrigin(this.crossOrigin);
return{
loader:loader};

}};

// CONCATENATED MODULE: ./src/model-three.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_threevue_type_script_lang_js_=model_threevue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-three.vue
var model_three_render,model_three_staticRenderFns;




/* normalize component */

var model_three_component=normalizeComponent(
src_model_threevue_type_script_lang_js_,
model_three_render,
model_three_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_three=model_three_component.exports;
// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/STLLoader.js
/**
 * @author aleeper / http://adamleeper.com/
 * @author mrdoob / http://mrdoob.com/
 * @author gero3 / https://github.com/gero3
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
 *
 * Supports both binary and ASCII encoded files, with automatic detection of type.
 *
 * The loader returns a non-indexed buffer geometry.
 *
 * Limitations:
 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
 *  ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *  var loader = new STLLoader();
 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
 *    scene.add( new THREE.Mesh( geometry ) );
 *  });
 *
 * For binary STLs geometry might contain colors for vertices. To use it:
 *  // use the same code to load STL as above
 *  if (geometry.hasColors) {
 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
 *  } else { .... }
 *  var mesh = new THREE.Mesh( geometry, material );
 */




var STLLoader=function STLLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

};

STLLoader.prototype={

constructor:STLLoader,

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(scope.manager);
loader.setPath(scope.path);
loader.setResponseType('arraybuffer');
loader.load(url,function(text){

try{

onLoad(scope.parse(text));

}catch(exception){

if(onError){

onError(exception);

}

}

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;
return this;

},

parse:function parse(data){

function isBinary(data){

var expect,face_size,n_faces,reader;
reader=new DataView(data);
face_size=32/8*3+32/8*3*3+16/8;
n_faces=reader.getUint32(80,true);
expect=80+32/8+n_faces*face_size;

if(expect===reader.byteLength){

return true;

}

// An ASCII STL data must begin with 'solid ' as the first six bytes.
// However, ASCII STLs lacking the SPACE after the 'd' are known to be
// plentiful.  So, check the first 5 bytes for 'solid'.

// Several encodings, such as UTF-8, precede the text with up to 5 bytes:
// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
// Search for "solid" to start anywhere after those prefixes.

// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'

var solid=[115,111,108,105,100];

for(var off=0;off<5;off++){

// If "solid" text is matched to the current offset, declare it to be an ASCII STL.

if(matchDataViewAt(solid,reader,off))return false;

}

// Couldn't find "solid" text at the beginning; it is binary STL.

return true;

}

function matchDataViewAt(query,reader,offset){

// Check if each byte in query matches the corresponding byte from the current offset

for(var i=0,il=query.length;i<il;i++){

if(query[i]!==reader.getUint8(offset+i,false))return false;

}

return true;

}

function parseBinary(data){

var reader=new DataView(data);
var faces=reader.getUint32(80,true);

var r,g,b,hasColors=false,colors;
var defaultR,defaultG,defaultB,alpha;

// process STL header
// check for default color in header ("COLOR=rgba" sequence).

for(var index=0;index<80-10;index++){

if(reader.getUint32(index,false)==0x434F4C4F/*COLO*/&&
reader.getUint8(index+4)==0x52/*'R'*/&&
reader.getUint8(index+5)==0x3D/*'='*/){

hasColors=true;
colors=[];

defaultR=reader.getUint8(index+6)/255;
defaultG=reader.getUint8(index+7)/255;
defaultB=reader.getUint8(index+8)/255;
alpha=reader.getUint8(index+9)/255;

}

}

var dataOffset=84;
var faceLength=12*4+2;

var geometry=new BufferGeometry();

var vertices=[];
var normals=[];

for(var face=0;face<faces;face++){

var start=dataOffset+face*faceLength;
var normalX=reader.getFloat32(start,true);
var normalY=reader.getFloat32(start+4,true);
var normalZ=reader.getFloat32(start+8,true);

if(hasColors){

var packedColor=reader.getUint16(start+48,true);

if((packedColor&0x8000)===0){

// facet has its own unique color

r=(packedColor&0x1F)/31;
g=(packedColor>>5&0x1F)/31;
b=(packedColor>>10&0x1F)/31;

}else{

r=defaultR;
g=defaultG;
b=defaultB;

}

}

for(var i=1;i<=3;i++){

var vertexstart=start+i*12;

vertices.push(reader.getFloat32(vertexstart,true));
vertices.push(reader.getFloat32(vertexstart+4,true));
vertices.push(reader.getFloat32(vertexstart+8,true));

normals.push(normalX,normalY,normalZ);

if(hasColors){

colors.push(r,g,b);

}

}

}

geometry.addAttribute('position',new BufferAttribute(new Float32Array(vertices),3));
geometry.addAttribute('normal',new BufferAttribute(new Float32Array(normals),3));

if(hasColors){

geometry.addAttribute('color',new BufferAttribute(new Float32Array(colors),3));
geometry.hasColors=true;
geometry.alpha=alpha;

}

return geometry;

}

function parseASCII(data){

var geometry=new BufferGeometry();
var patternFace=/facet([\s\S]*?)endfacet/g;
var faceCounter=0;

var patternFloat=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source;
var patternVertex=new RegExp('vertex'+patternFloat+patternFloat+patternFloat,'g');
var patternNormal=new RegExp('normal'+patternFloat+patternFloat+patternFloat,'g');

var vertices=[];
var normals=[];

var normal=new Vector3();

var result;

while((result=patternFace.exec(data))!==null){

var vertexCountPerFace=0;
var normalCountPerFace=0;

var text=result[0];

while((result=patternNormal.exec(text))!==null){

normal.x=parseFloat(result[1]);
normal.y=parseFloat(result[2]);
normal.z=parseFloat(result[3]);
normalCountPerFace++;

}

while((result=patternVertex.exec(text))!==null){

vertices.push(parseFloat(result[1]),parseFloat(result[2]),parseFloat(result[3]));
normals.push(normal.x,normal.y,normal.z);
vertexCountPerFace++;

}

// every face have to own ONE valid normal

if(normalCountPerFace!==1){

console.error('THREE.STLLoader: Something isn\'t right with the normal of face number '+faceCounter);

}

// each face have to own THREE valid vertices

if(vertexCountPerFace!==3){

console.error('THREE.STLLoader: Something isn\'t right with the vertices of face number '+faceCounter);

}

faceCounter++;

}

geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));
geometry.addAttribute('normal',new Float32BufferAttribute(normals,3));

return geometry;

}

function ensureString(buffer){

if(typeof buffer!=='string'){

return LoaderUtils.decodeText(new Uint8Array(buffer));

}

return buffer;

}

function ensureBinary(buffer){

if(typeof buffer==='string'){

var array_buffer=new Uint8Array(buffer.length);
for(var i=0;i<buffer.length;i++){

array_buffer[i]=buffer.charCodeAt(i)&0xff;// implicitly assumes little-endian

}
return array_buffer.buffer||array_buffer;

}else{

return buffer;

}

}

// start

var binData=ensureBinary(data);

return isBinary(binData)?parseBinary(binData):parseASCII(ensureString(data));

}};





// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-stl.vue?vue&type=script&lang=js&



/* harmony default export */var model_stlvue_type_script_lang_js_={
name:'model-stl',
mixins:[model_mixin],
props:{
lights:{
type:Array,
default:function _default(){
return[{
type:'HemisphereLight',
position:{
x:0,
y:1,
z:0},

skyColor:0xaaaaff,
groundColor:0x806060,
intensity:0.2},
{
type:'DirectionalLight',
position:{
x:1,
y:1,
z:1},

color:0xffffff,
intensity:0.8}];

}}},


data:function data(){
return{
loader:new STLLoader()};

},
methods:{
getObject:function getObject(geometry){
return new Mesh(geometry,new MeshPhongMaterial());
}}};


// CONCATENATED MODULE: ./src/model-stl.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_stlvue_type_script_lang_js_=model_stlvue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-stl.vue
var model_stl_render,model_stl_staticRenderFns;




/* normalize component */

var model_stl_component=normalizeComponent(
src_model_stlvue_type_script_lang_js_,
model_stl_render,
model_stl_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_stl=model_stl_component.exports;
// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/PLYLoader.js
/**
 * @author Wei Meng / http://about.me/menway
 *
 * Description: A THREE loader for PLY ASCII files (known as the Polygon
 * File Format or the Stanford Triangle Format).
 *
 * Limitations: ASCII decoding assumes file is UTF-8.
 *
 * Usage:
 *	var loader = new PLYLoader();
 *	loader.load('./models/ply/ascii/dolphins.ply', function (geometry) {
 *
 *		scene.add( new THREE.Mesh( geometry ) );
 *
 *	} );
 *
 * If the PLY file uses non standard property names, they can be mapped while
 * loading. For example, the following maps the properties
 * “diffuse_(red|green|blue)” in the file to standard color names.
 *
 * loader.setPropertyNameMapping( {
 *	diffuse_red: 'red',
 *	diffuse_green: 'green',
 *	diffuse_blue: 'blue'
 * } );
 *
 */




var PLYLoader=function PLYLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

this.propertyNameMapping={};

};

PLYLoader.prototype={

constructor:PLYLoader,

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var loader=new FileLoader(this.manager);
loader.setPath(this.path);
loader.setResponseType('arraybuffer');
loader.load(url,function(text){

onLoad(scope.parse(text));

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;
return this;

},

setPropertyNameMapping:function setPropertyNameMapping(mapping){

this.propertyNameMapping=mapping;

},

parse:function parse(data){

function parseHeader(data){

var patternHeader=/ply([\s\S]*)end_header\r?\n/;
var headerText='';
var headerLength=0;
var result=patternHeader.exec(data);

if(result!==null){

headerText=result[1];
headerLength=result[0].length;

}

var header={
comments:[],
elements:[],
headerLength:headerLength};


var lines=headerText.split('\n');
var currentElement;
var lineType,lineValues;

function make_ply_element_property(propertValues,propertyNameMapping){

var property={type:propertValues[0]};

if(property.type==='list'){

property.name=propertValues[3];
property.countType=propertValues[1];
property.itemType=propertValues[2];

}else{

property.name=propertValues[1];

}

if(property.name in propertyNameMapping){

property.name=propertyNameMapping[property.name];

}

return property;

}

for(var i=0;i<lines.length;i++){

var line=lines[i];
line=line.trim();

if(line==='')continue;

lineValues=line.split(/\s+/);
lineType=lineValues.shift();
line=lineValues.join(' ');

switch(lineType){

case'format':

header.format=lineValues[0];
header.version=lineValues[1];

break;

case'comment':

header.comments.push(line);

break;

case'element':

if(currentElement!==undefined){

header.elements.push(currentElement);

}

currentElement={};
currentElement.name=lineValues[0];
currentElement.count=parseInt(lineValues[1]);
currentElement.properties=[];

break;

case'property':

currentElement.properties.push(make_ply_element_property(lineValues,scope.propertyNameMapping));

break;


default:

console.log('unhandled',lineType,lineValues);}



}

if(currentElement!==undefined){

header.elements.push(currentElement);

}

return header;

}

function parseASCIINumber(n,type){

switch(type){

case'char':case'uchar':case'short':case'ushort':case'int':case'uint':
case'int8':case'uint8':case'int16':case'uint16':case'int32':case'uint32':

return parseInt(n);

case'float':case'double':case'float32':case'float64':

return parseFloat(n);}



}

function parseASCIIElement(properties,line){

var values=line.split(/\s+/);

var element={};

for(var i=0;i<properties.length;i++){

if(properties[i].type==='list'){

var list=[];
var n=parseASCIINumber(values.shift(),properties[i].countType);

for(var j=0;j<n;j++){

list.push(parseASCIINumber(values.shift(),properties[i].itemType));

}

element[properties[i].name]=list;

}else{

element[properties[i].name]=parseASCIINumber(values.shift(),properties[i].type);

}

}

return element;

}

function parseASCII(data,header){

// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)

var buffer={
indices:[],
vertices:[],
normals:[],
uvs:[],
faceVertexUvs:[],
colors:[]};


var result;

var patternBody=/end_header\s([\s\S]*)$/;
var body='';
if((result=patternBody.exec(data))!==null){

body=result[1];

}

var lines=body.split('\n');
var currentElement=0;
var currentElementCount=0;

for(var i=0;i<lines.length;i++){

var line=lines[i];
line=line.trim();
if(line===''){

continue;

}

if(currentElementCount>=header.elements[currentElement].count){

currentElement++;
currentElementCount=0;

}

var element=parseASCIIElement(header.elements[currentElement].properties,line);

handleElement(buffer,header.elements[currentElement].name,element);

currentElementCount++;

}

return postProcess(buffer);

}

function postProcess(buffer){

var geometry=new BufferGeometry();

// mandatory buffer data

if(buffer.indices.length>0){

geometry.setIndex(buffer.indices);

}

geometry.addAttribute('position',new Float32BufferAttribute(buffer.vertices,3));

// optional buffer data

if(buffer.normals.length>0){

geometry.addAttribute('normal',new Float32BufferAttribute(buffer.normals,3));

}

if(buffer.uvs.length>0){

geometry.addAttribute('uv',new Float32BufferAttribute(buffer.uvs,2));

}

if(buffer.colors.length>0){

geometry.addAttribute('color',new Float32BufferAttribute(buffer.colors,3));

}

if(buffer.faceVertexUvs.length>0){

geometry=geometry.toNonIndexed();
geometry.addAttribute('uv',new Float32BufferAttribute(buffer.faceVertexUvs,2));

}

geometry.computeBoundingSphere();

return geometry;

}

function handleElement(buffer,elementName,element){

if(elementName==='vertex'){

buffer.vertices.push(element.x,element.y,element.z);

if('nx'in element&&'ny'in element&&'nz'in element){

buffer.normals.push(element.nx,element.ny,element.nz);

}

if('s'in element&&'t'in element){

buffer.uvs.push(element.s,element.t);

}

if('red'in element&&'green'in element&&'blue'in element){

buffer.colors.push(element.red/255.0,element.green/255.0,element.blue/255.0);

}

}else if(elementName==='face'){

var vertex_indices=element.vertex_indices||element.vertex_index;// issue #9338
var texcoord=element.texcoord;

if(vertex_indices.length===3){

buffer.indices.push(vertex_indices[0],vertex_indices[1],vertex_indices[2]);

if(texcoord&&texcoord.length===6){

buffer.faceVertexUvs.push(texcoord[0],texcoord[1]);
buffer.faceVertexUvs.push(texcoord[2],texcoord[3]);
buffer.faceVertexUvs.push(texcoord[4],texcoord[5]);

}

}else if(vertex_indices.length===4){

buffer.indices.push(vertex_indices[0],vertex_indices[1],vertex_indices[3]);
buffer.indices.push(vertex_indices[1],vertex_indices[2],vertex_indices[3]);

}

}

}

function binaryRead(dataview,at,type,little_endian){

switch(type){

// corespondences for non-specific length types here match rply:
case'int8':case'char':return[dataview.getInt8(at),1];
case'uint8':case'uchar':return[dataview.getUint8(at),1];
case'int16':case'short':return[dataview.getInt16(at,little_endian),2];
case'uint16':case'ushort':return[dataview.getUint16(at,little_endian),2];
case'int32':case'int':return[dataview.getInt32(at,little_endian),4];
case'uint32':case'uint':return[dataview.getUint32(at,little_endian),4];
case'float32':case'float':return[dataview.getFloat32(at,little_endian),4];
case'float64':case'double':return[dataview.getFloat64(at,little_endian),8];}



}

function binaryReadElement(dataview,at,properties,little_endian){

var element={};
var result,read=0;

for(var i=0;i<properties.length;i++){

if(properties[i].type==='list'){

var list=[];

result=binaryRead(dataview,at+read,properties[i].countType,little_endian);
var n=result[0];
read+=result[1];

for(var j=0;j<n;j++){

result=binaryRead(dataview,at+read,properties[i].itemType,little_endian);
list.push(result[0]);
read+=result[1];

}

element[properties[i].name]=list;

}else{

result=binaryRead(dataview,at+read,properties[i].type,little_endian);
element[properties[i].name]=result[0];
read+=result[1];

}

}

return[element,read];

}

function parseBinary(data,header){

var buffer={
indices:[],
vertices:[],
normals:[],
uvs:[],
faceVertexUvs:[],
colors:[]};


var little_endian=header.format==='binary_little_endian';
var body=new DataView(data,header.headerLength);
var result,loc=0;

for(var currentElement=0;currentElement<header.elements.length;currentElement++){

for(var currentElementCount=0;currentElementCount<header.elements[currentElement].count;currentElementCount++){

result=binaryReadElement(body,loc,header.elements[currentElement].properties,little_endian);
loc+=result[1];
var element=result[0];

handleElement(buffer,header.elements[currentElement].name,element);

}

}

return postProcess(buffer);

}

//

var geometry;
var scope=this;

if(data instanceof ArrayBuffer){

var text=LoaderUtils.decodeText(new Uint8Array(data));
var header=parseHeader(text);

geometry=header.format==='ascii'?parseASCII(text,header):parseBinary(data,header);

}else{

geometry=parseASCII(data,parseHeader(data));

}

return geometry;

}};





// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-ply.vue?vue&type=script&lang=js&



/* harmony default export */var model_plyvue_type_script_lang_js_={
name:'model-ply',
mixins:[model_mixin],
props:{
lights:{
type:Array,
default:function _default(){
return[{
type:'HemisphereLight',
position:{
x:0,
y:1,
z:0},

skyColor:0xaaaaff,
groundColor:0x806060,
intensity:0.2},
{
type:'DirectionalLight',
position:{
x:1,
y:1,
z:1},

color:0xffffff,
intensity:0.8}];

}}},


data:function data(){
return{
loader:new PLYLoader()};

},
methods:{
getObject:function getObject(geometry){
geometry.computeVertexNormals();
return new Mesh(geometry,new MeshStandardMaterial());
}}};


// CONCATENATED MODULE: ./src/model-ply.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_plyvue_type_script_lang_js_=model_plyvue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-ply.vue
var model_ply_render,model_ply_staticRenderFns;




/* normalize component */

var model_ply_component=normalizeComponent(
src_model_plyvue_type_script_lang_js_,
model_ply_render,
model_ply_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_ply=model_ply_component.exports;
// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/TGALoader.js
/*
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 * @author mrdoob / http://mrdoob.com/
 * @author takahirox / https://github.com/takahirox/
 */



var TGALoader=function TGALoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

};

TGALoader.prototype={

constructor:TGALoader,

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var texture=new Texture();

var loader=new FileLoader(this.manager);
loader.setResponseType('arraybuffer');
loader.setPath(this.path);

loader.load(url,function(buffer){

texture.image=scope.parse(buffer);
texture.needsUpdate=true;

if(onLoad!==undefined){

onLoad(texture);

}

},onProgress,onError);

return texture;

},

parse:function parse(buffer){

// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js

function tgaCheckHeader(header){

switch(header.image_type){

// check indexed type

case TGA_TYPE_INDEXED:
case TGA_TYPE_RLE_INDEXED:
if(header.colormap_length>256||header.colormap_size!==24||header.colormap_type!==1){

console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');

}
break;

// check colormap type

case TGA_TYPE_RGB:
case TGA_TYPE_GREY:
case TGA_TYPE_RLE_RGB:
case TGA_TYPE_RLE_GREY:
if(header.colormap_type){

console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');

}
break;

// What the need of a file without data ?

case TGA_TYPE_NO_DATA:
console.error('THREE.TGALoader: No data.');

// Invalid type ?

default:
console.error('THREE.TGALoader: Invalid type "%s".',header.image_type);}



// check image width and height

if(header.width<=0||header.height<=0){

console.error('THREE.TGALoader: Invalid image size.');

}

// check image pixel size

if(header.pixel_size!==8&&header.pixel_size!==16&&
header.pixel_size!==24&&header.pixel_size!==32){

console.error('THREE.TGALoader: Invalid pixel size "%s".',header.pixel_size);

}

}

// parse tga image buffer

function tgaParse(use_rle,use_pal,header,offset,data){

var pixel_data,
pixel_size,
pixel_total,
palettes;

pixel_size=header.pixel_size>>3;
pixel_total=header.width*header.height*pixel_size;

// read palettes

if(use_pal){

palettes=data.subarray(offset,offset+=header.colormap_length*(header.colormap_size>>3));

}

// read RLE

if(use_rle){

pixel_data=new Uint8Array(pixel_total);

var c,count,i;
var shift=0;
var pixels=new Uint8Array(pixel_size);

while(shift<pixel_total){

c=data[offset++];
count=(c&0x7f)+1;

// RLE pixels

if(c&0x80){

// bind pixel tmp array

for(i=0;i<pixel_size;++i){

pixels[i]=data[offset++];

}

// copy pixel array

for(i=0;i<count;++i){

pixel_data.set(pixels,shift+i*pixel_size);

}

shift+=pixel_size*count;

}else{

// raw pixels

count*=pixel_size;
for(i=0;i<count;++i){

pixel_data[shift+i]=data[offset++];

}
shift+=count;

}

}

}else{

// raw pixels

pixel_data=data.subarray(
offset,offset+=use_pal?header.width*header.height:pixel_total);


}

return{
pixel_data:pixel_data,
palettes:palettes};


}

function tgaGetImageData8bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image,palettes){

var colormap=palettes;
var color,i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i++){

color=image[i];
imageData[(x+width*y)*4+3]=255;
imageData[(x+width*y)*4+2]=colormap[color*3+0];
imageData[(x+width*y)*4+1]=colormap[color*3+1];
imageData[(x+width*y)*4+0]=colormap[color*3+2];

}

}

return imageData;

}

function tgaGetImageData16bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){

var color,i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i+=2){

color=image[i+0]+(image[i+1]<<8);// Inversed ?
imageData[(x+width*y)*4+0]=(color&0x7C00)>>7;
imageData[(x+width*y)*4+1]=(color&0x03E0)>>2;
imageData[(x+width*y)*4+2]=(color&0x001F)>>3;
imageData[(x+width*y)*4+3]=color&0x8000?0:255;

}

}

return imageData;

}

function tgaGetImageData24bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){

var i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i+=3){

imageData[(x+width*y)*4+3]=255;
imageData[(x+width*y)*4+2]=image[i+0];
imageData[(x+width*y)*4+1]=image[i+1];
imageData[(x+width*y)*4+0]=image[i+2];

}

}

return imageData;

}

function tgaGetImageData32bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){

var i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i+=4){

imageData[(x+width*y)*4+2]=image[i+0];
imageData[(x+width*y)*4+1]=image[i+1];
imageData[(x+width*y)*4+0]=image[i+2];
imageData[(x+width*y)*4+3]=image[i+3];

}

}

return imageData;

}

function tgaGetImageDataGrey8bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){

var color,i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i++){

color=image[i];
imageData[(x+width*y)*4+0]=color;
imageData[(x+width*y)*4+1]=color;
imageData[(x+width*y)*4+2]=color;
imageData[(x+width*y)*4+3]=255;

}

}

return imageData;

}

function tgaGetImageDataGrey16bits(imageData,y_start,y_step,y_end,x_start,x_step,x_end,image){

var i=0,x,y;
var width=header.width;

for(y=y_start;y!==y_end;y+=y_step){

for(x=x_start;x!==x_end;x+=x_step,i+=2){

imageData[(x+width*y)*4+0]=image[i+0];
imageData[(x+width*y)*4+1]=image[i+0];
imageData[(x+width*y)*4+2]=image[i+0];
imageData[(x+width*y)*4+3]=image[i+1];

}

}

return imageData;

}

function getTgaRGBA(data,width,height,image,palette){

var x_start,
y_start,
x_step,
y_step,
x_end,
y_end;

switch((header.flags&TGA_ORIGIN_MASK)>>TGA_ORIGIN_SHIFT){

default:
case TGA_ORIGIN_UL:
x_start=0;
x_step=1;
x_end=width;
y_start=0;
y_step=1;
y_end=height;
break;

case TGA_ORIGIN_BL:
x_start=0;
x_step=1;
x_end=width;
y_start=height-1;
y_step=-1;
y_end=-1;
break;

case TGA_ORIGIN_UR:
x_start=width-1;
x_step=-1;
x_end=-1;
y_start=0;
y_step=1;
y_end=height;
break;

case TGA_ORIGIN_BR:
x_start=width-1;
x_step=-1;
x_end=-1;
y_start=height-1;
y_step=-1;
y_end=-1;
break;}



if(use_grey){

switch(header.pixel_size){

case 8:
tgaGetImageDataGrey8bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);
break;

case 16:
tgaGetImageDataGrey16bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);
break;

default:
console.error('THREE.TGALoader: Format not supported.');
break;}



}else{

switch(header.pixel_size){

case 8:
tgaGetImageData8bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image,palette);
break;

case 16:
tgaGetImageData16bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);
break;

case 24:
tgaGetImageData24bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);
break;

case 32:
tgaGetImageData32bits(data,y_start,y_step,y_end,x_start,x_step,x_end,image);
break;

default:
console.error('THREE.TGALoader: Format not supported.');
break;}



}

// Load image data according to specific method
// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';
// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );
return data;

}

// TGA constants

var TGA_TYPE_NO_DATA=0,
TGA_TYPE_INDEXED=1,
TGA_TYPE_RGB=2,
TGA_TYPE_GREY=3,
TGA_TYPE_RLE_INDEXED=9,
TGA_TYPE_RLE_RGB=10,
TGA_TYPE_RLE_GREY=11,

TGA_ORIGIN_MASK=0x30,
TGA_ORIGIN_SHIFT=0x04,
TGA_ORIGIN_BL=0x00,
TGA_ORIGIN_BR=0x01,
TGA_ORIGIN_UL=0x02,
TGA_ORIGIN_UR=0x03;

if(buffer.length<19)console.error('THREE.TGALoader: Not enough data to contain header.');

var content=new Uint8Array(buffer),
offset=0,
header={
id_length:content[offset++],
colormap_type:content[offset++],
image_type:content[offset++],
colormap_index:content[offset++]|content[offset++]<<8,
colormap_length:content[offset++]|content[offset++]<<8,
colormap_size:content[offset++],
origin:[
content[offset++]|content[offset++]<<8,
content[offset++]|content[offset++]<<8],

width:content[offset++]|content[offset++]<<8,
height:content[offset++]|content[offset++]<<8,
pixel_size:content[offset++],
flags:content[offset++]};


// check tga if it is valid format

tgaCheckHeader(header);

if(header.id_length+offset>buffer.length){

console.error('THREE.TGALoader: No data.');

}

// skip the needn't data

offset+=header.id_length;

// get targa information about RLE compression and palette

var use_rle=false,
use_pal=false,
use_grey=false;

switch(header.image_type){

case TGA_TYPE_RLE_INDEXED:
use_rle=true;
use_pal=true;
break;

case TGA_TYPE_INDEXED:
use_pal=true;
break;

case TGA_TYPE_RLE_RGB:
use_rle=true;
break;

case TGA_TYPE_RGB:
break;

case TGA_TYPE_RLE_GREY:
use_rle=true;
use_grey=true;
break;

case TGA_TYPE_GREY:
use_grey=true;
break;}



//

var useOffscreen=typeof OffscreenCanvas!=='undefined';

var canvas=useOffscreen?new OffscreenCanvas(header.width,header.height):document.createElement('canvas');
canvas.width=header.width;
canvas.height=header.height;

var context=canvas.getContext('2d');
var imageData=context.createImageData(header.width,header.height);

var result=tgaParse(use_rle,use_pal,header,offset,content);
var rgbaData=getTgaRGBA(imageData.data,header.width,header.height,result.pixel_data,result.palettes);

context.putImageData(imageData,0,0);

return useOffscreen?canvas.transferToImageBitmap():canvas;

},

setPath:function setPath(value){

this.path=value;
return this;

}};





// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/ColladaLoader.js
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */




var ColladaLoader=function ColladaLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;

};

ColladaLoader.prototype={

constructor:ColladaLoader,

crossOrigin:'anonymous',

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var path=scope.path===undefined?LoaderUtils.extractUrlBase(url):scope.path;

var loader=new FileLoader(scope.manager);
loader.setPath(scope.path);
loader.load(url,function(text){

onLoad(scope.parse(text,path));

},onProgress,onError);

},

setPath:function setPath(value){

this.path=value;
return this;

},

setResourcePath:function setResourcePath(value){

this.resourcePath=value;
return this;

},

options:{

set convertUpAxis(value){

console.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');

}},



setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

parse:function parse(text,path){

function getElementsByTagName(xml,name){

// Non recursive xml.getElementsByTagName() ...

var array=[];
var childNodes=xml.childNodes;

for(var i=0,l=childNodes.length;i<l;i++){

var child=childNodes[i];

if(child.nodeName===name){

array.push(child);

}

}

return array;

}

function parseStrings(text){

if(text.length===0)return[];

var parts=text.trim().split(/\s+/);
var array=new Array(parts.length);

for(var i=0,l=parts.length;i<l;i++){

array[i]=parts[i];

}

return array;

}

function parseFloats(text){

if(text.length===0)return[];

var parts=text.trim().split(/\s+/);
var array=new Array(parts.length);

for(var i=0,l=parts.length;i<l;i++){

array[i]=parseFloat(parts[i]);

}

return array;

}

function parseInts(text){

if(text.length===0)return[];

var parts=text.trim().split(/\s+/);
var array=new Array(parts.length);

for(var i=0,l=parts.length;i<l;i++){

array[i]=parseInt(parts[i]);

}

return array;

}

function parseId(text){

return text.substring(1);

}

function generateId(){

return'three_default_'+count++;

}

function isEmpty(object){

return Object.keys(object).length===0;

}

// asset

function parseAsset(xml){

return{
unit:parseAssetUnit(getElementsByTagName(xml,'unit')[0]),
upAxis:parseAssetUpAxis(getElementsByTagName(xml,'up_axis')[0])};


}

function parseAssetUnit(xml){

if(xml!==undefined&&xml.hasAttribute('meter')===true){

return parseFloat(xml.getAttribute('meter'));

}else{

return 1;// default 1 meter

}

}

function parseAssetUpAxis(xml){

return xml!==undefined?xml.textContent:'Y_UP';

}

// library

function parseLibrary(xml,libraryName,nodeName,parser){

var library=getElementsByTagName(xml,libraryName)[0];

if(library!==undefined){

var elements=getElementsByTagName(library,nodeName);

for(var i=0;i<elements.length;i++){

parser(elements[i]);

}

}

}

function buildLibrary(data,builder){

for(var name in data){

var object=data[name];
object.build=builder(data[name]);

}

}

// get

function getBuild(data,builder){

if(data.build!==undefined)return data.build;

data.build=builder(data);

return data.build;

}

// animation

function parseAnimation(xml){

var data={
sources:{},
samplers:{},
channels:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

var id;

switch(child.nodeName){

case'source':
id=child.getAttribute('id');
data.sources[id]=parseSource(child);
break;

case'sampler':
id=child.getAttribute('id');
data.samplers[id]=parseAnimationSampler(child);
break;

case'channel':
id=child.getAttribute('target');
data.channels[id]=parseAnimationChannel(child);
break;

default:
console.log(child);}



}

library.animations[xml.getAttribute('id')]=data;

}

function parseAnimationSampler(xml){

var data={
inputs:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'input':
var id=parseId(child.getAttribute('source'));
var semantic=child.getAttribute('semantic');
data.inputs[semantic]=id;
break;}



}

return data;

}

function parseAnimationChannel(xml){

var data={};

var target=xml.getAttribute('target');

// parsing SID Addressing Syntax

var parts=target.split('/');

var id=parts.shift();
var sid=parts.shift();

// check selection syntax

var arraySyntax=sid.indexOf('(')!==-1;
var memberSyntax=sid.indexOf('.')!==-1;

if(memberSyntax){

//  member selection access

parts=sid.split('.');
sid=parts.shift();
data.member=parts.shift();

}else if(arraySyntax){

// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.

var indices=sid.split('(');
sid=indices.shift();

for(var i=0;i<indices.length;i++){

indices[i]=parseInt(indices[i].replace(/\)/,''));

}

data.indices=indices;

}

data.id=id;
data.sid=sid;

data.arraySyntax=arraySyntax;
data.memberSyntax=memberSyntax;

data.sampler=parseId(xml.getAttribute('source'));

return data;

}

function buildAnimation(data){

var tracks=[];

var channels=data.channels;
var samplers=data.samplers;
var sources=data.sources;

for(var target in channels){

if(channels.hasOwnProperty(target)){

var channel=channels[target];
var sampler=samplers[channel.sampler];

var inputId=sampler.inputs.INPUT;
var outputId=sampler.inputs.OUTPUT;

var inputSource=sources[inputId];
var outputSource=sources[outputId];

var animation=buildAnimationChannel(channel,inputSource,outputSource);

createKeyframeTracks(animation,tracks);

}

}

return tracks;

}

function getAnimation(id){

return getBuild(library.animations[id],buildAnimation);

}

function buildAnimationChannel(channel,inputSource,outputSource){

var node=library.nodes[channel.id];
var object3D=getNode(node.id);

var transform=node.transforms[channel.sid];
var defaultMatrix=node.matrix.clone().transpose();

var time,stride;
var i,il,j,jl;

var data={};

// the collada spec allows the animation of data in various ways.
// depending on the transform type (matrix, translate, rotate, scale), we execute different logic

switch(transform){

case'matrix':

for(i=0,il=inputSource.array.length;i<il;i++){

time=inputSource.array[i];
stride=i*outputSource.stride;

if(data[time]===undefined)data[time]={};

if(channel.arraySyntax===true){

var value=outputSource.array[stride];
var index=channel.indices[0]+4*channel.indices[1];

data[time][index]=value;

}else{

for(j=0,jl=outputSource.stride;j<jl;j++){

data[time][j]=outputSource.array[stride+j];

}

}

}

break;

case'translate':
console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',transform);
break;

case'rotate':
console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',transform);
break;

case'scale':
console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',transform);
break;}



var keyframes=prepareAnimationData(data,defaultMatrix);

var animation={
name:object3D.uuid,
keyframes:keyframes};


return animation;

}

function prepareAnimationData(data,defaultMatrix){

var keyframes=[];

// transfer data into a sortable array

for(var time in data){

keyframes.push({time:parseFloat(time),value:data[time]});

}

// ensure keyframes are sorted by time

keyframes.sort(ascending);

// now we clean up all animation data, so we can use them for keyframe tracks

for(var i=0;i<16;i++){

transformAnimationData(keyframes,i,defaultMatrix.elements[i]);

}

return keyframes;

// array sort function

function ascending(a,b){

return a.time-b.time;

}

}

var position=new Vector3();
var scale=new Vector3();
var quaternion=new Quaternion();

function createKeyframeTracks(animation,tracks){

var keyframes=animation.keyframes;
var name=animation.name;

var times=[];
var positionData=[];
var quaternionData=[];
var scaleData=[];

for(var i=0,l=keyframes.length;i<l;i++){

var keyframe=keyframes[i];

var time=keyframe.time;
var value=keyframe.value;

matrix.fromArray(value).transpose();
matrix.decompose(position,quaternion,scale);

times.push(time);
positionData.push(position.x,position.y,position.z);
quaternionData.push(quaternion.x,quaternion.y,quaternion.z,quaternion.w);
scaleData.push(scale.x,scale.y,scale.z);

}

if(positionData.length>0)tracks.push(new VectorKeyframeTrack(name+'.position',times,positionData));
if(quaternionData.length>0)tracks.push(new QuaternionKeyframeTrack(name+'.quaternion',times,quaternionData));
if(scaleData.length>0)tracks.push(new VectorKeyframeTrack(name+'.scale',times,scaleData));

return tracks;

}

function transformAnimationData(keyframes,property,defaultValue){

var keyframe;

var empty=true;
var i,l;

// check, if values of a property are missing in our keyframes

for(i=0,l=keyframes.length;i<l;i++){

keyframe=keyframes[i];

if(keyframe.value[property]===undefined){

keyframe.value[property]=null;// mark as missing

}else{

empty=false;

}

}

if(empty===true){

// no values at all, so we set a default value

for(i=0,l=keyframes.length;i<l;i++){

keyframe=keyframes[i];

keyframe.value[property]=defaultValue;

}

}else{

// filling gaps

createMissingKeyframes(keyframes,property);

}

}

function createMissingKeyframes(keyframes,property){

var prev,next;

for(var i=0,l=keyframes.length;i<l;i++){

var keyframe=keyframes[i];

if(keyframe.value[property]===null){

prev=getPrev(keyframes,i,property);
next=getNext(keyframes,i,property);

if(prev===null){

keyframe.value[property]=next.value[property];
continue;

}

if(next===null){

keyframe.value[property]=prev.value[property];
continue;

}

interpolate(keyframe,prev,next,property);

}

}

}

function getPrev(keyframes,i,property){

while(i>=0){

var keyframe=keyframes[i];

if(keyframe.value[property]!==null)return keyframe;

i--;

}

return null;

}

function getNext(keyframes,i,property){

while(i<keyframes.length){

var keyframe=keyframes[i];

if(keyframe.value[property]!==null)return keyframe;

i++;

}

return null;

}

function interpolate(key,prev,next,property){

if(next.time-prev.time===0){

key.value[property]=prev.value[property];
return;

}

key.value[property]=(key.time-prev.time)*(next.value[property]-prev.value[property])/(next.time-prev.time)+prev.value[property];

}

// animation clips

function parseAnimationClip(xml){

var data={
name:xml.getAttribute('id')||'default',
start:parseFloat(xml.getAttribute('start')||0),
end:parseFloat(xml.getAttribute('end')||0),
animations:[]};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'instance_animation':
data.animations.push(parseId(child.getAttribute('url')));
break;}



}

library.clips[xml.getAttribute('id')]=data;

}

function buildAnimationClip(data){

var tracks=[];

var name=data.name;
var duration=data.end-data.start||-1;
var animations=data.animations;

for(var i=0,il=animations.length;i<il;i++){

var animationTracks=getAnimation(animations[i]);

for(var j=0,jl=animationTracks.length;j<jl;j++){

tracks.push(animationTracks[j]);

}

}

return new AnimationClip(name,duration,tracks);

}

function getAnimationClip(id){

return getBuild(library.clips[id],buildAnimationClip);

}

// controller

function parseController(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'skin':
// there is exactly one skin per controller
data.id=parseId(child.getAttribute('source'));
data.skin=parseSkin(child);
break;

case'morph':
data.id=parseId(child.getAttribute('source'));
console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');
break;}



}

library.controllers[xml.getAttribute('id')]=data;

}

function parseSkin(xml){

var data={
sources:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'bind_shape_matrix':
data.bindShapeMatrix=parseFloats(child.textContent);
break;

case'source':
var id=child.getAttribute('id');
data.sources[id]=parseSource(child);
break;

case'joints':
data.joints=parseJoints(child);
break;

case'vertex_weights':
data.vertexWeights=parseVertexWeights(child);
break;}



}

return data;

}

function parseJoints(xml){

var data={
inputs:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'input':
var semantic=child.getAttribute('semantic');
var id=parseId(child.getAttribute('source'));
data.inputs[semantic]=id;
break;}



}

return data;

}

function parseVertexWeights(xml){

var data={
inputs:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'input':
var semantic=child.getAttribute('semantic');
var id=parseId(child.getAttribute('source'));
var offset=parseInt(child.getAttribute('offset'));
data.inputs[semantic]={id:id,offset:offset};
break;

case'vcount':
data.vcount=parseInts(child.textContent);
break;

case'v':
data.v=parseInts(child.textContent);
break;}



}

return data;

}

function buildController(data){

var build={
id:data.id};


var geometry=library.geometries[build.id];

if(data.skin!==undefined){

build.skin=buildSkin(data.skin);

// we enhance the 'sources' property of the corresponding geometry with our skin data

geometry.sources.skinIndices=build.skin.indices;
geometry.sources.skinWeights=build.skin.weights;

}

return build;

}

function buildSkin(data){

var BONE_LIMIT=4;

var build={
joints:[],// this must be an array to preserve the joint order
indices:{
array:[],
stride:BONE_LIMIT},

weights:{
array:[],
stride:BONE_LIMIT}};



var sources=data.sources;
var vertexWeights=data.vertexWeights;

var vcount=vertexWeights.vcount;
var v=vertexWeights.v;
var jointOffset=vertexWeights.inputs.JOINT.offset;
var weightOffset=vertexWeights.inputs.WEIGHT.offset;

var jointSource=data.sources[data.joints.inputs.JOINT];
var inverseSource=data.sources[data.joints.inputs.INV_BIND_MATRIX];

var weights=sources[vertexWeights.inputs.WEIGHT.id].array;
var stride=0;

var i,j,l;

// procces skin data for each vertex

for(i=0,l=vcount.length;i<l;i++){

var jointCount=vcount[i];// this is the amount of joints that affect a single vertex
var vertexSkinData=[];

for(j=0;j<jointCount;j++){

var skinIndex=v[stride+jointOffset];
var weightId=v[stride+weightOffset];
var skinWeight=weights[weightId];

vertexSkinData.push({index:skinIndex,weight:skinWeight});

stride+=2;

}

// we sort the joints in descending order based on the weights.
// this ensures, we only procced the most important joints of the vertex

vertexSkinData.sort(descending);

// now we provide for each vertex a set of four index and weight values.
// the order of the skin data matches the order of vertices

for(j=0;j<BONE_LIMIT;j++){

var d=vertexSkinData[j];

if(d!==undefined){

build.indices.array.push(d.index);
build.weights.array.push(d.weight);

}else{

build.indices.array.push(0);
build.weights.array.push(0);

}

}

}

// setup bind matrix

if(data.bindShapeMatrix){

build.bindMatrix=new Matrix4().fromArray(data.bindShapeMatrix).transpose();

}else{

build.bindMatrix=new Matrix4().identity();

}

// process bones and inverse bind matrix data

for(i=0,l=jointSource.array.length;i<l;i++){

var name=jointSource.array[i];
var boneInverse=new Matrix4().fromArray(inverseSource.array,i*inverseSource.stride).transpose();

build.joints.push({name:name,boneInverse:boneInverse});

}

return build;

// array sort function

function descending(a,b){

return b.weight-a.weight;

}

}

function getController(id){

return getBuild(library.controllers[id],buildController);

}

// image

function parseImage(xml){

var data={
init_from:getElementsByTagName(xml,'init_from')[0].textContent};


library.images[xml.getAttribute('id')]=data;

}

function buildImage(data){

if(data.build!==undefined)return data.build;

return data.init_from;

}

function getImage(id){

var data=library.images[id];

if(data!==undefined){

return getBuild(data,buildImage);

}

console.warn('THREE.ColladaLoader: Couldn\'t find image with ID:',id);

return null;

}

// effect

function parseEffect(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'profile_COMMON':
data.profile=parseEffectProfileCOMMON(child);
break;}



}

library.effects[xml.getAttribute('id')]=data;

}

function parseEffectProfileCOMMON(xml){

var data={
surfaces:{},
samplers:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'newparam':
parseEffectNewparam(child,data);
break;

case'technique':
data.technique=parseEffectTechnique(child);
break;

case'extra':
data.extra=parseEffectExtra(child);
break;}



}

return data;

}

function parseEffectNewparam(xml,data){

var sid=xml.getAttribute('sid');

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'surface':
data.surfaces[sid]=parseEffectSurface(child);
break;

case'sampler2D':
data.samplers[sid]=parseEffectSampler(child);
break;}



}

}

function parseEffectSurface(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'init_from':
data.init_from=child.textContent;
break;}



}

return data;

}

function parseEffectSampler(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'source':
data.source=child.textContent;
break;}



}

return data;

}

function parseEffectTechnique(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'constant':
case'lambert':
case'blinn':
case'phong':
data.type=child.nodeName;
data.parameters=parseEffectParameters(child);
break;}



}

return data;

}

function parseEffectParameters(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'emission':
case'diffuse':
case'specular':
case'bump':
case'ambient':
case'shininess':
case'transparency':
data[child.nodeName]=parseEffectParameter(child);
break;
case'transparent':
data[child.nodeName]={
opaque:child.getAttribute('opaque'),
data:parseEffectParameter(child)};

break;}



}

return data;

}

function parseEffectParameter(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'color':
data[child.nodeName]=parseFloats(child.textContent);
break;

case'float':
data[child.nodeName]=parseFloat(child.textContent);
break;

case'texture':
data[child.nodeName]={id:child.getAttribute('texture'),extra:parseEffectParameterTexture(child)};
break;}



}

return data;

}

function parseEffectParameterTexture(xml){

var data={
technique:{}};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'extra':
parseEffectParameterTextureExtra(child,data);
break;}



}

return data;

}

function parseEffectParameterTextureExtra(xml,data){

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'technique':
parseEffectParameterTextureExtraTechnique(child,data);
break;}



}

}

function parseEffectParameterTextureExtraTechnique(xml,data){

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'repeatU':
case'repeatV':
case'offsetU':
case'offsetV':
data.technique[child.nodeName]=parseFloat(child.textContent);
break;

case'wrapU':
case'wrapV':

// some files have values for wrapU/wrapV which become NaN via parseInt

if(child.textContent.toUpperCase()==='TRUE'){

data.technique[child.nodeName]=1;

}else if(child.textContent.toUpperCase()==='FALSE'){

data.technique[child.nodeName]=0;

}else{

data.technique[child.nodeName]=parseInt(child.textContent);

}

break;}



}

}

function parseEffectExtra(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'technique':
data.technique=parseEffectExtraTechnique(child);
break;}



}

return data;

}

function parseEffectExtraTechnique(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'double_sided':
data[child.nodeName]=parseInt(child.textContent);
break;}



}

return data;

}

function buildEffect(data){

return data;

}

function getEffect(id){

return getBuild(library.effects[id],buildEffect);

}

// material

function parseMaterial(xml){

var data={
name:xml.getAttribute('name')};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'instance_effect':
data.url=parseId(child.getAttribute('url'));
break;}



}

library.materials[xml.getAttribute('id')]=data;

}

function getTextureLoader(image){

var loader;

var extension=image.slice((image.lastIndexOf('.')-1>>>0)+2);// http://www.jstips.co/en/javascript/get-file-extension/
extension=extension.toLowerCase();

switch(extension){

case'tga':
loader=tgaLoader;
break;

default:
loader=textureLoader;}



return loader;

}

function buildMaterial(data){

var effect=getEffect(data.url);
var technique=effect.profile.technique;
var extra=effect.profile.extra;

var material;

switch(technique.type){

case'phong':
case'blinn':
material=new MeshPhongMaterial();
break;

case'lambert':
material=new MeshLambertMaterial();
break;

default:
material=new MeshBasicMaterial();
break;}



material.name=data.name||'';

function getTexture(textureObject){

var sampler=effect.profile.samplers[textureObject.id];
var image=null;

// get image

if(sampler!==undefined){

var surface=effect.profile.surfaces[sampler.source];
image=getImage(surface.init_from);

}else{

console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');
image=getImage(textureObject.id);

}

// create texture if image is avaiable

if(image!==null){

var loader=getTextureLoader(image);

if(loader!==undefined){

var texture=loader.load(image);

var extra=textureObject.extra;

if(extra!==undefined&&extra.technique!==undefined&&isEmpty(extra.technique)===false){

var technique=extra.technique;

texture.wrapS=technique.wrapU?RepeatWrapping:ClampToEdgeWrapping;
texture.wrapT=technique.wrapV?RepeatWrapping:ClampToEdgeWrapping;

texture.offset.set(technique.offsetU||0,technique.offsetV||0);
texture.repeat.set(technique.repeatU||1,technique.repeatV||1);

}else{

texture.wrapS=RepeatWrapping;
texture.wrapT=RepeatWrapping;

}

return texture;

}else{

console.warn('THREE.ColladaLoader: Loader for texture %s not found.',image);

return null;

}

}else{

console.warn('THREE.ColladaLoader: Couldn\'t create texture with ID:',textureObject.id);

return null;

}

}

var parameters=technique.parameters;

for(var key in parameters){

var parameter=parameters[key];

switch(key){

case'diffuse':
if(parameter.color)material.color.fromArray(parameter.color);
if(parameter.texture)material.map=getTexture(parameter.texture);
break;
case'specular':
if(parameter.color&&material.specular)material.specular.fromArray(parameter.color);
if(parameter.texture)material.specularMap=getTexture(parameter.texture);
break;
case'bump':
if(parameter.texture)material.normalMap=getTexture(parameter.texture);
break;
case'ambient':
if(parameter.texture)material.lightMap=getTexture(parameter.texture);
break;
case'shininess':
if(parameter.float&&material.shininess)material.shininess=parameter.float;
break;
case'emission':
if(parameter.color&&material.emissive)material.emissive.fromArray(parameter.color);
if(parameter.texture)material.emissiveMap=getTexture(parameter.texture);
break;}



}

//

var transparent=parameters['transparent'];
var transparency=parameters['transparency'];

// <transparency> does not exist but <transparent>

if(transparency===undefined&&transparent){

transparency={
float:1};


}

// <transparent> does not exist but <transparency>

if(transparent===undefined&&transparency){

transparent={
opaque:'A_ONE',
data:{
color:[1,1,1,1]}};


}

if(transparent&&transparency){

// handle case if a texture exists but no color

if(transparent.data.texture){

// we do not set an alpha map (see #13792)

material.transparent=true;

}else{

var color=transparent.data.color;

switch(transparent.opaque){

case'A_ONE':
material.opacity=color[3]*transparency.float;
break;
case'RGB_ZERO':
material.opacity=1-color[0]*transparency.float;
break;
case'A_ZERO':
material.opacity=1-color[3]*transparency.float;
break;
case'RGB_ONE':
material.opacity=color[0]*transparency.float;
break;
default:
console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',transparent.opaque);}



if(material.opacity<1)material.transparent=true;

}

}

//

if(extra!==undefined&&extra.technique!==undefined&&extra.technique.double_sided===1){

material.side=DoubleSide;

}

return material;

}

function getMaterial(id){

return getBuild(library.materials[id],buildMaterial);

}

// camera

function parseCamera(xml){

var data={
name:xml.getAttribute('name')};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'optics':
data.optics=parseCameraOptics(child);
break;}



}

library.cameras[xml.getAttribute('id')]=data;

}

function parseCameraOptics(xml){

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

switch(child.nodeName){

case'technique_common':
return parseCameraTechnique(child);}



}

return{};

}

function parseCameraTechnique(xml){

var data={};

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

switch(child.nodeName){

case'perspective':
case'orthographic':

data.technique=child.nodeName;
data.parameters=parseCameraParameters(child);

break;}



}

return data;

}

function parseCameraParameters(xml){

var data={};

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

switch(child.nodeName){

case'xfov':
case'yfov':
case'xmag':
case'ymag':
case'znear':
case'zfar':
case'aspect_ratio':
data[child.nodeName]=parseFloat(child.textContent);
break;}



}

return data;

}

function buildCamera(data){

var camera;

switch(data.optics.technique){

case'perspective':
camera=new PerspectiveCamera(
data.optics.parameters.yfov,
data.optics.parameters.aspect_ratio,
data.optics.parameters.znear,
data.optics.parameters.zfar);

break;

case'orthographic':
var ymag=data.optics.parameters.ymag;
var xmag=data.optics.parameters.xmag;
var aspectRatio=data.optics.parameters.aspect_ratio;

xmag=xmag===undefined?ymag*aspectRatio:xmag;
ymag=ymag===undefined?xmag/aspectRatio:ymag;

xmag*=0.5;
ymag*=0.5;

camera=new OrthographicCamera(
-xmag,xmag,ymag,-ymag,// left, right, top, bottom
data.optics.parameters.znear,
data.optics.parameters.zfar);

break;

default:
camera=new PerspectiveCamera();
break;}



camera.name=data.name||'';

return camera;

}

function getCamera(id){

var data=library.cameras[id];

if(data!==undefined){

return getBuild(data,buildCamera);

}

console.warn('THREE.ColladaLoader: Couldn\'t find camera with ID:',id);

return null;

}

// light

function parseLight(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'technique_common':
data=parseLightTechnique(child);
break;}



}

library.lights[xml.getAttribute('id')]=data;

}

function parseLightTechnique(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'directional':
case'point':
case'spot':
case'ambient':

data.technique=child.nodeName;
data.parameters=parseLightParameters(child);}



}

return data;

}

function parseLightParameters(xml){

var data={};

for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'color':
var array=parseFloats(child.textContent);
data.color=new Color().fromArray(array);
break;

case'falloff_angle':
data.falloffAngle=parseFloat(child.textContent);
break;

case'quadratic_attenuation':
var f=parseFloat(child.textContent);
data.distance=f?Math.sqrt(1/f):0;
break;}



}

return data;

}

function buildLight(data){

var light;

switch(data.technique){

case'directional':
light=new DirectionalLight();
break;

case'point':
light=new PointLight();
break;

case'spot':
light=new SpotLight();
break;

case'ambient':
light=new AmbientLight();
break;}



if(data.parameters.color)light.color.copy(data.parameters.color);
if(data.parameters.distance)light.distance=data.parameters.distance;

return light;

}

function getLight(id){

var data=library.lights[id];

if(data!==undefined){

return getBuild(data,buildLight);

}

console.warn('THREE.ColladaLoader: Couldn\'t find light with ID:',id);

return null;

}

// geometry

function parseGeometry(xml){

var data={
name:xml.getAttribute('name'),
sources:{},
vertices:{},
primitives:[]};


var mesh=getElementsByTagName(xml,'mesh')[0];

// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep
if(mesh===undefined)return;

for(var i=0;i<mesh.childNodes.length;i++){

var child=mesh.childNodes[i];

if(child.nodeType!==1)continue;

var id=child.getAttribute('id');

switch(child.nodeName){

case'source':
data.sources[id]=parseSource(child);
break;

case'vertices':
// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];
data.vertices=parseGeometryVertices(child);
break;

case'polygons':
console.warn('THREE.ColladaLoader: Unsupported primitive type: ',child.nodeName);
break;

case'lines':
case'linestrips':
case'polylist':
case'triangles':
data.primitives.push(parseGeometryPrimitive(child));
break;

default:
console.log(child);}



}

library.geometries[xml.getAttribute('id')]=data;

}

function parseSource(xml){

var data={
array:[],
stride:3};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'float_array':
data.array=parseFloats(child.textContent);
break;

case'Name_array':
data.array=parseStrings(child.textContent);
break;

case'technique_common':
var accessor=getElementsByTagName(child,'accessor')[0];

if(accessor!==undefined){

data.stride=parseInt(accessor.getAttribute('stride'));

}
break;}



}

return data;

}

function parseGeometryVertices(xml){

var data={};

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

data[child.getAttribute('semantic')]=parseId(child.getAttribute('source'));

}

return data;

}

function parseGeometryPrimitive(xml){

var primitive={
type:xml.nodeName,
material:xml.getAttribute('material'),
count:parseInt(xml.getAttribute('count')),
inputs:{},
stride:0,
hasUV:false};


for(var i=0,l=xml.childNodes.length;i<l;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'input':
var id=parseId(child.getAttribute('source'));
var semantic=child.getAttribute('semantic');
var offset=parseInt(child.getAttribute('offset'));
var set=parseInt(child.getAttribute('set'));
var inputname=set>0?semantic+set:semantic;
primitive.inputs[inputname]={id:id,offset:offset};
primitive.stride=Math.max(primitive.stride,offset+1);
if(semantic==='TEXCOORD')primitive.hasUV=true;
break;

case'vcount':
primitive.vcount=parseInts(child.textContent);
break;

case'p':
primitive.p=parseInts(child.textContent);
break;}



}

return primitive;

}

function groupPrimitives(primitives){

var build={};

for(var i=0;i<primitives.length;i++){

var primitive=primitives[i];

if(build[primitive.type]===undefined)build[primitive.type]=[];

build[primitive.type].push(primitive);

}

return build;

}

function checkUVCoordinates(primitives){

var count=0;

for(var i=0,l=primitives.length;i<l;i++){

var primitive=primitives[i];

if(primitive.hasUV===true){

count++;

}

}

if(count>0&&count<primitives.length){

primitives.uvsNeedsFix=true;

}

}

function buildGeometry(data){

var build={};

var sources=data.sources;
var vertices=data.vertices;
var primitives=data.primitives;

if(primitives.length===0)return{};

// our goal is to create one buffer geometry for a single type of primitives
// first, we group all primitives by their type

var groupedPrimitives=groupPrimitives(primitives);

for(var type in groupedPrimitives){

var primitiveType=groupedPrimitives[type];

// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)

checkUVCoordinates(primitiveType);

// third, create a buffer geometry for each type of primitives

build[type]=buildGeometryType(primitiveType,sources,vertices);

}

return build;

}

function buildGeometryType(primitives,sources,vertices){

var build={};

var position={array:[],stride:0};
var normal={array:[],stride:0};
var uv={array:[],stride:0};
var uv2={array:[],stride:0};
var color={array:[],stride:0};

var skinIndex={array:[],stride:4};
var skinWeight={array:[],stride:4};

var geometry=new BufferGeometry();

var materialKeys=[];

var start=0;

for(var p=0;p<primitives.length;p++){

var primitive=primitives[p];
var inputs=primitive.inputs;

// groups

var count=0;

switch(primitive.type){

case'lines':
case'linestrips':
count=primitive.count*2;
break;

case'triangles':
count=primitive.count*3;
break;

case'polylist':

for(var g=0;g<primitive.count;g++){

var vc=primitive.vcount[g];

switch(vc){

case 3:
count+=3;// single triangle
break;

case 4:
count+=6;// quad, subdivided into two triangles
break;

default:
count+=(vc-2)*3;// polylist with more than four vertices
break;}



}

break;

default:
console.warn('THREE.ColladaLoader: Unknow primitive type:',primitive.type);}



geometry.addGroup(start,count,p);
start+=count;

// material

if(primitive.material){

materialKeys.push(primitive.material);

}

// geometry data

for(var name in inputs){

var input=inputs[name];

switch(name){

case'VERTEX':
for(var key in vertices){

var id=vertices[key];

switch(key){

case'POSITION':
var prevLength=position.array.length;
buildGeometryData(primitive,sources[id],input.offset,position.array);
position.stride=sources[id].stride;

if(sources.skinWeights&&sources.skinIndices){

buildGeometryData(primitive,sources.skinIndices,input.offset,skinIndex.array);
buildGeometryData(primitive,sources.skinWeights,input.offset,skinWeight.array);

}

// see #3803

if(primitive.hasUV===false&&primitives.uvsNeedsFix===true){

var count=(position.array.length-prevLength)/position.stride;

for(var i=0;i<count;i++){

// fill missing uv coordinates

uv.array.push(0,0);

}

}
break;

case'NORMAL':
buildGeometryData(primitive,sources[id],input.offset,normal.array);
normal.stride=sources[id].stride;
break;

case'COLOR':
buildGeometryData(primitive,sources[id],input.offset,color.array);
color.stride=sources[id].stride;
break;

case'TEXCOORD':
buildGeometryData(primitive,sources[id],input.offset,uv.array);
uv.stride=sources[id].stride;
break;

case'TEXCOORD1':
buildGeometryData(primitive,sources[id],input.offset,uv2.array);
uv.stride=sources[id].stride;
break;

default:
console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',key);}



}
break;

case'NORMAL':
buildGeometryData(primitive,sources[input.id],input.offset,normal.array);
normal.stride=sources[input.id].stride;
break;

case'COLOR':
buildGeometryData(primitive,sources[input.id],input.offset,color.array);
color.stride=sources[input.id].stride;
break;

case'TEXCOORD':
buildGeometryData(primitive,sources[input.id],input.offset,uv.array);
uv.stride=sources[input.id].stride;
break;

case'TEXCOORD1':
buildGeometryData(primitive,sources[input.id],input.offset,uv2.array);
uv2.stride=sources[input.id].stride;
break;}



}

}

// build geometry

if(position.array.length>0)geometry.addAttribute('position',new Float32BufferAttribute(position.array,position.stride));
if(normal.array.length>0)geometry.addAttribute('normal',new Float32BufferAttribute(normal.array,normal.stride));
if(color.array.length>0)geometry.addAttribute('color',new Float32BufferAttribute(color.array,color.stride));
if(uv.array.length>0)geometry.addAttribute('uv',new Float32BufferAttribute(uv.array,uv.stride));
if(uv2.array.length>0)geometry.addAttribute('uv2',new Float32BufferAttribute(uv2.array,uv2.stride));

if(skinIndex.array.length>0)geometry.addAttribute('skinIndex',new Float32BufferAttribute(skinIndex.array,skinIndex.stride));
if(skinWeight.array.length>0)geometry.addAttribute('skinWeight',new Float32BufferAttribute(skinWeight.array,skinWeight.stride));

build.data=geometry;
build.type=primitives[0].type;
build.materialKeys=materialKeys;

return build;

}

function buildGeometryData(primitive,source,offset,array){

var indices=primitive.p;
var stride=primitive.stride;
var vcount=primitive.vcount;

function pushVector(i){

var index=indices[i+offset]*sourceStride;
var length=index+sourceStride;

for(;index<length;index++){

array.push(sourceArray[index]);

}

}

var sourceArray=source.array;
var sourceStride=source.stride;

if(primitive.vcount!==undefined){

var index=0;

for(var i=0,l=vcount.length;i<l;i++){

var count=vcount[i];

if(count===4){

var a=index+stride*0;
var b=index+stride*1;
var c=index+stride*2;
var d=index+stride*3;

pushVector(a);pushVector(b);pushVector(d);
pushVector(b);pushVector(c);pushVector(d);

}else if(count===3){

var a=index+stride*0;
var b=index+stride*1;
var c=index+stride*2;

pushVector(a);pushVector(b);pushVector(c);

}else if(count>4){

for(var k=1,kl=count-2;k<=kl;k++){

var a=index+stride*0;
var b=index+stride*k;
var c=index+stride*(k+1);

pushVector(a);pushVector(b);pushVector(c);

}

}

index+=stride*count;

}

}else{

for(var i=0,l=indices.length;i<l;i+=stride){

pushVector(i);

}

}

}

function getGeometry(id){

return getBuild(library.geometries[id],buildGeometry);

}

// kinematics

function parseKinematicsModel(xml){

var data={
name:xml.getAttribute('name')||'',
joints:{},
links:[]};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'technique_common':
parseKinematicsTechniqueCommon(child,data);
break;}



}

library.kinematicsModels[xml.getAttribute('id')]=data;

}

function buildKinematicsModel(data){

if(data.build!==undefined)return data.build;

return data;

}

function getKinematicsModel(id){

return getBuild(library.kinematicsModels[id],buildKinematicsModel);

}

function parseKinematicsTechniqueCommon(xml,data){

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'joint':
data.joints[child.getAttribute('sid')]=parseKinematicsJoint(child);
break;

case'link':
data.links.push(parseKinematicsLink(child));
break;}



}

}

function parseKinematicsJoint(xml){

var data;

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'prismatic':
case'revolute':
data=parseKinematicsJointParameter(child);
break;}



}

return data;

}

function parseKinematicsJointParameter(xml,data){

var data={
sid:xml.getAttribute('sid'),
name:xml.getAttribute('name')||'',
axis:new Vector3(),
limits:{
min:0,
max:0},

type:xml.nodeName,
static:false,
zeroPosition:0,
middlePosition:0};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'axis':
var array=parseFloats(child.textContent);
data.axis.fromArray(array);
break;
case'limits':
var max=child.getElementsByTagName('max')[0];
var min=child.getElementsByTagName('min')[0];

data.limits.max=parseFloat(max.textContent);
data.limits.min=parseFloat(min.textContent);
break;}



}

// if min is equal to or greater than max, consider the joint static

if(data.limits.min>=data.limits.max){

data.static=true;

}

// calculate middle position

data.middlePosition=(data.limits.min+data.limits.max)/2.0;

return data;

}

function parseKinematicsLink(xml){

var data={
sid:xml.getAttribute('sid'),
name:xml.getAttribute('name')||'',
attachments:[],
transforms:[]};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'attachment_full':
data.attachments.push(parseKinematicsAttachment(child));
break;

case'matrix':
case'translate':
case'rotate':
data.transforms.push(parseKinematicsTransform(child));
break;}



}

return data;

}

function parseKinematicsAttachment(xml){

var data={
joint:xml.getAttribute('joint').split('/').pop(),
transforms:[],
links:[]};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'link':
data.links.push(parseKinematicsLink(child));
break;

case'matrix':
case'translate':
case'rotate':
data.transforms.push(parseKinematicsTransform(child));
break;}



}

return data;

}

function parseKinematicsTransform(xml){

var data={
type:xml.nodeName};


var array=parseFloats(xml.textContent);

switch(data.type){

case'matrix':
data.obj=new Matrix4();
data.obj.fromArray(array).transpose();
break;

case'translate':
data.obj=new Vector3();
data.obj.fromArray(array);
break;

case'rotate':
data.obj=new Vector3();
data.obj.fromArray(array);
data.angle=_Math.degToRad(array[3]);
break;}



return data;

}

// physics

function parsePhysicsModel(xml){

var data={
name:xml.getAttribute('name')||'',
rigidBodies:{}};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'rigid_body':
data.rigidBodies[child.getAttribute('name')]={};
parsePhysicsRigidBody(child,data.rigidBodies[child.getAttribute('name')]);
break;}



}

library.physicsModels[xml.getAttribute('id')]=data;

}

function parsePhysicsRigidBody(xml,data){

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'technique_common':
parsePhysicsTechniqueCommon(child,data);
break;}



}

}

function parsePhysicsTechniqueCommon(xml,data){

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'inertia':
data.inertia=parseFloats(child.textContent);
break;

case'mass':
data.mass=parseFloats(child.textContent)[0];
break;}



}

}

// scene

function parseKinematicsScene(xml){

var data={
bindJointAxis:[]};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'bind_joint_axis':
data.bindJointAxis.push(parseKinematicsBindJointAxis(child));
break;}



}

library.kinematicsScenes[parseId(xml.getAttribute('url'))]=data;

}

function parseKinematicsBindJointAxis(xml){

var data={
target:xml.getAttribute('target').split('/').pop()};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'axis':
var param=child.getElementsByTagName('param')[0];
data.axis=param.textContent;
var tmpJointIndex=data.axis.split('inst_').pop().split('axis')[0];
data.jointIndex=tmpJointIndex.substr(0,tmpJointIndex.length-1);
break;}



}

return data;

}

function buildKinematicsScene(data){

if(data.build!==undefined)return data.build;

return data;

}

function getKinematicsScene(id){

return getBuild(library.kinematicsScenes[id],buildKinematicsScene);

}

function setupKinematics(){

var kinematicsModelId=Object.keys(library.kinematicsModels)[0];
var kinematicsSceneId=Object.keys(library.kinematicsScenes)[0];
var visualSceneId=Object.keys(library.visualScenes)[0];

if(kinematicsModelId===undefined||kinematicsSceneId===undefined)return;

var kinematicsModel=getKinematicsModel(kinematicsModelId);
var kinematicsScene=getKinematicsScene(kinematicsSceneId);
var visualScene=getVisualScene(visualSceneId);

var bindJointAxis=kinematicsScene.bindJointAxis;
var jointMap={};

for(var i=0,l=bindJointAxis.length;i<l;i++){

var axis=bindJointAxis[i];

// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'

var targetElement=collada.querySelector('[sid="'+axis.target+'"]');

if(targetElement){

// get the parent of the transfrom element

var parentVisualElement=targetElement.parentElement;

// connect the joint of the kinematics model with the element in the visual scene

connect(axis.jointIndex,parentVisualElement);

}

}

function connect(jointIndex,visualElement){

var visualElementName=visualElement.getAttribute('name');
var joint=kinematicsModel.joints[jointIndex];

visualScene.traverse(function(object){

if(object.name===visualElementName){

jointMap[jointIndex]={
object:object,
transforms:buildTransformList(visualElement),
joint:joint,
position:joint.zeroPosition};


}

});

}

var m0=new Matrix4();

kinematics={

joints:kinematicsModel&&kinematicsModel.joints,

getJointValue:function getJointValue(jointIndex){

var jointData=jointMap[jointIndex];

if(jointData){

return jointData.position;

}else{

console.warn('THREE.ColladaLoader: Joint '+jointIndex+' doesn\'t exist.');

}

},

setJointValue:function setJointValue(jointIndex,value){

var jointData=jointMap[jointIndex];

if(jointData){

var joint=jointData.joint;

if(value>joint.limits.max||value<joint.limits.min){

console.warn('THREE.ColladaLoader: Joint '+jointIndex+' value '+value+' outside of limits (min: '+joint.limits.min+', max: '+joint.limits.max+').');

}else if(joint.static){

console.warn('THREE.ColladaLoader: Joint '+jointIndex+' is static.');

}else{

var object=jointData.object;
var axis=joint.axis;
var transforms=jointData.transforms;

matrix.identity();

// each update, we have to apply all transforms in the correct order

for(var i=0;i<transforms.length;i++){

var transform=transforms[i];

// if there is a connection of the transform node with a joint, apply the joint value

if(transform.sid&&transform.sid.indexOf(jointIndex)!==-1){

switch(joint.type){

case'revolute':
matrix.multiply(m0.makeRotationAxis(axis,_Math.degToRad(value)));
break;

case'prismatic':
matrix.multiply(m0.makeTranslation(axis.x*value,axis.y*value,axis.z*value));
break;

default:
console.warn('THREE.ColladaLoader: Unknown joint type: '+joint.type);
break;}



}else{

switch(transform.type){

case'matrix':
matrix.multiply(transform.obj);
break;

case'translate':
matrix.multiply(m0.makeTranslation(transform.obj.x,transform.obj.y,transform.obj.z));
break;

case'scale':
matrix.scale(transform.obj);
break;

case'rotate':
matrix.multiply(m0.makeRotationAxis(transform.obj,transform.angle));
break;}



}

}

object.matrix.copy(matrix);
object.matrix.decompose(object.position,object.quaternion,object.scale);

jointMap[jointIndex].position=value;

}

}else{

console.log('THREE.ColladaLoader: '+jointIndex+' does not exist.');

}

}};



}

function buildTransformList(node){

var transforms=[];

var xml=collada.querySelector('[id="'+node.id+'"]');

for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'matrix':
var array=parseFloats(child.textContent);
var matrix=new Matrix4().fromArray(array).transpose();
transforms.push({
sid:child.getAttribute('sid'),
type:child.nodeName,
obj:matrix});

break;

case'translate':
case'scale':
var array=parseFloats(child.textContent);
var vector=new Vector3().fromArray(array);
transforms.push({
sid:child.getAttribute('sid'),
type:child.nodeName,
obj:vector});

break;

case'rotate':
var array=parseFloats(child.textContent);
var vector=new Vector3().fromArray(array);
var angle=_Math.degToRad(array[3]);
transforms.push({
sid:child.getAttribute('sid'),
type:child.nodeName,
obj:vector,
angle:angle});

break;}



}

return transforms;

}

// nodes

function prepareNodes(xml){

var elements=xml.getElementsByTagName('node');

// ensure all node elements have id attributes

for(var i=0;i<elements.length;i++){

var element=elements[i];

if(element.hasAttribute('id')===false){

element.setAttribute('id',generateId());

}

}

}

var matrix=new Matrix4();
var vector=new Vector3();

function parseNode(xml){

var data={
name:xml.getAttribute('name')||'',
type:xml.getAttribute('type'),
id:xml.getAttribute('id'),
sid:xml.getAttribute('sid'),
matrix:new Matrix4(),
nodes:[],
instanceCameras:[],
instanceControllers:[],
instanceLights:[],
instanceGeometries:[],
instanceNodes:[],
transforms:{}};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

if(child.nodeType!==1)continue;

switch(child.nodeName){

case'node':
data.nodes.push(child.getAttribute('id'));
parseNode(child);
break;

case'instance_camera':
data.instanceCameras.push(parseId(child.getAttribute('url')));
break;

case'instance_controller':
data.instanceControllers.push(parseNodeInstance(child));
break;

case'instance_light':
data.instanceLights.push(parseId(child.getAttribute('url')));
break;

case'instance_geometry':
data.instanceGeometries.push(parseNodeInstance(child));
break;

case'instance_node':
data.instanceNodes.push(parseId(child.getAttribute('url')));
break;

case'matrix':
var array=parseFloats(child.textContent);
data.matrix.multiply(matrix.fromArray(array).transpose());
data.transforms[child.getAttribute('sid')]=child.nodeName;
break;

case'translate':
var array=parseFloats(child.textContent);
vector.fromArray(array);
data.matrix.multiply(matrix.makeTranslation(vector.x,vector.y,vector.z));
data.transforms[child.getAttribute('sid')]=child.nodeName;
break;

case'rotate':
var array=parseFloats(child.textContent);
var angle=_Math.degToRad(array[3]);
data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array),angle));
data.transforms[child.getAttribute('sid')]=child.nodeName;
break;

case'scale':
var array=parseFloats(child.textContent);
data.matrix.scale(vector.fromArray(array));
data.transforms[child.getAttribute('sid')]=child.nodeName;
break;

case'extra':
break;

default:
console.log(child);}



}

if(hasNode(data.id)){

console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.',data.id);

}else{

library.nodes[data.id]=data;

}

return data;

}

function parseNodeInstance(xml){

var data={
id:parseId(xml.getAttribute('url')),
materials:{},
skeletons:[]};


for(var i=0;i<xml.childNodes.length;i++){

var child=xml.childNodes[i];

switch(child.nodeName){

case'bind_material':
var instances=child.getElementsByTagName('instance_material');

for(var j=0;j<instances.length;j++){

var instance=instances[j];
var symbol=instance.getAttribute('symbol');
var target=instance.getAttribute('target');

data.materials[symbol]=parseId(target);

}

break;

case'skeleton':
data.skeletons.push(parseId(child.textContent));
break;

default:
break;}



}

return data;

}

function buildSkeleton(skeletons,joints){

var boneData=[];
var sortedBoneData=[];

var i,j,data;

// a skeleton can have multiple root bones. collada expresses this
// situtation with multiple "skeleton" tags per controller instance

for(i=0;i<skeletons.length;i++){

var skeleton=skeletons[i];

var root;

if(hasNode(skeleton)){

root=getNode(skeleton);
buildBoneHierarchy(root,joints,boneData);

}else if(hasVisualScene(skeleton)){

// handle case where the skeleton refers to the visual scene (#13335)

var visualScene=library.visualScenes[skeleton];
var children=visualScene.children;

for(var j=0;j<children.length;j++){

var child=children[j];

if(child.type==='JOINT'){

var root=getNode(child.id);
buildBoneHierarchy(root,joints,boneData);

}

}

}else{

console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:',skeleton);

}

}

// sort bone data (the order is defined in the corresponding controller)

for(i=0;i<joints.length;i++){

for(j=0;j<boneData.length;j++){

data=boneData[j];

if(data.bone.name===joints[i].name){

sortedBoneData[i]=data;
data.processed=true;
break;

}

}

}

// add unprocessed bone data at the end of the list

for(i=0;i<boneData.length;i++){

data=boneData[i];

if(data.processed===false){

sortedBoneData.push(data);
data.processed=true;

}

}

// setup arrays for skeleton creation

var bones=[];
var boneInverses=[];

for(i=0;i<sortedBoneData.length;i++){

data=sortedBoneData[i];

bones.push(data.bone);
boneInverses.push(data.boneInverse);

}

return new Skeleton(bones,boneInverses);

}

function buildBoneHierarchy(root,joints,boneData){

// setup bone data from visual scene

root.traverse(function(object){

if(object.isBone===true){

var boneInverse;

// retrieve the boneInverse from the controller data

for(var i=0;i<joints.length;i++){

var joint=joints[i];

if(joint.name===object.name){

boneInverse=joint.boneInverse;
break;

}

}

if(boneInverse===undefined){

// Unfortunately, there can be joints in the visual scene that are not part of the
// corresponding controller. In this case, we have to create a dummy boneInverse matrix
// for the respective bone. This bone won't affect any vertices, because there are no skin indices
// and weights defined for it. But we still have to add the bone to the sorted bone list in order to
// ensure a correct animation of the model.

boneInverse=new Matrix4();

}

boneData.push({bone:object,boneInverse:boneInverse,processed:false});

}

});

}

function buildNode(data){

var objects=[];

var matrix=data.matrix;
var nodes=data.nodes;
var type=data.type;
var instanceCameras=data.instanceCameras;
var instanceControllers=data.instanceControllers;
var instanceLights=data.instanceLights;
var instanceGeometries=data.instanceGeometries;
var instanceNodes=data.instanceNodes;

// nodes

for(var i=0,l=nodes.length;i<l;i++){

objects.push(getNode(nodes[i]));

}

// instance cameras

for(var i=0,l=instanceCameras.length;i<l;i++){

var instanceCamera=getCamera(instanceCameras[i]);

if(instanceCamera!==null){

objects.push(instanceCamera.clone());

}

}

// instance controllers

for(var i=0,l=instanceControllers.length;i<l;i++){

var instance=instanceControllers[i];
var controller=getController(instance.id);
var geometries=getGeometry(controller.id);
var newObjects=buildObjects(geometries,instance.materials);

var skeletons=instance.skeletons;
var joints=controller.skin.joints;

var skeleton=buildSkeleton(skeletons,joints);

for(var j=0,jl=newObjects.length;j<jl;j++){

var object=newObjects[j];

if(object.isSkinnedMesh){

object.bind(skeleton,controller.skin.bindMatrix);
object.normalizeSkinWeights();

}

objects.push(object);

}

}

// instance lights

for(var i=0,l=instanceLights.length;i<l;i++){

var instanceLight=getLight(instanceLights[i]);

if(instanceLight!==null){

objects.push(instanceLight.clone());

}

}

// instance geometries

for(var i=0,l=instanceGeometries.length;i<l;i++){

var instance=instanceGeometries[i];

// a single geometry instance in collada can lead to multiple object3Ds.
// this is the case when primitives are combined like triangles and lines

var geometries=getGeometry(instance.id);
var newObjects=buildObjects(geometries,instance.materials);

for(var j=0,jl=newObjects.length;j<jl;j++){

objects.push(newObjects[j]);

}

}

// instance nodes

for(var i=0,l=instanceNodes.length;i<l;i++){

objects.push(getNode(instanceNodes[i]).clone());

}

var object;

if(nodes.length===0&&objects.length===1){

object=objects[0];

}else{

object=type==='JOINT'?new Bone():new Group();

for(var i=0;i<objects.length;i++){

object.add(objects[i]);

}

}

if(object.name===''){

object.name=type==='JOINT'?data.sid:data.name;

}

object.matrix.copy(matrix);
object.matrix.decompose(object.position,object.quaternion,object.scale);

return object;

}

var fallbackMaterial=new MeshBasicMaterial({color:0xff00ff});

function resolveMaterialBinding(keys,instanceMaterials){

var materials=[];

for(var i=0,l=keys.length;i<l;i++){

var id=instanceMaterials[keys[i]];

if(id===undefined){

console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.',keys[i]);
materials.push(fallbackMaterial);

}else{

materials.push(getMaterial(id));

}

}

return materials;

}

function buildObjects(geometries,instanceMaterials){

var objects=[];

for(var type in geometries){

var geometry=geometries[type];

var materials=resolveMaterialBinding(geometry.materialKeys,instanceMaterials);

// handle case if no materials are defined

if(materials.length===0){

if(type==='lines'||type==='linestrips'){

materials.push(new LineBasicMaterial());

}else{

materials.push(new MeshPhongMaterial());

}

}

// regard skinning

var skinning=geometry.data.attributes.skinIndex!==undefined;

if(skinning){

for(var i=0,l=materials.length;i<l;i++){

materials[i].skinning=true;

}

}

// choose between a single or multi materials (material array)

var material=materials.length===1?materials[0]:materials;

// now create a specific 3D object

var object;

switch(type){

case'lines':
object=new LineSegments(geometry.data,material);
break;

case'linestrips':
object=new Line(geometry.data,material);
break;

case'triangles':
case'polylist':
if(skinning){

object=new SkinnedMesh(geometry.data,material);

}else{

object=new Mesh(geometry.data,material);

}
break;}



objects.push(object);

}

return objects;

}

function hasNode(id){

return library.nodes[id]!==undefined;

}

function getNode(id){

return getBuild(library.nodes[id],buildNode);

}

// visual scenes

function parseVisualScene(xml){

var data={
name:xml.getAttribute('name'),
children:[]};


prepareNodes(xml);

var elements=getElementsByTagName(xml,'node');

for(var i=0;i<elements.length;i++){

data.children.push(parseNode(elements[i]));

}

library.visualScenes[xml.getAttribute('id')]=data;

}

function buildVisualScene(data){

var group=new Group();
group.name=data.name;

var children=data.children;

for(var i=0;i<children.length;i++){

var child=children[i];

group.add(getNode(child.id));

}

return group;

}

function hasVisualScene(id){

return library.visualScenes[id]!==undefined;

}

function getVisualScene(id){

return getBuild(library.visualScenes[id],buildVisualScene);

}

// scenes

function parseScene(xml){

var instance=getElementsByTagName(xml,'instance_visual_scene')[0];
return getVisualScene(parseId(instance.getAttribute('url')));

}

function setupAnimations(){

var clips=library.clips;

if(isEmpty(clips)===true){

if(isEmpty(library.animations)===false){

// if there are animations but no clips, we create a default clip for playback

var tracks=[];

for(var id in library.animations){

var animationTracks=getAnimation(id);

for(var i=0,l=animationTracks.length;i<l;i++){

tracks.push(animationTracks[i]);

}

}

animations.push(new AnimationClip('default',-1,tracks));

}

}else{

for(var id in clips){

animations.push(getAnimationClip(id));

}

}

}

// convert the parser error element into text with each child elements text
// separated by new lines.

function parserErrorToText(parserError){

var result='';
var stack=[parserError];

while(stack.length){

var node=stack.shift();

if(node.nodeType===Node.TEXT_NODE){

result+=node.textContent;

}else{

result+='\n';
stack.push.apply(stack,node.childNodes);

}

}

return result.trim();

}

if(text.length===0){

return{scene:new Scene()};

}

var xml=new DOMParser().parseFromString(text,'application/xml');

var collada=getElementsByTagName(xml,'COLLADA')[0];

var parserError=xml.getElementsByTagName('parsererror')[0];
if(parserError!==undefined){

// Chrome will return parser error with a div in it

var errorElement=getElementsByTagName(parserError,'div')[0];
var errorText;

if(errorElement){

errorText=errorElement.textContent;

}else{

errorText=parserErrorToText(parserError);

}

console.error('THREE.ColladaLoader: Failed to parse collada file.\n',errorText);

return null;

}

// metadata

var version=collada.getAttribute('version');
console.log('THREE.ColladaLoader: File version',version);

var asset=parseAsset(getElementsByTagName(collada,'asset')[0]);
var textureLoader=new TextureLoader(this.manager);
textureLoader.setPath(this.resourcePath||path).setCrossOrigin(this.crossOrigin);

var tgaLoader;

if(TGALoader){

tgaLoader=new TGALoader(this.manager);
tgaLoader.setPath(this.resourcePath||path);

}

//

var animations=[];
var kinematics={};
var count=0;

//

var library={
animations:{},
clips:{},
controllers:{},
images:{},
effects:{},
materials:{},
cameras:{},
lights:{},
geometries:{},
nodes:{},
visualScenes:{},
kinematicsModels:{},
physicsModels:{},
kinematicsScenes:{}};


parseLibrary(collada,'library_animations','animation',parseAnimation);
parseLibrary(collada,'library_animation_clips','animation_clip',parseAnimationClip);
parseLibrary(collada,'library_controllers','controller',parseController);
parseLibrary(collada,'library_images','image',parseImage);
parseLibrary(collada,'library_effects','effect',parseEffect);
parseLibrary(collada,'library_materials','material',parseMaterial);
parseLibrary(collada,'library_cameras','camera',parseCamera);
parseLibrary(collada,'library_lights','light',parseLight);
parseLibrary(collada,'library_geometries','geometry',parseGeometry);
parseLibrary(collada,'library_nodes','node',parseNode);
parseLibrary(collada,'library_visual_scenes','visual_scene',parseVisualScene);
parseLibrary(collada,'library_kinematics_models','kinematics_model',parseKinematicsModel);
parseLibrary(collada,'library_physics_models','physics_model',parsePhysicsModel);
parseLibrary(collada,'scene','instance_kinematics_scene',parseKinematicsScene);

buildLibrary(library.animations,buildAnimation);
buildLibrary(library.clips,buildAnimationClip);
buildLibrary(library.controllers,buildController);
buildLibrary(library.images,buildImage);
buildLibrary(library.effects,buildEffect);
buildLibrary(library.materials,buildMaterial);
buildLibrary(library.cameras,buildCamera);
buildLibrary(library.lights,buildLight);
buildLibrary(library.geometries,buildGeometry);
buildLibrary(library.visualScenes,buildVisualScene);

setupAnimations();
setupKinematics();

var scene=parseScene(getElementsByTagName(collada,'scene')[0]);

if(asset.upAxis==='Z_UP'){

scene.quaternion.setFromEuler(new Euler(-Math.PI/2,0,0));

}

scene.scale.multiplyScalar(asset.unit);

return{
animations:animations,
kinematics:kinematics,
library:library,
scene:scene};


}};





// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-collada.vue?vue&type=script&lang=js&


/* harmony default export */var model_colladavue_type_script_lang_js_={
name:'model-collada',
mixins:[model_mixin],
props:{
lights:{
type:Array,
default:function _default(){
return[{
type:'HemisphereLight',
position:{
x:0,
y:1,
z:0},

skyColor:0xaaaaff,
groundColor:0x806060,
intensity:0.2},
{
type:'DirectionalLight',
position:{
x:1,
y:1,
z:1},

color:0xffffff,
intensity:0.8}];

}},

smoothing:{
type:Boolean,
default:false}},


data:function data(){
var loader=new ColladaLoader();
loader.setCrossOrigin(this.crossOrigin);
return{
loader:loader};

},
methods:{
getObject:function getObject(collada){
return collada.scene;
}}};


// CONCATENATED MODULE: ./src/model-collada.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_colladavue_type_script_lang_js_=model_colladavue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-collada.vue
var model_collada_render,model_collada_staticRenderFns;




/* normalize component */

var model_collada_component=normalizeComponent(
src_model_colladavue_type_script_lang_js_,
model_collada_render,
model_collada_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_collada=model_collada_component.exports;
// CONCATENATED MODULE: ./node_modules/_three@0.105.2@three/examples/jsm/loaders/GLTFLoader.js
/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */



var GLTFLoader_GLTFLoader=function(){

function GLTFLoader(manager){

this.manager=manager!==undefined?manager:DefaultLoadingManager;
this.dracoLoader=null;

}

GLTFLoader.prototype={

constructor:GLTFLoader,

crossOrigin:'anonymous',

load:function load(url,onLoad,onProgress,onError){

var scope=this;

var resourcePath;

if(this.resourcePath!==undefined){

resourcePath=this.resourcePath;

}else if(this.path!==undefined){

resourcePath=this.path;

}else{

resourcePath=LoaderUtils.extractUrlBase(url);

}

// Tells the LoadingManager to track an extra item, which resolves after
// the model is fully loaded. This means the count of items loaded will
// be incorrect, but ensures manager.onLoad() does not fire early.
scope.manager.itemStart(url);

var _onError=function _onError(e){

if(onError){

onError(e);

}else{

console.error(e);

}

scope.manager.itemError(url);
scope.manager.itemEnd(url);

};

var loader=new FileLoader(scope.manager);

loader.setPath(this.path);
loader.setResponseType('arraybuffer');

loader.load(url,function(data){

try{

scope.parse(data,resourcePath,function(gltf){

onLoad(gltf);

scope.manager.itemEnd(url);

},_onError);

}catch(e){

_onError(e);

}

},onProgress,_onError);

},

setCrossOrigin:function setCrossOrigin(value){

this.crossOrigin=value;
return this;

},

setPath:function setPath(value){

this.path=value;
return this;

},

setResourcePath:function setResourcePath(value){

this.resourcePath=value;
return this;

},

setDRACOLoader:function setDRACOLoader(dracoLoader){

this.dracoLoader=dracoLoader;
return this;

},

parse:function parse(data,path,onLoad,onError){

var content;
var extensions={};

if(typeof data==='string'){

content=data;

}else{

var magic=LoaderUtils.decodeText(new Uint8Array(data,0,4));

if(magic===BINARY_EXTENSION_HEADER_MAGIC){

try{

extensions[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(data);

}catch(error){

if(onError)onError(error);
return;

}

content=extensions[EXTENSIONS.KHR_BINARY_GLTF].content;

}else{

content=LoaderUtils.decodeText(new Uint8Array(data));

}

}

var json=JSON.parse(content);

if(json.asset===undefined||json.asset.version[0]<2){

if(onError)onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));
return;

}

if(json.extensionsUsed){

for(var i=0;i<json.extensionsUsed.length;++i){

var extensionName=json.extensionsUsed[i];
var extensionsRequired=json.extensionsRequired||[];

switch(extensionName){

case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
extensions[extensionName]=new GLTFLightsExtension(json);
break;

case EXTENSIONS.KHR_MATERIALS_UNLIT:
extensions[extensionName]=new GLTFMaterialsUnlitExtension(json);
break;

case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
extensions[extensionName]=new GLTFMaterialsPbrSpecularGlossinessExtension(json);
break;

case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
extensions[extensionName]=new GLTFDracoMeshCompressionExtension(json,this.dracoLoader);
break;

case EXTENSIONS.MSFT_TEXTURE_DDS:
extensions[EXTENSIONS.MSFT_TEXTURE_DDS]=new GLTFTextureDDSExtension();
break;

case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]=new GLTFTextureTransformExtension(json);
break;

default:

if(extensionsRequired.indexOf(extensionName)>=0){

console.warn('THREE.GLTFLoader: Unknown extension "'+extensionName+'".');

}}



}

}

var parser=new GLTFParser(json,extensions,{

path:path||this.resourcePath||'',
crossOrigin:this.crossOrigin,
manager:this.manager});



parser.parse(onLoad,onError);

}};



/* GLTFREGISTRY */

function GLTFRegistry(){

var objects={};

return{

get:function get(key){

return objects[key];

},

add:function add(key,object){

objects[key]=object;

},

remove:function remove(key){

delete objects[key];

},

removeAll:function removeAll(){

objects={};

}};



}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

var EXTENSIONS={
KHR_BINARY_GLTF:'KHR_binary_glTF',
KHR_DRACO_MESH_COMPRESSION:'KHR_draco_mesh_compression',
KHR_LIGHTS_PUNCTUAL:'KHR_lights_punctual',
KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:'KHR_materials_pbrSpecularGlossiness',
KHR_MATERIALS_UNLIT:'KHR_materials_unlit',
KHR_TEXTURE_TRANSFORM:'KHR_texture_transform',
MSFT_TEXTURE_DDS:'MSFT_texture_dds'};


/**
	 * DDS Texture Extension
	 *
	 * Specification:
	 * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
	 *
	 */
function GLTFTextureDDSExtension(){

if(!THREE.DDSLoader){

throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');

}

this.name=EXTENSIONS.MSFT_TEXTURE_DDS;
this.ddsLoader=new THREE.DDSLoader();

}

/**
	 * Lights Extension
	 *
	 * Specification: PENDING
	 */
function GLTFLightsExtension(json){

this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

var extension=json.extensions&&json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]||{};
this.lightDefs=extension.lights||[];

}

GLTFLightsExtension.prototype.loadLight=function(lightIndex){

var lightDef=this.lightDefs[lightIndex];
var lightNode;

var color=new Color(0xffffff);
if(lightDef.color!==undefined)color.fromArray(lightDef.color);

var range=lightDef.range!==undefined?lightDef.range:0;

switch(lightDef.type){

case'directional':
lightNode=new DirectionalLight(color);
lightNode.target.position.set(0,0,-1);
lightNode.add(lightNode.target);
break;

case'point':
lightNode=new PointLight(color);
lightNode.distance=range;
break;

case'spot':
lightNode=new SpotLight(color);
lightNode.distance=range;
// Handle spotlight properties.
lightDef.spot=lightDef.spot||{};
lightDef.spot.innerConeAngle=lightDef.spot.innerConeAngle!==undefined?lightDef.spot.innerConeAngle:0;
lightDef.spot.outerConeAngle=lightDef.spot.outerConeAngle!==undefined?lightDef.spot.outerConeAngle:Math.PI/4.0;
lightNode.angle=lightDef.spot.outerConeAngle;
lightNode.penumbra=1.0-lightDef.spot.innerConeAngle/lightDef.spot.outerConeAngle;
lightNode.target.position.set(0,0,-1);
lightNode.add(lightNode.target);
break;

default:
throw new Error('THREE.GLTFLoader: Unexpected light type, "'+lightDef.type+'".');}



// Some lights (e.g. spot) default to a position other than the origin. Reset the position
// here, because node-level parsing will only override position if explicitly specified.
lightNode.position.set(0,0,0);

lightNode.decay=2;

if(lightDef.intensity!==undefined)lightNode.intensity=lightDef.intensity;

lightNode.name=lightDef.name||'light_'+lightIndex;

return Promise.resolve(lightNode);

};

/**
	 * Unlit Materials Extension (pending)
	 *
	 * PR: https://github.com/KhronosGroup/glTF/pull/1163
	 */
function GLTFMaterialsUnlitExtension(){

this.name=EXTENSIONS.KHR_MATERIALS_UNLIT;

}

GLTFMaterialsUnlitExtension.prototype.getMaterialType=function(){

return MeshBasicMaterial;

};

GLTFMaterialsUnlitExtension.prototype.extendParams=function(materialParams,materialDef,parser){

var pending=[];

materialParams.color=new Color(1.0,1.0,1.0);
materialParams.opacity=1.0;

var metallicRoughness=materialDef.pbrMetallicRoughness;

if(metallicRoughness){

if(Array.isArray(metallicRoughness.baseColorFactor)){

var array=metallicRoughness.baseColorFactor;

materialParams.color.fromArray(array);
materialParams.opacity=array[3];

}

if(metallicRoughness.baseColorTexture!==undefined){

pending.push(parser.assignTexture(materialParams,'map',metallicRoughness.baseColorTexture));

}

}

return Promise.all(pending);

};

/* BINARY EXTENSION */

var BINARY_EXTENSION_BUFFER_NAME='binary_glTF';
var BINARY_EXTENSION_HEADER_MAGIC='glTF';
var BINARY_EXTENSION_HEADER_LENGTH=12;
var BINARY_EXTENSION_CHUNK_TYPES={JSON:0x4E4F534A,BIN:0x004E4942};

function GLTFBinaryExtension(data){

this.name=EXTENSIONS.KHR_BINARY_GLTF;
this.content=null;
this.body=null;

var headerView=new DataView(data,0,BINARY_EXTENSION_HEADER_LENGTH);

this.header={
magic:LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),
version:headerView.getUint32(4,true),
length:headerView.getUint32(8,true)};


if(this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC){

throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');

}else if(this.header.version<2.0){

throw new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');

}

var chunkView=new DataView(data,BINARY_EXTENSION_HEADER_LENGTH);
var chunkIndex=0;

while(chunkIndex<chunkView.byteLength){

var chunkLength=chunkView.getUint32(chunkIndex,true);
chunkIndex+=4;

var chunkType=chunkView.getUint32(chunkIndex,true);
chunkIndex+=4;

if(chunkType===BINARY_EXTENSION_CHUNK_TYPES.JSON){

var contentArray=new Uint8Array(data,BINARY_EXTENSION_HEADER_LENGTH+chunkIndex,chunkLength);
this.content=LoaderUtils.decodeText(contentArray);

}else if(chunkType===BINARY_EXTENSION_CHUNK_TYPES.BIN){

var byteOffset=BINARY_EXTENSION_HEADER_LENGTH+chunkIndex;
this.body=data.slice(byteOffset,byteOffset+chunkLength);

}

// Clients must ignore chunks with unknown types.

chunkIndex+=chunkLength;

}

if(this.content===null){

throw new Error('THREE.GLTFLoader: JSON content not found.');

}

}

/**
	 * DRACO Mesh Compression Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/pull/874
	 */
function GLTFDracoMeshCompressionExtension(json,dracoLoader){

if(!dracoLoader){

throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');

}

this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
this.json=json;
this.dracoLoader=dracoLoader;

}

GLTFDracoMeshCompressionExtension.prototype.decodePrimitive=function(primitive,parser){

var json=this.json;
var dracoLoader=this.dracoLoader;
var bufferViewIndex=primitive.extensions[this.name].bufferView;
var gltfAttributeMap=primitive.extensions[this.name].attributes;
var threeAttributeMap={};
var attributeNormalizedMap={};
var attributeTypeMap={};

for(var attributeName in gltfAttributeMap){

var threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();

threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName];

}

for(attributeName in primitive.attributes){

var threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();

if(gltfAttributeMap[attributeName]!==undefined){

var accessorDef=json.accessors[primitive.attributes[attributeName]];
var componentType=WEBGL_COMPONENT_TYPES[accessorDef.componentType];

attributeTypeMap[threeAttributeName]=componentType;
attributeNormalizedMap[threeAttributeName]=accessorDef.normalized===true;

}

}

return parser.getDependency('bufferView',bufferViewIndex).then(function(bufferView){

return new Promise(function(resolve){

dracoLoader.decodeDracoFile(bufferView,function(geometry){

for(var attributeName in geometry.attributes){

var attribute=geometry.attributes[attributeName];
var normalized=attributeNormalizedMap[attributeName];

if(normalized!==undefined)attribute.normalized=normalized;

}

resolve(geometry);

},threeAttributeMap,attributeTypeMap);

});

});

};

/**
	 * Texture Transform Extension
	 *
	 * Specification:
	 */
function GLTFTextureTransformExtension(){

this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM;

}

GLTFTextureTransformExtension.prototype.extendTexture=function(texture,transform){

texture=texture.clone();

if(transform.offset!==undefined){

texture.offset.fromArray(transform.offset);

}

if(transform.rotation!==undefined){

texture.rotation=transform.rotation;

}

if(transform.scale!==undefined){

texture.repeat.fromArray(transform.scale);

}

if(transform.texCoord!==undefined){

console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.');

}

texture.needsUpdate=true;

return texture;

};

/**
	 * Specular-Glossiness Extension
	 *
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
	 */
function GLTFMaterialsPbrSpecularGlossinessExtension(){

return{

name:EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

specularGlossinessParams:[
'color',
'map',
'lightMap',
'lightMapIntensity',
'aoMap',
'aoMapIntensity',
'emissive',
'emissiveIntensity',
'emissiveMap',
'bumpMap',
'bumpScale',
'normalMap',
'displacementMap',
'displacementScale',
'displacementBias',
'specularMap',
'specular',
'glossinessMap',
'glossiness',
'alphaMap',
'envMap',
'envMapIntensity',
'refractionRatio'],


getMaterialType:function getMaterialType(){

return ShaderMaterial;

},

extendParams:function extendParams(materialParams,materialDef,parser){

var pbrSpecularGlossiness=materialDef.extensions[this.name];

var shader=ShaderLib['standard'];

var uniforms=UniformsUtils.clone(shader.uniforms);

var specularMapParsFragmentChunk=[
'#ifdef USE_SPECULARMAP',
'	uniform sampler2D specularMap;',
'#endif'].
join('\n');

var glossinessMapParsFragmentChunk=[
'#ifdef USE_GLOSSINESSMAP',
'	uniform sampler2D glossinessMap;',
'#endif'].
join('\n');

var specularMapFragmentChunk=[
'vec3 specularFactor = specular;',
'#ifdef USE_SPECULARMAP',
'	vec4 texelSpecular = texture2D( specularMap, vUv );',
'	texelSpecular = sRGBToLinear( texelSpecular );',
'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
'	specularFactor *= texelSpecular.rgb;',
'#endif'].
join('\n');

var glossinessMapFragmentChunk=[
'float glossinessFactor = glossiness;',
'#ifdef USE_GLOSSINESSMAP',
'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
'	glossinessFactor *= texelGlossiness.a;',
'#endif'].
join('\n');

var lightPhysicalFragmentChunk=[
'PhysicalMaterial material;',
'material.diffuseColor = diffuseColor.rgb;',
'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',
'material.specularColor = specularFactor.rgb;'].
join('\n');

var fragmentShader=shader.fragmentShader.
replace('uniform float roughness;','uniform vec3 specular;').
replace('uniform float metalness;','uniform float glossiness;').
replace('#include <roughnessmap_pars_fragment>',specularMapParsFragmentChunk).
replace('#include <metalnessmap_pars_fragment>',glossinessMapParsFragmentChunk).
replace('#include <roughnessmap_fragment>',specularMapFragmentChunk).
replace('#include <metalnessmap_fragment>',glossinessMapFragmentChunk).
replace('#include <lights_physical_fragment>',lightPhysicalFragmentChunk);

delete uniforms.roughness;
delete uniforms.metalness;
delete uniforms.roughnessMap;
delete uniforms.metalnessMap;

uniforms.specular={value:new Color().setHex(0x111111)};
uniforms.glossiness={value:0.5};
uniforms.specularMap={value:null};
uniforms.glossinessMap={value:null};

materialParams.vertexShader=shader.vertexShader;
materialParams.fragmentShader=fragmentShader;
materialParams.uniforms=uniforms;
materialParams.defines={'STANDARD':''};

materialParams.color=new Color(1.0,1.0,1.0);
materialParams.opacity=1.0;

var pending=[];

if(Array.isArray(pbrSpecularGlossiness.diffuseFactor)){

var array=pbrSpecularGlossiness.diffuseFactor;

materialParams.color.fromArray(array);
materialParams.opacity=array[3];

}

if(pbrSpecularGlossiness.diffuseTexture!==undefined){

pending.push(parser.assignTexture(materialParams,'map',pbrSpecularGlossiness.diffuseTexture));

}

materialParams.emissive=new Color(0.0,0.0,0.0);
materialParams.glossiness=pbrSpecularGlossiness.glossinessFactor!==undefined?pbrSpecularGlossiness.glossinessFactor:1.0;
materialParams.specular=new Color(1.0,1.0,1.0);

if(Array.isArray(pbrSpecularGlossiness.specularFactor)){

materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);

}

if(pbrSpecularGlossiness.specularGlossinessTexture!==undefined){

var specGlossMapDef=pbrSpecularGlossiness.specularGlossinessTexture;
pending.push(parser.assignTexture(materialParams,'glossinessMap',specGlossMapDef));
pending.push(parser.assignTexture(materialParams,'specularMap',specGlossMapDef));

}

return Promise.all(pending);

},

createMaterial:function createMaterial(params){

// setup material properties based on MeshStandardMaterial for Specular-Glossiness

var material=new ShaderMaterial({
defines:params.defines,
vertexShader:params.vertexShader,
fragmentShader:params.fragmentShader,
uniforms:params.uniforms,
fog:true,
lights:true,
opacity:params.opacity,
transparent:params.transparent});


material.isGLTFSpecularGlossinessMaterial=true;

material.color=params.color;

material.map=params.map===undefined?null:params.map;

material.lightMap=null;
material.lightMapIntensity=1.0;

material.aoMap=params.aoMap===undefined?null:params.aoMap;
material.aoMapIntensity=1.0;

material.emissive=params.emissive;
material.emissiveIntensity=1.0;
material.emissiveMap=params.emissiveMap===undefined?null:params.emissiveMap;

material.bumpMap=params.bumpMap===undefined?null:params.bumpMap;
material.bumpScale=1;

material.normalMap=params.normalMap===undefined?null:params.normalMap;

if(params.normalScale)material.normalScale=params.normalScale;

material.displacementMap=null;
material.displacementScale=1;
material.displacementBias=0;

material.specularMap=params.specularMap===undefined?null:params.specularMap;
material.specular=params.specular;

material.glossinessMap=params.glossinessMap===undefined?null:params.glossinessMap;
material.glossiness=params.glossiness;

material.alphaMap=null;

material.envMap=params.envMap===undefined?null:params.envMap;
material.envMapIntensity=1.0;

material.refractionRatio=0.98;

material.extensions.derivatives=true;

return material;

},

/**
			 * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
			 * copy only properties it knows about or inherits, and misses many properties that would
			 * normally be defined by MeshStandardMaterial.
			 *
			 * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
			 * loading a glTF model, but cloning later (e.g. by the user) would require these changes
			 * AND also updating `.onBeforeRender` on the parent mesh.
			 *
			 * @param  {ShaderMaterial} source
			 * @return {ShaderMaterial}
			 */
cloneMaterial:function cloneMaterial(source){

var target=source.clone();

target.isGLTFSpecularGlossinessMaterial=true;

var params=this.specularGlossinessParams;

for(var i=0,il=params.length;i<il;i++){

var value=source[params[i]];
target[params[i]]=value&&value.isColor?value.clone():value;

}

return target;

},

// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
refreshUniforms:function refreshUniforms(renderer,scene,camera,geometry,material,group){

if(material.isGLTFSpecularGlossinessMaterial!==true){

return;

}

var uniforms=material.uniforms;
var defines=material.defines;

uniforms.opacity.value=material.opacity;

uniforms.diffuse.value.copy(material.color);
uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);

uniforms.map.value=material.map;
uniforms.specularMap.value=material.specularMap;
uniforms.alphaMap.value=material.alphaMap;

uniforms.lightMap.value=material.lightMap;
uniforms.lightMapIntensity.value=material.lightMapIntensity;

uniforms.aoMap.value=material.aoMap;
uniforms.aoMapIntensity.value=material.aoMapIntensity;

// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map

var uvScaleMap;

if(material.map){

uvScaleMap=material.map;

}else if(material.specularMap){

uvScaleMap=material.specularMap;

}else if(material.displacementMap){

uvScaleMap=material.displacementMap;

}else if(material.normalMap){

uvScaleMap=material.normalMap;

}else if(material.bumpMap){

uvScaleMap=material.bumpMap;

}else if(material.glossinessMap){

uvScaleMap=material.glossinessMap;

}else if(material.alphaMap){

uvScaleMap=material.alphaMap;

}else if(material.emissiveMap){

uvScaleMap=material.emissiveMap;

}

if(uvScaleMap!==undefined){

// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){

uvScaleMap=uvScaleMap.texture;

}

if(uvScaleMap.matrixAutoUpdate===true){

uvScaleMap.updateMatrix();

}

uniforms.uvTransform.value.copy(uvScaleMap.matrix);

}

if(material.envMap){

uniforms.envMap.value=material.envMap;
uniforms.envMapIntensity.value=material.envMapIntensity;

// don't flip CubeTexture envMaps, flip everything else:
//  WebGLRenderTargetCube will be flipped for backwards compatibility
//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
uniforms.flipEnvMap.value=material.envMap.isCubeTexture?-1:1;

uniforms.reflectivity.value=material.reflectivity;
uniforms.refractionRatio.value=material.refractionRatio;

uniforms.maxMipLevel.value=renderer.properties.get(material.envMap).__maxMipLevel;

}

uniforms.specular.value.copy(material.specular);
uniforms.glossiness.value=material.glossiness;

uniforms.glossinessMap.value=material.glossinessMap;

uniforms.emissiveMap.value=material.emissiveMap;
uniforms.bumpMap.value=material.bumpMap;
uniforms.normalMap.value=material.normalMap;

uniforms.displacementMap.value=material.displacementMap;
uniforms.displacementScale.value=material.displacementScale;
uniforms.displacementBias.value=material.displacementBias;

if(uniforms.glossinessMap.value!==null&&defines.USE_GLOSSINESSMAP===undefined){

defines.USE_GLOSSINESSMAP='';
// set USE_ROUGHNESSMAP to enable vUv
defines.USE_ROUGHNESSMAP='';

}

if(uniforms.glossinessMap.value===null&&defines.USE_GLOSSINESSMAP!==undefined){

delete defines.USE_GLOSSINESSMAP;
delete defines.USE_ROUGHNESSMAP;

}

}};



}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
function GLTFCubicSplineInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){

Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);

}

GLTFCubicSplineInterpolant.prototype=Object.create(Interpolant.prototype);
GLTFCubicSplineInterpolant.prototype.constructor=GLTFCubicSplineInterpolant;

GLTFCubicSplineInterpolant.prototype.copySampleValue_=function(index){

// Copies a sample value to the result buffer. See description of glTF
// CUBICSPLINE values layout in interpolate_() function below.

var result=this.resultBuffer,
values=this.sampleValues,
valueSize=this.valueSize,
offset=index*valueSize*3+valueSize;

for(var i=0;i!==valueSize;i++){

result[i]=values[offset+i];

}

return result;

};

GLTFCubicSplineInterpolant.prototype.beforeStart_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_=GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_=function(i1,t0,t,t1){

var result=this.resultBuffer;
var values=this.sampleValues;
var stride=this.valueSize;

var stride2=stride*2;
var stride3=stride*3;

var td=t1-t0;

var p=(t-t0)/td;
var pp=p*p;
var ppp=pp*p;

var offset1=i1*stride3;
var offset0=offset1-stride3;

var s2=-2*ppp+3*pp;
var s3=ppp-pp;
var s0=1-s2;
var s1=s3-pp+p;

// Layout of keyframe output values for CUBICSPLINE animations:
//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
for(var i=0;i!==stride;i++){

var p0=values[offset0+i+stride];// splineVertex_k
var m0=values[offset0+i+stride2]*td;// outTangent_k * (t_k+1 - t_k)
var p1=values[offset1+i+stride];// splineVertex_k+1
var m1=values[offset1+i]*td;// inTangent_k+1 * (t_k+1 - t_k)

result[i]=s0*p0+s1*m0+s2*p1+s3*m1;

}

return result;

};

/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

var WEBGL_CONSTANTS={
FLOAT:5126,
//FLOAT_MAT2: 35674,
FLOAT_MAT3:35675,
FLOAT_MAT4:35676,
FLOAT_VEC2:35664,
FLOAT_VEC3:35665,
FLOAT_VEC4:35666,
LINEAR:9729,
REPEAT:10497,
SAMPLER_2D:35678,
POINTS:0,
LINES:1,
LINE_LOOP:2,
LINE_STRIP:3,
TRIANGLES:4,
TRIANGLE_STRIP:5,
TRIANGLE_FAN:6,
UNSIGNED_BYTE:5121,
UNSIGNED_SHORT:5123};


var WEBGL_TYPE={
5126:Number,
//35674: THREE.Matrix2,
35675:Matrix3,
35676:Matrix4,
35664:Vector2,
35665:Vector3,
35666:Vector4,
35678:Texture};


var WEBGL_COMPONENT_TYPES={
5120:Int8Array,
5121:Uint8Array,
5122:Int16Array,
5123:Uint16Array,
5125:Uint32Array,
5126:Float32Array};


var WEBGL_FILTERS={
9728:NearestFilter,
9729:LinearFilter,
9984:NearestMipMapNearestFilter,
9985:LinearMipMapNearestFilter,
9986:NearestMipMapLinearFilter,
9987:LinearMipMapLinearFilter};


var WEBGL_WRAPPINGS={
33071:ClampToEdgeWrapping,
33648:MirroredRepeatWrapping,
10497:RepeatWrapping};


var WEBGL_SIDES={
1028:BackSide,// Culling front
1029:FrontSide// Culling back
//1032: THREE.NoSide   // Culling front and back, what to do?
};

var WEBGL_DEPTH_FUNCS={
512:NeverDepth,
513:LessDepth,
514:EqualDepth,
515:LessEqualDepth,
516:GreaterEqualDepth,
517:NotEqualDepth,
518:GreaterEqualDepth,
519:AlwaysDepth};


var WEBGL_BLEND_EQUATIONS={
32774:AddEquation,
32778:SubtractEquation,
32779:ReverseSubtractEquation};


var WEBGL_BLEND_FUNCS={
0:ZeroFactor,
1:OneFactor,
768:SrcColorFactor,
769:OneMinusSrcColorFactor,
770:SrcAlphaFactor,
771:OneMinusSrcAlphaFactor,
772:DstAlphaFactor,
773:OneMinusDstAlphaFactor,
774:DstColorFactor,
775:OneMinusDstColorFactor,
776:SrcAlphaSaturateFactor
// The followings are not supported by Three.js yet
//32769: CONSTANT_COLOR,
//32770: ONE_MINUS_CONSTANT_COLOR,
//32771: CONSTANT_ALPHA,
//32772: ONE_MINUS_CONSTANT_COLOR
};

var WEBGL_TYPE_SIZES={
'SCALAR':1,
'VEC2':2,
'VEC3':3,
'VEC4':4,
'MAT2':4,
'MAT3':9,
'MAT4':16};


var ATTRIBUTES={
POSITION:'position',
NORMAL:'normal',
TANGENT:'tangent',
TEXCOORD_0:'uv',
TEXCOORD_1:'uv2',
COLOR_0:'color',
WEIGHTS_0:'skinWeight',
JOINTS_0:'skinIndex'};


var PATH_PROPERTIES={
scale:'scale',
translation:'position',
rotation:'quaternion',
weights:'morphTargetInfluences'};


var INTERPOLATION={
CUBICSPLINE:undefined,// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
// keyframe track will be initialized with a default interpolation type, then modified.
LINEAR:InterpolateLinear,
STEP:InterpolateDiscrete};


var STATES_ENABLES={
2884:'CULL_FACE',
2929:'DEPTH_TEST',
3042:'BLEND',
3089:'SCISSOR_TEST',
32823:'POLYGON_OFFSET_FILL',
32926:'SAMPLE_ALPHA_TO_COVERAGE'};


var ALPHA_MODES={
OPAQUE:'OPAQUE',
MASK:'MASK',
BLEND:'BLEND'};


var MIME_TYPE_FORMATS={
'image/png':RGBAFormat,
'image/jpeg':RGBFormat};


/* UTILITY FUNCTIONS */

function resolveURL(url,path){

// Invalid URL
if(typeof url!=='string'||url==='')return'';

// Absolute URL http://,https://,//
if(/^(https?:)?\/\//i.test(url))return url;

// Data URI
if(/^data:.*,.*$/i.test(url))return url;

// Blob URL
if(/^blob:.*$/i.test(url))return url;

// Relative URL
return path+url;

}

var defaultMaterial;

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
	 */
function createDefaultMaterial(){

defaultMaterial=defaultMaterial||new MeshStandardMaterial({
color:0xFFFFFF,
emissive:0x000000,
metalness:1,
roughness:1,
transparent:false,
depthTest:true,
side:FrontSide});


return defaultMaterial;

}

function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){

// Add unknown glTF extensions to an object's userData.

for(var name in objectDef.extensions){

if(knownExtensions[name]===undefined){

object.userData.gltfExtensions=object.userData.gltfExtensions||{};
object.userData.gltfExtensions[name]=objectDef.extensions[name];

}

}

}

/**
	 * @param {Object3D|Material|BufferGeometry} object
	 * @param {GLTF.definition} gltfDef
	 */
function assignExtrasToUserData(object,gltfDef){

if(gltfDef.extras!==undefined){

if(typeof gltfDef.extras==='object'){

Object.assign(object.userData,gltfDef.extras);

}else{

console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, '+gltfDef.extras);

}

}

}

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
	 *
	 * @param {BufferGeometry} geometry
	 * @param {Array<GLTF.Target>} targets
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
function addMorphTargets(geometry,targets,parser){

var hasMorphPosition=false;
var hasMorphNormal=false;

for(var i=0,il=targets.length;i<il;i++){

var target=targets[i];

if(target.POSITION!==undefined)hasMorphPosition=true;
if(target.NORMAL!==undefined)hasMorphNormal=true;

if(hasMorphPosition&&hasMorphNormal)break;

}

if(!hasMorphPosition&&!hasMorphNormal)return Promise.resolve(geometry);

var pendingPositionAccessors=[];
var pendingNormalAccessors=[];

for(var i=0,il=targets.length;i<il;i++){

var target=targets[i];

if(hasMorphPosition){

var pendingAccessor=target.POSITION!==undefined?
parser.getDependency('accessor',target.POSITION):
geometry.attributes.position;

pendingPositionAccessors.push(pendingAccessor);

}

if(hasMorphNormal){

var pendingAccessor=target.NORMAL!==undefined?
parser.getDependency('accessor',target.NORMAL):
geometry.attributes.normal;

pendingNormalAccessors.push(pendingAccessor);

}

}

return Promise.all([
Promise.all(pendingPositionAccessors),
Promise.all(pendingNormalAccessors)]).
then(function(accessors){

var morphPositions=accessors[0];
var morphNormals=accessors[1];

// Clone morph target accessors before modifying them.

for(var i=0,il=morphPositions.length;i<il;i++){

if(geometry.attributes.position===morphPositions[i])continue;

morphPositions[i]=cloneBufferAttribute(morphPositions[i]);

}

for(var i=0,il=morphNormals.length;i<il;i++){

if(geometry.attributes.normal===morphNormals[i])continue;

morphNormals[i]=cloneBufferAttribute(morphNormals[i]);

}

for(var i=0,il=targets.length;i<il;i++){

var target=targets[i];
var attributeName='morphTarget'+i;

if(hasMorphPosition){

// Three.js morph position is absolute value. The formula is
//   basePosition
//     + weight0 * ( morphPosition0 - basePosition )
//     + weight1 * ( morphPosition1 - basePosition )
//     ...
// while the glTF one is relative
//   basePosition
//     + weight0 * glTFmorphPosition0
//     + weight1 * glTFmorphPosition1
//     ...
// then we need to convert from relative to absolute here.

if(target.POSITION!==undefined){

var positionAttribute=morphPositions[i];
positionAttribute.name=attributeName;

var position=geometry.attributes.position;

for(var j=0,jl=positionAttribute.count;j<jl;j++){

positionAttribute.setXYZ(
j,
positionAttribute.getX(j)+position.getX(j),
positionAttribute.getY(j)+position.getY(j),
positionAttribute.getZ(j)+position.getZ(j));


}

}

}

if(hasMorphNormal){

// see target.POSITION's comment

if(target.NORMAL!==undefined){

var normalAttribute=morphNormals[i];
normalAttribute.name=attributeName;

var normal=geometry.attributes.normal;

for(var j=0,jl=normalAttribute.count;j<jl;j++){

normalAttribute.setXYZ(
j,
normalAttribute.getX(j)+normal.getX(j),
normalAttribute.getY(j)+normal.getY(j),
normalAttribute.getZ(j)+normal.getZ(j));


}

}

}

}

if(hasMorphPosition)geometry.morphAttributes.position=morphPositions;
if(hasMorphNormal)geometry.morphAttributes.normal=morphNormals;

return geometry;

});

}

/**
	 * @param {Mesh} mesh
	 * @param {GLTF.Mesh} meshDef
	 */
function updateMorphTargets(mesh,meshDef){

mesh.updateMorphTargets();

if(meshDef.weights!==undefined){

for(var i=0,il=meshDef.weights.length;i<il;i++){

mesh.morphTargetInfluences[i]=meshDef.weights[i];

}

}

// .extras has user-defined data, so check that .extras.targetNames is an array.
if(meshDef.extras&&Array.isArray(meshDef.extras.targetNames)){

var targetNames=meshDef.extras.targetNames;

if(mesh.morphTargetInfluences.length===targetNames.length){

mesh.morphTargetDictionary={};

for(var i=0,il=targetNames.length;i<il;i++){

mesh.morphTargetDictionary[targetNames[i]]=i;

}

}else{

console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');

}

}

}
function isObjectEqual(a,b){

if(Object.keys(a).length!==Object.keys(b).length)return false;

for(var key in a){

if(a[key]!==b[key])return false;

}

return true;

}

function createPrimitiveKey(primitiveDef){

var dracoExtension=primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
var geometryKey;

if(dracoExtension){

geometryKey='draco:'+dracoExtension.bufferView+
':'+dracoExtension.indices+
':'+createAttributesKey(dracoExtension.attributes);

}else{

geometryKey=primitiveDef.indices+':'+createAttributesKey(primitiveDef.attributes)+':'+primitiveDef.mode;

}

return geometryKey;

}

function createAttributesKey(attributes){

var attributesKey='';

var keys=Object.keys(attributes).sort();

for(var i=0,il=keys.length;i<il;i++){

attributesKey+=keys[i]+':'+attributes[keys[i]]+';';

}

return attributesKey;

}

function cloneBufferAttribute(attribute){

if(attribute.isInterleavedBufferAttribute){

var count=attribute.count;
var itemSize=attribute.itemSize;
var array=attribute.array.slice(0,count*itemSize);

for(var i=0,j=0;i<count;++i){

array[j++]=attribute.getX(i);
if(itemSize>=2)array[j++]=attribute.getY(i);
if(itemSize>=3)array[j++]=attribute.getZ(i);
if(itemSize>=4)array[j++]=attribute.getW(i);

}

return new BufferAttribute(array,itemSize,attribute.normalized);

}

return attribute.clone();

}

/* GLTF PARSER */

function GLTFParser(json,extensions,options){

this.json=json||{};
this.extensions=extensions||{};
this.options=options||{};

// loader object cache
this.cache=new GLTFRegistry();

// BufferGeometry caching
this.primitiveCache={};

this.textureLoader=new TextureLoader(this.options.manager);
this.textureLoader.setCrossOrigin(this.options.crossOrigin);

this.fileLoader=new FileLoader(this.options.manager);
this.fileLoader.setResponseType('arraybuffer');

}

GLTFParser.prototype.parse=function(onLoad,onError){

var parser=this;
var json=this.json;
var extensions=this.extensions;

// Clear the loader cache
this.cache.removeAll();

// Mark the special nodes/meshes in json for efficient parse
this.markDefs();

Promise.all([

this.getDependencies('scene'),
this.getDependencies('animation'),
this.getDependencies('camera')]).

then(function(dependencies){

var result={
scene:dependencies[0][json.scene||0],
scenes:dependencies[0],
animations:dependencies[1],
cameras:dependencies[2],
asset:json.asset,
parser:parser,
userData:{}};


addUnknownExtensionsToUserData(extensions,result,json);

onLoad(result);

}).catch(onError);

};

/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
GLTFParser.prototype.markDefs=function(){

var nodeDefs=this.json.nodes||[];
var skinDefs=this.json.skins||[];
var meshDefs=this.json.meshes||[];

var meshReferences={};
var meshUses={};

// Nothing in the node definition indicates whether it is a Bone or an
// Object3D. Use the skins' joint references to mark bones.
for(var skinIndex=0,skinLength=skinDefs.length;skinIndex<skinLength;skinIndex++){

var joints=skinDefs[skinIndex].joints;

for(var i=0,il=joints.length;i<il;i++){

nodeDefs[joints[i]].isBone=true;

}

}

// Meshes can (and should) be reused by multiple nodes in a glTF asset. To
// avoid having more than one Mesh with the same name, count
// references and rename instances below.
//
// Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
for(var nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){

var nodeDef=nodeDefs[nodeIndex];

if(nodeDef.mesh!==undefined){

if(meshReferences[nodeDef.mesh]===undefined){

meshReferences[nodeDef.mesh]=meshUses[nodeDef.mesh]=0;

}

meshReferences[nodeDef.mesh]++;

// Nothing in the mesh definition indicates whether it is
// a SkinnedMesh or Mesh. Use the node's mesh reference
// to mark SkinnedMesh if node has skin.
if(nodeDef.skin!==undefined){

meshDefs[nodeDef.mesh].isSkinnedMesh=true;

}

}

}

this.json.meshReferences=meshReferences;
this.json.meshUses=meshUses;

};

/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|Texture|AnimationClip|ArrayBuffer|Object>}
	 */
GLTFParser.prototype.getDependency=function(type,index){

var cacheKey=type+':'+index;
var dependency=this.cache.get(cacheKey);

if(!dependency){

switch(type){

case'scene':
dependency=this.loadScene(index);
break;

case'node':
dependency=this.loadNode(index);
break;

case'mesh':
dependency=this.loadMesh(index);
break;

case'accessor':
dependency=this.loadAccessor(index);
break;

case'bufferView':
dependency=this.loadBufferView(index);
break;

case'buffer':
dependency=this.loadBuffer(index);
break;

case'material':
dependency=this.loadMaterial(index);
break;

case'texture':
dependency=this.loadTexture(index);
break;

case'skin':
dependency=this.loadSkin(index);
break;

case'animation':
dependency=this.loadAnimation(index);
break;

case'camera':
dependency=this.loadCamera(index);
break;

case'light':
dependency=this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
break;

default:
throw new Error('Unknown type: '+type);}



this.cache.add(cacheKey,dependency);

}

return dependency;

};

/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
GLTFParser.prototype.getDependencies=function(type){

var dependencies=this.cache.get(type);

if(!dependencies){

var parser=this;
var defs=this.json[type+(type==='mesh'?'es':'s')]||[];

dependencies=Promise.all(defs.map(function(def,index){

return parser.getDependency(type,index);

}));

this.cache.add(type,dependencies);

}

return dependencies;

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
GLTFParser.prototype.loadBuffer=function(bufferIndex){

var bufferDef=this.json.buffers[bufferIndex];
var loader=this.fileLoader;

if(bufferDef.type&&bufferDef.type!=='arraybuffer'){

throw new Error('THREE.GLTFLoader: '+bufferDef.type+' buffer type is not supported.');

}

// If present, GLB container is required to be the first buffer.
if(bufferDef.uri===undefined&&bufferIndex===0){

return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);

}

var options=this.options;

return new Promise(function(resolve,reject){

loader.load(resolveURL(bufferDef.uri,options.path),resolve,undefined,function(){

reject(new Error('THREE.GLTFLoader: Failed to load buffer "'+bufferDef.uri+'".'));

});

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
GLTFParser.prototype.loadBufferView=function(bufferViewIndex){

var bufferViewDef=this.json.bufferViews[bufferViewIndex];

return this.getDependency('buffer',bufferViewDef.buffer).then(function(buffer){

var byteLength=bufferViewDef.byteLength||0;
var byteOffset=bufferViewDef.byteOffset||0;
return buffer.slice(byteOffset,byteOffset+byteLength);

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
GLTFParser.prototype.loadAccessor=function(accessorIndex){

var parser=this;
var json=this.json;

var accessorDef=this.json.accessors[accessorIndex];

if(accessorDef.bufferView===undefined&&accessorDef.sparse===undefined){

// Ignore empty accessors, which may be used to declare runtime
// information about attributes coming from another source (e.g. Draco
// compression extension).
return Promise.resolve(null);

}

var pendingBufferViews=[];

if(accessorDef.bufferView!==undefined){

pendingBufferViews.push(this.getDependency('bufferView',accessorDef.bufferView));

}else{

pendingBufferViews.push(null);

}

if(accessorDef.sparse!==undefined){

pendingBufferViews.push(this.getDependency('bufferView',accessorDef.sparse.indices.bufferView));
pendingBufferViews.push(this.getDependency('bufferView',accessorDef.sparse.values.bufferView));

}

return Promise.all(pendingBufferViews).then(function(bufferViews){

var bufferView=bufferViews[0];

var itemSize=WEBGL_TYPE_SIZES[accessorDef.type];
var TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType];

// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
var elementBytes=TypedArray.BYTES_PER_ELEMENT;
var itemBytes=elementBytes*itemSize;
var byteOffset=accessorDef.byteOffset||0;
var byteStride=accessorDef.bufferView!==undefined?json.bufferViews[accessorDef.bufferView].byteStride:undefined;
var normalized=accessorDef.normalized===true;
var array,bufferAttribute;

// The buffer is not interleaved if the stride is the item size in bytes.
if(byteStride&&byteStride!==itemBytes){

var ibCacheKey='InterleavedBuffer:'+accessorDef.bufferView+':'+accessorDef.componentType;
var ib=parser.cache.get(ibCacheKey);

if(!ib){

// Use the full buffer if it's interleaved.
array=new TypedArray(bufferView);

// Integer parameters to IB/IBA are in array elements, not bytes.
ib=new InterleavedBuffer(array,byteStride/elementBytes);

parser.cache.add(ibCacheKey,ib);

}

bufferAttribute=new InterleavedBufferAttribute(ib,itemSize,byteOffset/elementBytes,normalized);

}else{

if(bufferView===null){

array=new TypedArray(accessorDef.count*itemSize);

}else{

array=new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize);

}

bufferAttribute=new BufferAttribute(array,itemSize,normalized);

}

// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
if(accessorDef.sparse!==undefined){

var itemSizeIndices=WEBGL_TYPE_SIZES.SCALAR;
var TypedArrayIndices=WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];

var byteOffsetIndices=accessorDef.sparse.indices.byteOffset||0;
var byteOffsetValues=accessorDef.sparse.values.byteOffset||0;

var sparseIndices=new TypedArrayIndices(bufferViews[1],byteOffsetIndices,accessorDef.sparse.count*itemSizeIndices);
var sparseValues=new TypedArray(bufferViews[2],byteOffsetValues,accessorDef.sparse.count*itemSize);

if(bufferView!==null){

// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
bufferAttribute.setArray(bufferAttribute.array.slice());

}

for(var i=0,il=sparseIndices.length;i<il;i++){

var index=sparseIndices[i];

bufferAttribute.setX(index,sparseValues[i*itemSize]);
if(itemSize>=2)bufferAttribute.setY(index,sparseValues[i*itemSize+1]);
if(itemSize>=3)bufferAttribute.setZ(index,sparseValues[i*itemSize+2]);
if(itemSize>=4)bufferAttribute.setW(index,sparseValues[i*itemSize+3]);
if(itemSize>=5)throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');

}

}

return bufferAttribute;

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<Texture>}
	 */
GLTFParser.prototype.loadTexture=function(textureIndex){

var parser=this;
var json=this.json;
var options=this.options;
var textureLoader=this.textureLoader;

var URL=window.URL||window.webkitURL;

var textureDef=json.textures[textureIndex];

var textureExtensions=textureDef.extensions||{};

var source;

if(textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]){

source=json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];

}else{

source=json.images[textureDef.source];

}

var sourceURI=source.uri;
var isObjectURL=false;

if(source.bufferView!==undefined){

// Load binary image data from bufferView, if provided.

sourceURI=parser.getDependency('bufferView',source.bufferView).then(function(bufferView){

isObjectURL=true;
var blob=new Blob([bufferView],{type:source.mimeType});
sourceURI=URL.createObjectURL(blob);
return sourceURI;

});

}

return Promise.resolve(sourceURI).then(function(sourceURI){

// Load Texture resource.

var loader=Loader.Handlers.get(sourceURI);

if(!loader){

loader=textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]?
parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader:
textureLoader;

}

return new Promise(function(resolve,reject){

loader.load(resolveURL(sourceURI,options.path),resolve,undefined,reject);

});

}).then(function(texture){

// Clean up resources and configure Texture.

if(isObjectURL===true){

URL.revokeObjectURL(sourceURI);

}

texture.flipY=false;

if(textureDef.name!==undefined)texture.name=textureDef.name;

// Ignore unknown mime types, like DDS files.
if(source.mimeType in MIME_TYPE_FORMATS){

texture.format=MIME_TYPE_FORMATS[source.mimeType];

}

var samplers=json.samplers||{};
var sampler=samplers[textureDef.sampler]||{};

texture.magFilter=WEBGL_FILTERS[sampler.magFilter]||LinearFilter;
texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||LinearMipMapLinearFilter;
texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||RepeatWrapping;
texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||RepeatWrapping;

return texture;

});

};

/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise}
	 */
GLTFParser.prototype.assignTexture=function(materialParams,mapName,mapDef){

var parser=this;

return this.getDependency('texture',mapDef.index).then(function(texture){

if(!texture.isCompressedTexture){

switch(mapName){

case'aoMap':
case'emissiveMap':
case'metalnessMap':
case'normalMap':
case'roughnessMap':
texture.format=RGBFormat;
break;}



}

if(parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){

var transform=mapDef.extensions!==undefined?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:undefined;

if(transform){

texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform);

}

}

materialParams[mapName]=texture;

});

};

/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accomodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
GLTFParser.prototype.assignFinalMaterial=function(mesh){

var geometry=mesh.geometry;
var material=mesh.material;
var extensions=this.extensions;

var useVertexTangents=geometry.attributes.tangent!==undefined;
var useVertexColors=geometry.attributes.color!==undefined;
var useFlatShading=geometry.attributes.normal===undefined;
var useSkinning=mesh.isSkinnedMesh===true;
var useMorphTargets=Object.keys(geometry.morphAttributes).length>0;
var useMorphNormals=useMorphTargets&&geometry.morphAttributes.normal!==undefined;

if(mesh.isPoints){

var cacheKey='PointsMaterial:'+material.uuid;

var pointsMaterial=this.cache.get(cacheKey);

if(!pointsMaterial){

pointsMaterial=new PointsMaterial();
Material.prototype.copy.call(pointsMaterial,material);
pointsMaterial.color.copy(material.color);
pointsMaterial.map=material.map;
pointsMaterial.lights=false;// PointsMaterial doesn't support lights yet

this.cache.add(cacheKey,pointsMaterial);

}

material=pointsMaterial;

}else if(mesh.isLine){

var cacheKey='LineBasicMaterial:'+material.uuid;

var lineMaterial=this.cache.get(cacheKey);

if(!lineMaterial){

lineMaterial=new LineBasicMaterial();
Material.prototype.copy.call(lineMaterial,material);
lineMaterial.color.copy(material.color);
lineMaterial.lights=false;// LineBasicMaterial doesn't support lights yet

this.cache.add(cacheKey,lineMaterial);

}

material=lineMaterial;

}

// Clone the material if it will be modified
if(useVertexTangents||useVertexColors||useFlatShading||useSkinning||useMorphTargets){

var cacheKey='ClonedMaterial:'+material.uuid+':';

if(material.isGLTFSpecularGlossinessMaterial)cacheKey+='specular-glossiness:';
if(useSkinning)cacheKey+='skinning:';
if(useVertexTangents)cacheKey+='vertex-tangents:';
if(useVertexColors)cacheKey+='vertex-colors:';
if(useFlatShading)cacheKey+='flat-shading:';
if(useMorphTargets)cacheKey+='morph-targets:';
if(useMorphNormals)cacheKey+='morph-normals:';

var cachedMaterial=this.cache.get(cacheKey);

if(!cachedMaterial){

cachedMaterial=material.isGLTFSpecularGlossinessMaterial?
extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material):
material.clone();

if(useSkinning)cachedMaterial.skinning=true;
if(useVertexTangents)cachedMaterial.vertexTangents=true;
if(useVertexColors)cachedMaterial.vertexColors=VertexColors;
if(useFlatShading)cachedMaterial.flatShading=true;
if(useMorphTargets)cachedMaterial.morphTargets=true;
if(useMorphNormals)cachedMaterial.morphNormals=true;

this.cache.add(cacheKey,cachedMaterial);

}

material=cachedMaterial;

}

// workarounds for mesh and geometry

if(material.aoMap&&geometry.attributes.uv2===undefined&&geometry.attributes.uv!==undefined){

console.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');
geometry.addAttribute('uv2',new BufferAttribute(geometry.attributes.uv.array,2));

}

if(material.isGLTFSpecularGlossinessMaterial){

// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
mesh.onBeforeRender=extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;

}

mesh.material=material;

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
GLTFParser.prototype.loadMaterial=function(materialIndex){

var parser=this;
var json=this.json;
var extensions=this.extensions;
var materialDef=json.materials[materialIndex];

var materialType;
var materialParams={};
var materialExtensions=materialDef.extensions||{};

var pending=[];

if(materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){

var sgExtension=extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
materialType=sgExtension.getMaterialType();
pending.push(sgExtension.extendParams(materialParams,materialDef,parser));

}else if(materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]){

var kmuExtension=extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
materialType=kmuExtension.getMaterialType();
pending.push(kmuExtension.extendParams(materialParams,materialDef,parser));

}else{

// Specification:
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

materialType=MeshStandardMaterial;

var metallicRoughness=materialDef.pbrMetallicRoughness||{};

materialParams.color=new Color(1.0,1.0,1.0);
materialParams.opacity=1.0;

if(Array.isArray(metallicRoughness.baseColorFactor)){

var array=metallicRoughness.baseColorFactor;

materialParams.color.fromArray(array);
materialParams.opacity=array[3];

}

if(metallicRoughness.baseColorTexture!==undefined){

pending.push(parser.assignTexture(materialParams,'map',metallicRoughness.baseColorTexture));

}

materialParams.metalness=metallicRoughness.metallicFactor!==undefined?metallicRoughness.metallicFactor:1.0;
materialParams.roughness=metallicRoughness.roughnessFactor!==undefined?metallicRoughness.roughnessFactor:1.0;

if(metallicRoughness.metallicRoughnessTexture!==undefined){

pending.push(parser.assignTexture(materialParams,'metalnessMap',metallicRoughness.metallicRoughnessTexture));
pending.push(parser.assignTexture(materialParams,'roughnessMap',metallicRoughness.metallicRoughnessTexture));

}

}

if(materialDef.doubleSided===true){

materialParams.side=DoubleSide;

}

var alphaMode=materialDef.alphaMode||ALPHA_MODES.OPAQUE;

if(alphaMode===ALPHA_MODES.BLEND){

materialParams.transparent=true;

}else{

materialParams.transparent=false;

if(alphaMode===ALPHA_MODES.MASK){

materialParams.alphaTest=materialDef.alphaCutoff!==undefined?materialDef.alphaCutoff:0.5;

}

}

if(materialDef.normalTexture!==undefined&&materialType!==MeshBasicMaterial){

pending.push(parser.assignTexture(materialParams,'normalMap',materialDef.normalTexture));

materialParams.normalScale=new Vector2(1,1);

if(materialDef.normalTexture.scale!==undefined){

materialParams.normalScale.set(materialDef.normalTexture.scale,materialDef.normalTexture.scale);

}

}

if(materialDef.occlusionTexture!==undefined&&materialType!==MeshBasicMaterial){

pending.push(parser.assignTexture(materialParams,'aoMap',materialDef.occlusionTexture));

if(materialDef.occlusionTexture.strength!==undefined){

materialParams.aoMapIntensity=materialDef.occlusionTexture.strength;

}

}

if(materialDef.emissiveFactor!==undefined&&materialType!==MeshBasicMaterial){

materialParams.emissive=new Color().fromArray(materialDef.emissiveFactor);

}

if(materialDef.emissiveTexture!==undefined&&materialType!==MeshBasicMaterial){

pending.push(parser.assignTexture(materialParams,'emissiveMap',materialDef.emissiveTexture));

}

return Promise.all(pending).then(function(){

var material;

if(materialType===ShaderMaterial){

material=extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);

}else{

material=new materialType(materialParams);

}

if(materialDef.name!==undefined)material.name=materialDef.name;

// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
if(material.map)material.map.encoding=sRGBEncoding;
if(material.emissiveMap)material.emissiveMap.encoding=sRGBEncoding;
if(material.specularMap)material.specularMap.encoding=sRGBEncoding;

assignExtrasToUserData(material,materialDef);

if(materialDef.extensions)addUnknownExtensionsToUserData(extensions,material,materialDef);

return material;

});

};

/**
	 * @param {BufferGeometry} geometry
	 * @param {GLTF.Primitive} primitiveDef
	 * @param {GLTFParser} parser
	 * @return {Promise<BufferGeometry>}
	 */
function addPrimitiveAttributes(geometry,primitiveDef,parser){

var attributes=primitiveDef.attributes;

var pending=[];

function assignAttributeAccessor(accessorIndex,attributeName){

return parser.getDependency('accessor',accessorIndex).
then(function(accessor){

geometry.addAttribute(attributeName,accessor);

});

}

for(var gltfAttributeName in attributes){

var threeAttributeName=ATTRIBUTES[gltfAttributeName]||gltfAttributeName.toLowerCase();

// Skip attributes already provided by e.g. Draco extension.
if(threeAttributeName in geometry.attributes)continue;

pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName));

}

if(primitiveDef.indices!==undefined&&!geometry.index){

var accessor=parser.getDependency('accessor',primitiveDef.indices).then(function(accessor){

geometry.setIndex(accessor);

});

pending.push(accessor);

}

assignExtrasToUserData(geometry,primitiveDef);

return Promise.all(pending).then(function(){

return primitiveDef.targets!==undefined?
addMorphTargets(geometry,primitiveDef.targets,parser):
geometry;

});

}

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
GLTFParser.prototype.loadGeometries=function(primitives){

var parser=this;
var extensions=this.extensions;
var cache=this.primitiveCache;

function createDracoPrimitive(primitive){

return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].
decodePrimitive(primitive,parser).
then(function(geometry){

return addPrimitiveAttributes(geometry,primitive,parser);

});

}

var pending=[];

for(var i=0,il=primitives.length;i<il;i++){

var primitive=primitives[i];
var cacheKey=createPrimitiveKey(primitive);

// See if we've already created this geometry
var cached=cache[cacheKey];

if(cached){

// Use the cached geometry if it exists
pending.push(cached.promise);

}else{

var geometryPromise;

if(primitive.extensions&&primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]){

// Use DRACO geometry if available
geometryPromise=createDracoPrimitive(primitive);

}else{

// Otherwise create a new geometry
geometryPromise=addPrimitiveAttributes(new BufferGeometry(),primitive,parser);

}

// Cache this geometry
cache[cacheKey]={primitive:primitive,promise:geometryPromise};

pending.push(geometryPromise);

}

}

return Promise.all(pending);

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
GLTFParser.prototype.loadMesh=function(meshIndex){

var parser=this;
var json=this.json;
var extensions=this.extensions;

var meshDef=json.meshes[meshIndex];
var primitives=meshDef.primitives;

var pending=[];

for(var i=0,il=primitives.length;i<il;i++){

var material=primitives[i].material===undefined?
createDefaultMaterial():
this.getDependency('material',primitives[i].material);

pending.push(material);

}

return Promise.all(pending).then(function(originalMaterials){

return parser.loadGeometries(primitives).then(function(geometries){

var meshes=[];

for(var i=0,il=geometries.length;i<il;i++){

var geometry=geometries[i];
var primitive=primitives[i];

// 1. create Mesh

var mesh;

var material=originalMaterials[i];

if(primitive.mode===WEBGL_CONSTANTS.TRIANGLES||
primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||
primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||
primitive.mode===undefined){

// .isSkinnedMesh isn't in glTF spec. See .markDefs()
mesh=meshDef.isSkinnedMesh===true?
new SkinnedMesh(geometry,material):
new Mesh(geometry,material);

if(mesh.isSkinnedMesh===true)mesh.normalizeSkinWeights();// #15319

if(primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP){

mesh.drawMode=TriangleStripDrawMode;

}else if(primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN){

mesh.drawMode=TriangleFanDrawMode;

}

}else if(primitive.mode===WEBGL_CONSTANTS.LINES){

mesh=new LineSegments(geometry,material);

}else if(primitive.mode===WEBGL_CONSTANTS.LINE_STRIP){

mesh=new Line(geometry,material);

}else if(primitive.mode===WEBGL_CONSTANTS.LINE_LOOP){

mesh=new LineLoop(geometry,material);

}else if(primitive.mode===WEBGL_CONSTANTS.POINTS){

mesh=new Points(geometry,material);

}else{

throw new Error('THREE.GLTFLoader: Primitive mode unsupported: '+primitive.mode);

}

if(Object.keys(mesh.geometry.morphAttributes).length>0){

updateMorphTargets(mesh,meshDef);

}

mesh.name=meshDef.name||'mesh_'+meshIndex;

if(geometries.length>1)mesh.name+='_'+i;

assignExtrasToUserData(mesh,meshDef);

parser.assignFinalMaterial(mesh);

meshes.push(mesh);

}

if(meshes.length===1){

return meshes[0];

}

var group=new Group();

for(var i=0,il=meshes.length;i<il;i++){

group.add(meshes[i]);

}

return group;

});

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<Camera>}
	 */
GLTFParser.prototype.loadCamera=function(cameraIndex){

var camera;
var cameraDef=this.json.cameras[cameraIndex];
var params=cameraDef[cameraDef.type];

if(!params){

console.warn('THREE.GLTFLoader: Missing camera parameters.');
return;

}

if(cameraDef.type==='perspective'){

camera=new PerspectiveCamera(_Math.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2e6);

}else if(cameraDef.type==='orthographic'){

camera=new OrthographicCamera(params.xmag/-2,params.xmag/2,params.ymag/2,params.ymag/-2,params.znear,params.zfar);

}

if(cameraDef.name!==undefined)camera.name=cameraDef.name;

assignExtrasToUserData(camera,cameraDef);

return Promise.resolve(camera);

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
GLTFParser.prototype.loadSkin=function(skinIndex){

var skinDef=this.json.skins[skinIndex];

var skinEntry={joints:skinDef.joints};

if(skinDef.inverseBindMatrices===undefined){

return Promise.resolve(skinEntry);

}

return this.getDependency('accessor',skinDef.inverseBindMatrices).then(function(accessor){

skinEntry.inverseBindMatrices=accessor;

return skinEntry;

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
GLTFParser.prototype.loadAnimation=function(animationIndex){

var json=this.json;

var animationDef=json.animations[animationIndex];

var pendingNodes=[];
var pendingInputAccessors=[];
var pendingOutputAccessors=[];
var pendingSamplers=[];
var pendingTargets=[];

for(var i=0,il=animationDef.channels.length;i<il;i++){

var channel=animationDef.channels[i];
var sampler=animationDef.samplers[channel.sampler];
var target=channel.target;
var name=target.node!==undefined?target.node:target.id;// NOTE: target.id is deprecated.
var input=animationDef.parameters!==undefined?animationDef.parameters[sampler.input]:sampler.input;
var output=animationDef.parameters!==undefined?animationDef.parameters[sampler.output]:sampler.output;

pendingNodes.push(this.getDependency('node',name));
pendingInputAccessors.push(this.getDependency('accessor',input));
pendingOutputAccessors.push(this.getDependency('accessor',output));
pendingSamplers.push(sampler);
pendingTargets.push(target);

}

return Promise.all([

Promise.all(pendingNodes),
Promise.all(pendingInputAccessors),
Promise.all(pendingOutputAccessors),
Promise.all(pendingSamplers),
Promise.all(pendingTargets)]).

then(function(dependencies){

var nodes=dependencies[0];
var inputAccessors=dependencies[1];
var outputAccessors=dependencies[2];
var samplers=dependencies[3];
var targets=dependencies[4];

var tracks=[];

for(var i=0,il=nodes.length;i<il;i++){

var node=nodes[i];
var inputAccessor=inputAccessors[i];
var outputAccessor=outputAccessors[i];
var sampler=samplers[i];
var target=targets[i];

if(node===undefined)continue;

node.updateMatrix();
node.matrixAutoUpdate=true;

var TypedKeyframeTrack;

switch(PATH_PROPERTIES[target.path]){

case PATH_PROPERTIES.weights:

TypedKeyframeTrack=NumberKeyframeTrack;
break;

case PATH_PROPERTIES.rotation:

TypedKeyframeTrack=QuaternionKeyframeTrack;
break;

case PATH_PROPERTIES.position:
case PATH_PROPERTIES.scale:
default:

TypedKeyframeTrack=VectorKeyframeTrack;
break;}



var targetName=node.name?node.name:node.uuid;

var interpolation=sampler.interpolation!==undefined?INTERPOLATION[sampler.interpolation]:InterpolateLinear;

var targetNames=[];

if(PATH_PROPERTIES[target.path]===PATH_PROPERTIES.weights){

// Node may be a Group (glTF mesh with several primitives) or a Mesh.
node.traverse(function(object){

if(object.isMesh===true&&object.morphTargetInfluences){

targetNames.push(object.name?object.name:object.uuid);

}

});

}else{

targetNames.push(targetName);

}

for(var j=0,jl=targetNames.length;j<jl;j++){

var track=new TypedKeyframeTrack(
targetNames[j]+'.'+PATH_PROPERTIES[target.path],
inputAccessor.array,
outputAccessor.array,
interpolation);


// Override interpolation with custom factory method.
if(sampler.interpolation==='CUBICSPLINE'){

track.createInterpolant=function InterpolantFactoryMethodGLTFCubicSpline(result){

// A CUBICSPLINE keyframe in glTF has three output values for each input value,
// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
// must be divided by three to get the interpolant's sampleSize argument.

return new GLTFCubicSplineInterpolant(this.times,this.values,this.getValueSize()/3,result);

};

// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=true;

}

tracks.push(track);

}

}

var name=animationDef.name!==undefined?animationDef.name:'animation_'+animationIndex;

return new AnimationClip(name,undefined,tracks);

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
GLTFParser.prototype.loadNode=function(nodeIndex){

var json=this.json;
var extensions=this.extensions;
var parser=this;

var meshReferences=json.meshReferences;
var meshUses=json.meshUses;

var nodeDef=json.nodes[nodeIndex];

return function(){

// .isBone isn't in glTF spec. See .markDefs
if(nodeDef.isBone===true){

return Promise.resolve(new Bone());

}else if(nodeDef.mesh!==undefined){

return parser.getDependency('mesh',nodeDef.mesh).then(function(mesh){

var node;

if(meshReferences[nodeDef.mesh]>1){

var instanceNum=meshUses[nodeDef.mesh]++;

node=mesh.clone();
node.name+='_instance_'+instanceNum;

// onBeforeRender copy for Specular-Glossiness
node.onBeforeRender=mesh.onBeforeRender;

for(var i=0,il=node.children.length;i<il;i++){

node.children[i].name+='_instance_'+instanceNum;
node.children[i].onBeforeRender=mesh.children[i].onBeforeRender;

}

}else{

node=mesh;

}

// if weights are provided on the node, override weights on the mesh.
if(nodeDef.weights!==undefined){

node.traverse(function(o){

if(!o.isMesh)return;

for(var i=0,il=nodeDef.weights.length;i<il;i++){

o.morphTargetInfluences[i]=nodeDef.weights[i];

}

});

}

return node;

});

}else if(nodeDef.camera!==undefined){

return parser.getDependency('camera',nodeDef.camera);

}else if(nodeDef.extensions&&
nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]&&
nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light!==undefined){

return parser.getDependency('light',nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);

}else{

return Promise.resolve(new Object3D());

}

}().then(function(node){

if(nodeDef.name!==undefined){

node.userData.name=nodeDef.name;
node.name=PropertyBinding.sanitizeNodeName(nodeDef.name);

}

assignExtrasToUserData(node,nodeDef);

if(nodeDef.extensions)addUnknownExtensionsToUserData(extensions,node,nodeDef);

if(nodeDef.matrix!==undefined){

var matrix=new Matrix4();
matrix.fromArray(nodeDef.matrix);
node.applyMatrix(matrix);

}else{

if(nodeDef.translation!==undefined){

node.position.fromArray(nodeDef.translation);

}

if(nodeDef.rotation!==undefined){

node.quaternion.fromArray(nodeDef.rotation);

}

if(nodeDef.scale!==undefined){

node.scale.fromArray(nodeDef.scale);

}

}

return node;

});

};

/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Scene>}
	 */
GLTFParser.prototype.loadScene=function(){

// scene node hierachy builder

function buildNodeHierachy(nodeId,parentObject,json,parser){

var nodeDef=json.nodes[nodeId];

return parser.getDependency('node',nodeId).then(function(node){

if(nodeDef.skin===undefined)return node;

// build skeleton here as well

var skinEntry;

return parser.getDependency('skin',nodeDef.skin).then(function(skin){

skinEntry=skin;

var pendingJoints=[];

for(var i=0,il=skinEntry.joints.length;i<il;i++){

pendingJoints.push(parser.getDependency('node',skinEntry.joints[i]));

}

return Promise.all(pendingJoints);

}).then(function(jointNodes){

var meshes=node.isGroup===true?node.children:[node];

for(var i=0,il=meshes.length;i<il;i++){

var mesh=meshes[i];

var bones=[];
var boneInverses=[];

for(var j=0,jl=jointNodes.length;j<jl;j++){

var jointNode=jointNodes[j];

if(jointNode){

bones.push(jointNode);

var mat=new Matrix4();

if(skinEntry.inverseBindMatrices!==undefined){

mat.fromArray(skinEntry.inverseBindMatrices.array,j*16);

}

boneInverses.push(mat);

}else{

console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',skinEntry.joints[j]);

}

}

mesh.bind(new Skeleton(bones,boneInverses),mesh.matrixWorld);

}

return node;

});

}).then(function(node){

// build node hierachy

parentObject.add(node);

var pending=[];

if(nodeDef.children){

var children=nodeDef.children;

for(var i=0,il=children.length;i<il;i++){

var child=children[i];
pending.push(buildNodeHierachy(child,node,json,parser));

}

}

return Promise.all(pending);

});

}

return function loadScene(sceneIndex){

var json=this.json;
var extensions=this.extensions;
var sceneDef=this.json.scenes[sceneIndex];
var parser=this;

var scene=new Scene();
if(sceneDef.name!==undefined)scene.name=sceneDef.name;

assignExtrasToUserData(scene,sceneDef);

if(sceneDef.extensions)addUnknownExtensionsToUserData(extensions,scene,sceneDef);

var nodeIds=sceneDef.nodes||[];

var pending=[];

for(var i=0,il=nodeIds.length;i<il;i++){

pending.push(buildNodeHierachy(nodeIds[i],scene,json,parser));

}

return Promise.all(pending).then(function(){

return scene;

});

};

}();

return GLTFLoader;

}();



// CONCATENATED MODULE: ./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--12-0!./node_modules/_thread-loader@2.1.2@thread-loader/dist/cjs.js!./node_modules/_babel-loader@8.0.6@babel-loader/lib!./node_modules/_cache-loader@2.0.1@cache-loader/dist/cjs.js??ref--0-0!./node_modules/_vue-loader@15.7.0@vue-loader/lib??vue-loader-options!./src/model-gltf.vue?vue&type=script&lang=js&


/* harmony default export */var model_gltfvue_type_script_lang_js_={
name:'model-gltf',
mixins:[model_mixin],
props:{
lights:{
type:Array,
default:function _default(){
return[{
type:'AmbientLight',
color:0xaaaaaa},
{
type:'DirectionalLight',
position:{
x:1,
y:1,
z:1},

color:0xffffff,
intensity:0.8}];

}},

gammaOutput:{
type:Boolean,
default:true}},


data:function data(){
var loader=new GLTFLoader_GLTFLoader();
loader.setCrossOrigin(this.crossOrigin);
return{
loader:loader};

},
methods:{
load:function load(){
var _this=this;

if(!this.src)return;

if(this.object){
this.wrapper.remove(this.object);
}

this.loader.load(this.src,function(data){
_this.addObject(data.scene);

_this.$emit('on-load');
},function(xhr){
_this.$emit('on-progress',xhr);
},function(err){
console.log(err);

_this.$emit('on-error',err);
});
}}};


// CONCATENATED MODULE: ./src/model-gltf.vue?vue&type=script&lang=js&
/* harmony default export */var src_model_gltfvue_type_script_lang_js_=model_gltfvue_type_script_lang_js_;
// CONCATENATED MODULE: ./src/model-gltf.vue
var model_gltf_render,model_gltf_staticRenderFns;




/* normalize component */

var model_gltf_component=normalizeComponent(
src_model_gltfvue_type_script_lang_js_,
model_gltf_render,
model_gltf_staticRenderFns,
false,
null,
null,
null);



/* harmony default export */var model_gltf=model_gltf_component.exports;
// CONCATENATED MODULE: ./src/index.js








// alias

var ModelJson=external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend(model_three,{
name:'model-json'});

var ModelDae=external_commonjs_vue_commonjs2_vue_root_Vue_default.a.extend(model_collada,{
name:'model-dae'});

var components=[model_obj,model_three,ModelJson,model_stl,model_ply,model_collada,ModelDae,model_gltf];
/* eslint-disable no-shadow */

var install=function install(Vue){
components.forEach(function(component){
Vue.component(component.name,component);
});
};

if(typeof window!=='undefined'&&window.Vue){
install(window.Vue);
}

/* harmony default export */var src={
install:install,
ModelObj:model_obj,
ModelThree:model_three,
ModelJson:ModelJson,
ModelStl:model_stl,
ModelPly:model_ply,
ModelCollada:model_collada,
ModelDae:ModelDae,
ModelGltf:model_gltf};


// CONCATENATED MODULE: ./node_modules/_@vue_cli-service@3.8.4@@vue/cli-service/lib/commands/build/entry-lib.js
/* concated harmony reexport install */__webpack_require__.d(__webpack_exports__,"install",function(){return install;});
/* concated harmony reexport ModelObj */__webpack_require__.d(__webpack_exports__,"ModelObj",function(){return model_obj;});
/* concated harmony reexport ModelThree */__webpack_require__.d(__webpack_exports__,"ModelThree",function(){return model_three;});
/* concated harmony reexport ModelJson */__webpack_require__.d(__webpack_exports__,"ModelJson",function(){return ModelJson;});
/* concated harmony reexport ModelStl */__webpack_require__.d(__webpack_exports__,"ModelStl",function(){return model_stl;});
/* concated harmony reexport ModelPly */__webpack_require__.d(__webpack_exports__,"ModelPly",function(){return model_ply;});
/* concated harmony reexport ModelCollada */__webpack_require__.d(__webpack_exports__,"ModelCollada",function(){return model_collada;});
/* concated harmony reexport ModelDae */__webpack_require__.d(__webpack_exports__,"ModelDae",function(){return ModelDae;});
/* concated harmony reexport ModelGltf */__webpack_require__.d(__webpack_exports__,"ModelGltf",function(){return model_gltf;});


/* harmony default export */var entry_lib=__webpack_exports__["default"]=src;



/***/},

/***/"c615":
/***/function c615(module,exports,__webpack_require__){

__webpack_require__("9253")('Uint32',4,function(init){
return function Uint32Array(data,byteOffset,length){
return init(this,data,byteOffset,length);
};
});


/***/},

/***/"c650":
/***/function c650(module,exports,__webpack_require__){

"use strict";

var global=__webpack_require__("3754");
var dP=__webpack_require__("ddf7");
var DESCRIPTORS=__webpack_require__("dad2");
var SPECIES=__webpack_require__("8b37")('species');

module.exports=function(KEY){
var C=global[KEY];
if(DESCRIPTORS&&C&&!C[SPECIES])dP.f(C,SPECIES,{
configurable:true,
get:function get(){return this;}});

};


/***/},

/***/"c847":
/***/function c847(module,exports,__webpack_require__){

// check on default Array iterator
var Iterators=__webpack_require__("14fc");
var ITERATOR=__webpack_require__("8b37")('iterator');
var ArrayProto=Array.prototype;

module.exports=function(it){
return it!==undefined&&(Iterators.Array===it||ArrayProto[ITERATOR]===it);
};


/***/},

/***/"c9ea":
/***/function c9ea(module,exports){

module.exports="\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003"+
"\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";


/***/},

/***/"ca2b":
/***/function ca2b(module,exports){

module.exports=false;


/***/},

/***/"cfc7":
/***/function cfc7(module,exports,__webpack_require__){

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys=__webpack_require__("fb6d");
var enumBugKeys=__webpack_require__("b4e0");

module.exports=Object.keys||function keys(O){
return $keys(O,enumBugKeys);
};


/***/},

/***/"d217":
/***/function d217(module,exports){

exports.f={}.propertyIsEnumerable;


/***/},

/***/"d4d5":
/***/function d4d5(module,exports,__webpack_require__){

"use strict";

var global=__webpack_require__("3754");
var has=__webpack_require__("03b3");
var cof=__webpack_require__("94ac");
var inheritIfRequired=__webpack_require__("44de");
var toPrimitive=__webpack_require__("5325");
var fails=__webpack_require__("b6f1");
var gOPN=__webpack_require__("a891").f;
var gOPD=__webpack_require__("acb9").f;
var dP=__webpack_require__("ddf7").f;
var $trim=__webpack_require__("539d").trim;
var NUMBER='Number';
var $Number=global[NUMBER];
var Base=$Number;
var proto=$Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF=cof(__webpack_require__("a7b8")(proto))==NUMBER;
var TRIM='trim'in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber=function toNumber(argument){
var it=toPrimitive(argument,false);
if(typeof it=='string'&&it.length>2){
it=TRIM?it.trim():$trim(it,3);
var first=it.charCodeAt(0);
var third,radix,maxCode;
if(first===43||first===45){
third=it.charCodeAt(2);
if(third===88||third===120)return NaN;// Number('+0x1') should be NaN, old V8 fix
}else if(first===48){
switch(it.charCodeAt(1)){
case 66:case 98:radix=2;maxCode=49;break;// fast equal /^0b[01]+$/i
case 79:case 111:radix=8;maxCode=55;break;// fast equal /^0o[0-7]+$/i
default:return+it;}

for(var digits=it.slice(2),i=0,l=digits.length,code;i<l;i++){
code=digits.charCodeAt(i);
// parseInt parses a string to a first unavailable symbol
// but ToNumber should return NaN if a string contains unavailable symbols
if(code<48||code>maxCode)return NaN;
}return parseInt(digits,radix);
}
}return+it;
};

if(!$Number(' 0o1')||!$Number('0b1')||$Number('+0x1')){
$Number=function Number(value){
var it=arguments.length<1?0:value;
var that=this;
return that instanceof $Number
// check on 1..constructor(foo) case
&&(BROKEN_COF?fails(function(){proto.valueOf.call(that);}):cof(that)!=NUMBER)?
inheritIfRequired(new Base(toNumber(it)),that,$Number):toNumber(it);
};
for(var keys=__webpack_require__("dad2")?gOPN(Base):(
// ES3:
'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,'+
// ES6 (in case, if modules with ES6 Number statics required before):
'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,'+
'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').
split(','),j=0,key;keys.length>j;j++){
if(has(Base,key=keys[j])&&!has($Number,key)){
dP($Number,key,gOPD(Base,key));
}
}
$Number.prototype=proto;
proto.constructor=$Number;
__webpack_require__("e5ef")(global,NUMBER,$Number);
}


/***/},

/***/"d74e":
/***/function d74e(module,exports){

module.exports=function(it,Constructor,name,forbiddenField){
if(!(it instanceof Constructor)||forbiddenField!==undefined&&forbiddenField in it){
throw TypeError(name+': incorrect invocation!');
}return it;
};


/***/},

/***/"dac5":
/***/function dac5(module,exports,__webpack_require__){

"use strict";

var addToUnscopables=__webpack_require__("644a");
var step=__webpack_require__("e650");
var Iterators=__webpack_require__("14fc");
var toIObject=__webpack_require__("3a68");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports=__webpack_require__("7656")(Array,'Array',function(iterated,kind){
this._t=toIObject(iterated);// target
this._i=0;// next index
this._k=kind;// kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
},function(){
var O=this._t;
var kind=this._k;
var index=this._i++;
if(!O||index>=O.length){
this._t=undefined;
return step(1);
}
if(kind=='keys')return step(0,index);
if(kind=='values')return step(0,O[index]);
return step(0,[index,O[index]]);
},'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments=Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/},

/***/"dad2":
/***/function dad2(module,exports,__webpack_require__){

// Thank's IE8 for his funny defineProperty
module.exports=!__webpack_require__("b6f1")(function(){
return Object.defineProperty({},'a',{get:function get(){return 7;}}).a!=7;
});


/***/},

/***/"daf2":
/***/function daf2(module,exports,__webpack_require__){

module.exports=__webpack_require__("adbd")('native-function-to-string',Function.toString);


/***/},

/***/"db4b":
/***/function db4b(module,exports,__webpack_require__){

// 7.1.13 ToObject(argument)
var defined=__webpack_require__("f01a");
module.exports=function(it){
return Object(defined(it));
};


/***/},

/***/"ddf7":
/***/function ddf7(module,exports,__webpack_require__){

var anObject=__webpack_require__("a013");
var IE8_DOM_DEFINE=__webpack_require__("568a");
var toPrimitive=__webpack_require__("5325");
var dP=Object.defineProperty;

exports.f=__webpack_require__("dad2")?Object.defineProperty:function defineProperty(O,P,Attributes){
anObject(O);
P=toPrimitive(P,true);
anObject(Attributes);
if(IE8_DOM_DEFINE)try{
return dP(O,P,Attributes);
}catch(e){/* empty */}
if('get'in Attributes||'set'in Attributes)throw TypeError('Accessors not supported!');
if('value'in Attributes)O[P]=Attributes.value;
return O;
};


/***/},

/***/"dfab":
/***/function dfab(module,exports,__webpack_require__){

var shared=__webpack_require__("adbd")('keys');
var uid=__webpack_require__("9d01");
module.exports=function(key){
return shared[key]||(shared[key]=uid(key));
};


/***/},

/***/"e3e0":
/***/function e3e0(module,exports,__webpack_require__){

var isObject=__webpack_require__("88dd");
var document=__webpack_require__("3754").document;
// typeof document.createElement is 'object' in old IE
var is=isObject(document)&&isObject(document.createElement);
module.exports=function(it){
return is?document.createElement(it):{};
};


/***/},

/***/"e5ef":
/***/function e5ef(module,exports,__webpack_require__){

var global=__webpack_require__("3754");
var hide=__webpack_require__("743d");
var has=__webpack_require__("03b3");
var SRC=__webpack_require__("9d01")('src');
var $toString=__webpack_require__("daf2");
var TO_STRING='toString';
var TPL=(''+$toString).split(TO_STRING);

__webpack_require__("a4cc").inspectSource=function(it){
return $toString.call(it);
};

(module.exports=function(O,key,val,safe){
var isFunction=typeof val=='function';
if(isFunction)has(val,'name')||hide(val,'name',key);
if(O[key]===val)return;
if(isFunction)has(val,SRC)||hide(val,SRC,O[key]?''+O[key]:TPL.join(String(key)));
if(O===global){
O[key]=val;
}else if(!safe){
delete O[key];
hide(O,key,val);
}else if(O[key]){
O[key]=val;
}else{
hide(O,key,val);
}
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype,TO_STRING,function toString(){
return typeof this=='function'&&this[SRC]||$toString.call(this);
});


/***/},

/***/"e650":
/***/function e650(module,exports){

module.exports=function(done,value){
return{value:value,done:!!done};
};


/***/},

/***/"e67d":
/***/function e67d(module,exports){

// document.currentScript polyfill by Adam Miller

// MIT license

(function(document){
var currentScript="currentScript",
scripts=document.getElementsByTagName('script');// Live NodeList collection

// If browser needs currentScript polyfill, add get currentScript() to the document object
if(!(currentScript in document)){
Object.defineProperty(document,currentScript,{
get:function get(){

// IE 6-10 supports script readyState
// IE 10+ support stack trace
try{throw new Error();}
catch(err){

// Find the second match for the "at" string to get file src url from stack.
// Specifically works with the format of stack traces in IE.
var i,res=(/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(err.stack)||[false])[1];

// For all scripts on the page, if src matches or if ready state is interactive, return the script tag
for(i in scripts){
if(scripts[i].src==res||scripts[i].readyState=="interactive"){
return scripts[i];
}
}

// If no match, return null
return null;
}
}});

}
})(document);


/***/},

/***/"f01a":
/***/function f01a(module,exports){

// 7.2.1 RequireObjectCoercible(argument)
module.exports=function(it){
if(it==undefined)throw TypeError("Can't call method on  "+it);
return it;
};


/***/},

/***/"f216":
/***/function f216(module,exports,__webpack_require__){

var redefine=__webpack_require__("e5ef");
module.exports=function(target,src,safe){
for(var key in src){redefine(target,key,src[key],safe);}
return target;
};


/***/},

/***/"f691":
/***/function f691(module,exports,__webpack_require__){

var isObject=__webpack_require__("88dd");
var isArray=__webpack_require__("b5b8");
var SPECIES=__webpack_require__("8b37")('species');

module.exports=function(original){
var C;
if(isArray(original)){
C=original.constructor;
// cross-realm fallback
if(typeof C=='function'&&(C===Array||isArray(C.prototype)))C=undefined;
if(isObject(C)){
C=C[SPECIES];
if(C===null)C=undefined;
}
}return C===undefined?Array:C;
};


/***/},

/***/"f763":
/***/function f763(module,exports,__webpack_require__){

var $iterators=__webpack_require__("dac5");
var getKeys=__webpack_require__("cfc7");
var redefine=__webpack_require__("e5ef");
var global=__webpack_require__("3754");
var hide=__webpack_require__("743d");
var Iterators=__webpack_require__("14fc");
var wks=__webpack_require__("8b37");
var ITERATOR=wks('iterator');
var TO_STRING_TAG=wks('toStringTag');
var ArrayValues=Iterators.Array;

var DOMIterables={
CSSRuleList:true,// TODO: Not spec compliant, should be false.
CSSStyleDeclaration:false,
CSSValueList:false,
ClientRectList:false,
DOMRectList:false,
DOMStringList:false,
DOMTokenList:true,
DataTransferItemList:false,
FileList:false,
HTMLAllCollection:false,
HTMLCollection:false,
HTMLFormElement:false,
HTMLSelectElement:false,
MediaList:true,// TODO: Not spec compliant, should be false.
MimeTypeArray:false,
NamedNodeMap:false,
NodeList:true,
PaintRequestList:false,
Plugin:false,
PluginArray:false,
SVGLengthList:false,
SVGNumberList:false,
SVGPathSegList:false,
SVGPointList:false,
SVGStringList:false,
SVGTransformList:false,
SourceBufferList:false,
StyleSheetList:true,// TODO: Not spec compliant, should be false.
TextTrackCueList:false,
TextTrackList:false,
TouchList:false};


for(var collections=getKeys(DOMIterables),i=0;i<collections.length;i++){
var NAME=collections[i];
var explicit=DOMIterables[NAME];
var Collection=global[NAME];
var proto=Collection&&Collection.prototype;
var key;
if(proto){
if(!proto[ITERATOR])hide(proto,ITERATOR,ArrayValues);
if(!proto[TO_STRING_TAG])hide(proto,TO_STRING_TAG,NAME);
Iterators[NAME]=ArrayValues;
if(explicit)for(key in $iterators){if(!proto[key])redefine(proto,key,$iterators[key],true);}
}
}


/***/},

/***/"f7c1":
/***/function f7c1(module,exports){

exports.f=Object.getOwnPropertySymbols;


/***/},

/***/"fb6d":
/***/function fb6d(module,exports,__webpack_require__){

var has=__webpack_require__("03b3");
var toIObject=__webpack_require__("3a68");
var arrayIndexOf=__webpack_require__("9f58")(false);
var IE_PROTO=__webpack_require__("dfab")('IE_PROTO');

module.exports=function(object,names){
var O=toIObject(object);
var i=0;
var result=[];
var key;
for(key in O){if(key!=IE_PROTO)has(O,key)&&result.push(key);}
// Don't enum bug & hidden keys
while(names.length>i){if(has(O,key=names[i++])){
~arrayIndexOf(result,key)||result.push(key);
}}
return result;
};


/***/}

/******/}));
});

/***/ }),

/***/ 11:
/*!********************************!*\
  !*** E:/tq/tq1/store/index.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(uni) {Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _regenerator = _interopRequireDefault(__webpack_require__(/*! ./node_modules/@babel/runtime/regenerator */ 12));var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _vuex = _interopRequireDefault(__webpack_require__(/*! vuex */ 15));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}

_vue.default.use(_vuex.default);



//修改之后的加法
var Add = function Add(arg1, arg2) {
  var r1, r2, m;
  try {r1 = arg1.toString().split(".")[1].length;} catch (e) {r1 = 0;}
  try {r2 = arg2.toString().split(".")[1].length;} catch (e) {r2 = 0;}
  m = Math.pow(10, Math.max(r1, r2));
  return (arg1 * m + arg2 * m) / m;
};

//修改之后的减法
var Minus = function Minus(arg1, arg2) {
  var r1, r2, m, n;
  try {r1 = arg1.toString().split(".")[1].length;} catch (e) {r1 = 0;}
  try {r2 = arg2.toString().split(".")[1].length;} catch (e) {r2 = 0;}
  m = Math.pow(10, Math.max(r1, r2));
  //动态控制精度长度
  n = r1 >= r2 ? r1 : r2;
  return ((arg1 * m - arg2 * m) / m).toFixed(n);
};
//修改之后的乘法
var Multiply = function Multiply(arg1, arg2) {
  var m = 0,s1 = arg1.toString(),s2 = arg2.toString();
  try {m += s1.split(".")[1].length;} catch (e) {}
  try {m += s2.split(".")[1].length;} catch (e) {}
  return Number(s1.replace(".", "")) * Number(s2.replace(".", "")) / Math.pow(10, m);
};
//修改之后的除法
var Division = function Division(arg1, arg2) {
  var t1 = 0,t2 = 0,r1,r2;
  try {t1 = arg1.toString().split(".")[1].length;} catch (e) {}
  try {t2 = arg2.toString().split(".")[1].length;} catch (e) {}
  // with (Math) {
  r1 = Number(arg1.toString().replace(".", ""));
  r2 = Number(arg2.toString().replace(".", ""));
  return r1 / r2 * Math.pow(10, t2 - t1);
  // }
};


var store = new _vuex.default.Store({
  state: {
    hasLogin: false,
    loginProvider: "",
    openid: null,
    sysOpenid: null, //系统openid
    orderCarList: [], //购物车列表
    IPData: { cip: '' }, //IP
    Add: Add, Minus: Minus, Multiply: Multiply, Division: Division },

  mutations: {
    login: function login(state, provider) {
      state.hasLogin = true;
      state.loginProvider = provider;
    },
    logout: function logout(state) {
      state.hasLogin = false;
      state.openid = null;
    },
    setOpenid: function setOpenid(state, openid) {
      state.openid = openid;
    },
    setSysOpenid: function setSysOpenid(state, openid) {
      state.sysOpenid = openid;
    } },

  actions: {
    // lazy loading openid
    getUserOpenId: function () {var _getUserOpenId = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {var commit, state;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:commit = _ref.commit, state = _ref.state;
                console.log("call getUserOpenId>>");_context.next = 4;return (
                  new Promise(function (resolve, reject) {
                    if (state.openid) {
                      resolve(state.openid);
                    } else {
                      uni.login({
                        provider: 'weixin',
                        success: function success(data) {
                          console.log("微信获取login success=", data);
                          commit('login');
                          setTimeout(function () {//模拟异步请求服务器获取 openid
                            var openid = data.code;
                            console.log('uni.request mock openid[' + openid + ']');
                            commit('setOpenid', openid);
                            resolve(openid);
                          }, 1000);
                        },
                        fail: function fail(err) {
                          console.log('uni.login 接口调用失败，将无法正常使用开放接口等服务', err);
                          reject(err);
                        } });

                    }
                  }));case 4:return _context.abrupt("return", _context.sent);case 5:case "end":return _context.stop();}}}, _callee, this);}));function getUserOpenId(_x) {return _getUserOpenId.apply(this, arguments);}return getUserOpenId;}(),

    getBagList: function () {var _getBagList = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee2(_ref2) {var commit, state;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:commit = _ref2.commit, state = _ref2.state;_context2.next = 3;return (
                  new Promise(function (resolve, reject) {
                    var openid = state.sysOpenid;
                    uni.request({
                      url: 'https://feiwuar.goho.co/pay/queryOrderCar',
                      data: {
                        openid: openid },

                      method: "POST",
                      header: {
                        'content-type': 'application/x-www-form-urlencoded' },

                      success: function success(res) {
                        console.log("getBagList=", res.data);
                        if (res.data.code == "0000") {
                          res.data.orderCarList.forEach(function (item) {
                            item.checked = true;
                          });
                          state.orderCarList = res.data.orderCarList;
                          setTimeout(function () {//模拟异步请求服务器获取 openid
                            resolve(res.data.orderCarList);
                          }, 1000);
                        } else {
                          reject('获取购物车信息失败！');
                        }
                      } });

                  }));case 3:return _context2.abrupt("return", _context2.sent);case 4:case "end":return _context2.stop();}}}, _callee2, this);}));function getBagList(_x2) {return _getBagList.apply(this, arguments);}return getBagList;}(),


    addBag: function () {var _addBag = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee3(_ref3, data) {var commit, state, dispatch;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:commit = _ref3.commit, state = _ref3.state, dispatch = _ref3.dispatch;if (
                data.openid) {_context3.next = 4;break;}
                uni.showToast({ title: '用户未初始化，请退出重新登录！', icon: 'none', duration: 3000 });return _context3.abrupt("return");case 4:_context3.next = 6;return (



                  new Promise(function (resolve, reject) {
                    uni.request({
                      url: 'https://feiwuar.goho.co/pay/addOrderCar',
                      data: data,
                      method: "POST",
                      header: {
                        'content-type': 'application/x-www-form-urlencoded' },

                      success: function success(res) {
                        console.log("addBag=", data, JSON.stringify(data), res);
                        uni.hideLoading();
                        if (res.data.code == "0000") {
                          resolve({ code: 0, stock: res.data.stock });
                          dispatch("getBagList").then(function (res) {
                            uni.$emit('updateBag', res);
                          });
                        } else {
                          reject({ code: 1, msg: res.data.msg || '添加购物车失败！', stock: res.data.stock });
                          setTimeout(function () {
                            uni.showToast({ title: res.data.msg || '添加购物车失败！', icon: 'none', duration: 3000 });
                          }, 500);
                        }
                      },
                      fail: function fail(err) {
                        reject({ code: 1, msg: '添加购物车异常！', stock: res.data.stock });
                        setTimeout(function () {
                          uni.showToast({ title: '添加购物车异常', icon: 'none', duration: 3000 });
                        }, 500);
                      } });

                  }));case 6:return _context3.abrupt("return", _context3.sent);case 7:case "end":return _context3.stop();}}}, _callee3, this);}));function addBag(_x3, _x4) {return _addBag.apply(this, arguments);}return addBag;}(),


    payGood: function () {var _payGood = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee4(_ref4, data) {var commit, state, dispatch, openid, price, allList, _d, flag;return _regenerator.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:commit = _ref4.commit, state = _ref4.state, dispatch = _ref4.dispatch; //立即购买
                openid = state.sysOpenid;if (
                openid) {_context4.next = 5;break;}
                uni.showToast({ title: '用户未初始化，请退出重新登录！', icon: 'none', duration: 3000 });return _context4.abrupt("return");case 5:



                price = 0.1; // data.sumMoney
                allList = [];
                _d = {
                  "good_num": data.goods_num,
                  "good_no": data.goods_no,
                  "amt": data.goods_price,
                  "good_name": data.goods_name,
                  "good_model": data.goods_model

                  // if(data.flag){
                  // 	_d.flag = data.flag
                  // }
                };flag = data.flag ? data.flag : -1;
                allList.push(_d);
                console.log(" allList =", allList);_context4.next = 13;return (
                  new Promise(function (resolve, reject) {
                    uni.request({
                      url: 'https://feiwuar.goho.co/pay/wxArPayOrder',
                      data: {
                        openid: openid,
                        price: price,
                        flag: flag,
                        allList: JSON.stringify(allList)
                        // ip: state.IPData.cip
                      },
                      method: "POST",
                      header: {
                        'content-type': 'application/x-www-form-urlencoded' },

                      success: function success(res) {
                        console.log("付钱 pay=", res, openid, price, allList);
                        if (res.statusCode == 200 && res.data.code == '0000') {
                          resolve(res.data);
                        } else {
                          uni.showToast({ title: res.data.msg || '创建订单失败！', icon: 'none', duration: 2000 });
                          reject(res.data);
                        }
                      } });

                  }));case 13:return _context4.abrupt("return", _context4.sent);case 14:case "end":return _context4.stop();}}}, _callee4, this);}));function payGood(_x5, _x6) {return _payGood.apply(this, arguments);}return payGood;}(),

    updateStock: function () {var _updateStock = _asyncToGenerator( /*#__PURE__*/_regenerator.default.mark(function _callee5(_ref5, data) {var commit, state, dispatch;return _regenerator.default.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:commit = _ref5.commit, state = _ref5.state, dispatch = _ref5.dispatch;
                console.log("释放库存订单号=", data);_context5.next = 4;return (
                  new Promise(function (resolve, reject) {
                    uni.request({
                      url: 'https://feiwuar.goho.co/pay/updateStock',
                      data: {
                        order_no: data },

                      method: "POST",
                      header: {
                        'content-type': 'application/x-www-form-urlencoded' },

                      success: function success(res) {
                        console.log("释放库存 updateStock =", res);
                      } });

                  }));case 4:return _context5.abrupt("return", _context5.sent);case 5:case "end":return _context5.stop();}}}, _callee5, this);}));function updateStock(_x7, _x8) {return _updateStock.apply(this, arguments);}return updateStock;}() } });var _default =





store;exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["default"]))

/***/ }),

/***/ 12:
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ 13);


/***/ }),

/***/ 13:
/*!************************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime-module.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ 14);

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ 14:
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);


/***/ }),

/***/ 15:
/*!********************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm.js ***!
  \********************************************/
/*! exports provided: Store, install, mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return install; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapState", function() { return mapState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapMutations", function() { return mapMutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapGetters", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() { return mapActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNamespacedHelpers", function() { return createNamespacedHelpers; });
/**
 * vuex v3.0.1
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook =
  typeof window !== 'undefined' &&
  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */


/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (true) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) { return }

  parent.removeChild(key);
};

function update (path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (true) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  var state = options.state; if ( state === void 0 ) state = {};
  if (typeof state === 'function') {
    state = state() || {};
  }

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors = { state: { configurable: true } };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors.state.set = function (v) {
  if (true) {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (true) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
     true &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (true) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  this._actionSubscribers.forEach(function (sub) { return sub(action, this$1.state); });

  return entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload)
};

Store.prototype.subscribe = function subscribe (fn) {
  return genericSubscribe(fn, this._subscribers)
};

Store.prototype.subscribeAction = function subscribeAction (fn) {
  return genericSubscribe(fn, this._actionSubscribers)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (true) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

function genericSubscribe (fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () { return fn(store); };
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ( true && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ( true && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) { return }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function () { return store.getters[type]; },
      enumerable: true
    });
  });

  return gettersProxy
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (true) {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.length
    ? path.reduce(function (state, key) { return state[key]; }, state)
    : state
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (true) {
    assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (true) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if ( true && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

function normalizeMap (map) {
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if ( true && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.0.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};


/* harmony default export */ __webpack_exports__["default"] = (index_esm);


/***/ }),

/***/ 16:
/*!***************************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2FtabBar%2Fcomponent%2Fcomponent"} ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _component = _interopRequireDefault(__webpack_require__(/*! ./pages/tabBar/component/component.vue */ 17));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_component.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ }),

/***/ 2:
/*!******************************************************************************************!*\
  !*** ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/mp-vue/dist/mp.runtime.esm.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    {
      if(vm.$scope && vm.$scope.is){
        return vm.$scope.is
      }
    }
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : undefined
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : undefined;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          {
            if(vm.mpHost === 'mp-baidu'){//百度 observer 在 setData callback 之后触发，直接忽略该 warn
                return
            }
            //fixed by xxxxxx __next_tick_pending,uni://form-field 时不告警
            if(
                key === 'value' && 
                Array.isArray(vm.$options.behaviors) &&
                vm.$options.behaviors.indexOf('uni://form-field') !== -1
              ){
              return
            }
            if(vm._getFormData){
              return
            }
            var $parent = vm.$parent;
            while($parent){
              if($parent.__next_tick_pending){
                return  
              }
              $parent = $parent.$parent;
            }
          }
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    vm.mpHost !== 'mp-toutiao' && initInjections(vm); // resolve injections before data/props  
    initState(vm);
    vm.mpHost !== 'mp-toutiao' && initProvide(vm); // resolve provide after data/props
    vm.mpHost !== 'mp-toutiao' && callHook(vm, 'created');      

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.10';

/**
 * https://raw.githubusercontent.com/Tencent/westore/master/packages/westore/utils/diff.js
 */
var ARRAYTYPE = '[object Array]';
var OBJECTTYPE = '[object Object]';
// const FUNCTIONTYPE = '[object Function]'

function diff(current, pre) {
    var result = {};
    syncKeys(current, pre);
    _diff(current, pre, '', result);
    return result
}

function syncKeys(current, pre) {
    if (current === pre) { return }
    var rootCurrentType = type(current);
    var rootPreType = type(pre);
    if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
        if(Object.keys(current).length >= Object.keys(pre).length){
            for (var key in pre) {
                var currentValue = current[key];
                if (currentValue === undefined) {
                    current[key] = null;
                } else {
                    syncKeys(currentValue, pre[key]);
                }
            }
        }
    } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
        if (current.length >= pre.length) {
            pre.forEach(function (item, index) {
                syncKeys(current[index], item);
            });
        }
    }
}

function _diff(current, pre, path, result) {
    if (current === pre) { return }
    var rootCurrentType = type(current);
    var rootPreType = type(pre);
    if (rootCurrentType == OBJECTTYPE) {
        if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
            setResult(result, path, current);
        } else {
            var loop = function ( key ) {
                var currentValue = current[key];
                var preValue = pre[key];
                var currentType = type(currentValue);
                var preType = type(preValue);
                if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
                    if (currentValue != pre[key]) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    }
                } else if (currentType == ARRAYTYPE) {
                    if (preType != ARRAYTYPE) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    } else {
                        if (currentValue.length < preValue.length) {
                            setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                        } else {
                            currentValue.forEach(function (item, index) {
                                _diff(item, preValue[index], (path == '' ? '' : path + ".") + key + '[' + index + ']', result);
                            });
                        }
                    }
                } else if (currentType == OBJECTTYPE) {
                    if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
                        setResult(result, (path == '' ? '' : path + ".") + key, currentValue);
                    } else {
                        for (var subKey in currentValue) {
                            _diff(currentValue[subKey], preValue[subKey], (path == '' ? '' : path + ".") + key + '.' + subKey, result);
                        }
                    }
                }
            };

            for (var key in current) loop( key );
        }
    } else if (rootCurrentType == ARRAYTYPE) {
        if (rootPreType != ARRAYTYPE) {
            setResult(result, path, current);
        } else {
            if (current.length < pre.length) {
                setResult(result, path, current);
            } else {
                current.forEach(function (item, index) {
                    _diff(item, pre[index], path + '[' + index + ']', result);
                });
            }
        }
    } else {
        setResult(result, path, current);
    }
}

function setResult(result, k, v) {
    // if (type(v) != FUNCTIONTYPE) {
        result[k] = v;
    // }
}

function type(obj) {
    return Object.prototype.toString.call(obj)
}

/*  */

function flushCallbacks$1(vm) {
    if (vm.__next_tick_callbacks && vm.__next_tick_callbacks.length) {
        if (Object({"NODE_ENV":"development","VUE_APP_PLATFORM":"mp-weixin","BASE_URL":"/"}).VUE_APP_DEBUG) {
            var mpInstance = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + vm._uid +
                ']:flushCallbacks[' + vm.__next_tick_callbacks.length + ']');
        }
        var copies = vm.__next_tick_callbacks.slice(0);
        vm.__next_tick_callbacks.length = 0;
        for (var i = 0; i < copies.length; i++) {
            copies[i]();
        }
    }
}

function hasRenderWatcher(vm) {
    return queue.find(function (watcher) { return vm._watcher === watcher; })
}

function nextTick$1(vm, cb) {
    //1.nextTick 之前 已 setData 且 setData 还未回调完成
    //2.nextTick 之前存在 render watcher
    if (!vm.__next_tick_pending && !hasRenderWatcher(vm)) {
        if(Object({"NODE_ENV":"development","VUE_APP_PLATFORM":"mp-weixin","BASE_URL":"/"}).VUE_APP_DEBUG){
            var mpInstance = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + vm._uid +
                ']:nextVueTick');
        }
        return nextTick(cb, vm)
    }else{
        if(Object({"NODE_ENV":"development","VUE_APP_PLATFORM":"mp-weixin","BASE_URL":"/"}).VUE_APP_DEBUG){
            var mpInstance$1 = vm.$scope;
            console.log('[' + (+new Date) + '][' + (mpInstance$1.is || mpInstance$1.route) + '][' + vm._uid +
                ']:nextMPTick');
        }
    }
    var _resolve;
    if (!vm.__next_tick_callbacks) {
        vm.__next_tick_callbacks = [];
    }
    vm.__next_tick_callbacks.push(function () {
        if (cb) {
            try {
                cb.call(vm);
            } catch (e) {
                handleError(e, vm, 'nextTick');
            }
        } else if (_resolve) {
            _resolve(vm);
        }
    });
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        })
    }
}

/*  */

function cloneWithData(vm) {
  // 确保当前 vm 所有数据被同步
  var ret = Object.create(null);
  var dataKeys = [].concat(
    Object.keys(vm._data || {}),
    Object.keys(vm._computedWatchers || {}));

  dataKeys.reduce(function(ret, key) {
    ret[key] = vm[key];
    return ret
  }, ret);
  //TODO 需要把无用数据处理掉，比如 list=>l0 则 list 需要移除，否则多传输一份数据
  Object.assign(ret, vm.$mp.data || {});
  if (
    Array.isArray(vm.$options.behaviors) &&
    vm.$options.behaviors.indexOf('uni://form-field') !== -1
  ) { //form-field
    ret['name'] = vm.name;
    ret['value'] = vm.value;
  }

  return JSON.parse(JSON.stringify(ret))
}

var patch = function(oldVnode, vnode) {
  var this$1 = this;

  if (vnode === null) { //destroy
    return
  }
  if (this.mpType === 'page' || this.mpType === 'component') {
    var mpInstance = this.$scope;
    var data = Object.create(null);
    try {
      data = cloneWithData(this);
    } catch (err) {
      console.error(err);
    }
    data.__webviewId__ = mpInstance.data.__webviewId__;
    var mpData = Object.create(null);
    Object.keys(data).forEach(function (key) { //仅同步 data 中有的数据
      mpData[key] = mpInstance.data[key];
    });
    var diffData = diff(data, mpData);
    if (Object.keys(diffData).length) {
      if (Object({"NODE_ENV":"development","VUE_APP_PLATFORM":"mp-weixin","BASE_URL":"/"}).VUE_APP_DEBUG) {
        console.log('[' + (+new Date) + '][' + (mpInstance.is || mpInstance.route) + '][' + this._uid +
          ']差量更新',
          JSON.stringify(diffData));
      }
      this.__next_tick_pending = true;
      mpInstance.setData(diffData, function () {
        this$1.__next_tick_pending = false;
        flushCallbacks$1(this$1);
      });
    } else {
      flushCallbacks$1(this);
    }
  }
};

/*  */

function createEmptyRender() {

}

function mountComponent$1(
  vm,
  el,
  hydrating
) {
  if (!vm.mpType) {//main.js 中的 new Vue
    return vm
  }
  if (vm.mpType === 'app') {
    vm.$options.render = createEmptyRender;
  }
  if (!vm.$options.render) {
    vm.$options.render = createEmptyRender;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  
  vm.mpHost !== 'mp-toutiao' && callHook(vm, 'beforeMount');

  var updateComponent = function () {
    vm._update(vm._render(), hydrating);
  };

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;
  return vm
}

/*  */

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/*  */

var MP_METHODS = ['createSelectorQuery', 'createIntersectionObserver', 'selectAllComponents', 'selectComponent'];

function getTarget(obj, path) {
  var parts = path.split('.');
  var key = parts[0];
  if (key.indexOf('__$n') === 0) { //number index
    key = parseInt(key.replace('__$n', ''));
  }
  if (parts.length === 1) {
    return obj[key]
  }
  return getTarget(obj[key], parts.slice(1).join('.'))
}

function internalMixin(Vue) {

  Vue.config.errorHandler = function(err) {
    console.error(err);
  };

  var oldEmit = Vue.prototype.$emit;

  Vue.prototype.$emit = function(event) {
    if (this.$scope && event) {
      this.$scope['triggerEvent'](event, {
        __args__: toArray(arguments, 1)
      });
    }
    return oldEmit.apply(this, arguments)
  };

  Vue.prototype.$nextTick = function(fn) {
    return nextTick$1(this, fn)
  };

  MP_METHODS.forEach(function (method) {
    Vue.prototype[method] = function(args) {
      if (this.$scope) {
        return this.$scope[method](args)
      }
    };
  });

  Vue.prototype.__init_provide = initProvide;

  Vue.prototype.__init_injections = initInjections;

  Vue.prototype.__call_hook = function(hook, args) {
    var vm = this;
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    var ret;
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        ret = invokeWithErrorHandling(handlers[i], vm, args ? [args] : null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
    return ret
  };

  Vue.prototype.__set_model = function(target, key, value, modifiers) {
    if (Array.isArray(modifiers)) {
      if (modifiers.indexOf('trim') !== -1) {
        value = value.trim();
      }
      if (modifiers.indexOf('number') !== -1) {
        value = this._n(value);
      }
    }
    if (!target) {
      target = this;
    }
    target[key] = value;
  };

  Vue.prototype.__set_sync = function(target, key, value) {
    if (!target) {
      target = this;
    }
    target[key] = value;
  };

  Vue.prototype.__get_orig = function(item) {
    if (isPlainObject(item)) {
      return item['$orig'] || item
    }
    return item
  };

  Vue.prototype.__get_value = function(dataPath, target) {
    return getTarget(target || this, dataPath)
  };


  Vue.prototype.__get_class = function(dynamicClass, staticClass) {
    return renderClass(staticClass, dynamicClass)
  };

  Vue.prototype.__get_style = function(dynamicStyle, staticStyle) {
    if (!dynamicStyle && !staticStyle) {
      return ''
    }
    var dynamicStyleObj = normalizeStyleBinding(dynamicStyle);
    var styleObj = staticStyle ? extend(staticStyle, dynamicStyleObj) : dynamicStyleObj;
    return Object.keys(styleObj).map(function (name) { return ((hyphenate(name)) + ":" + (styleObj[name])); }).join(';')
  };

  Vue.prototype.__map = function(val, iteratee) {
    //TODO 暂不考虑 string,number
    var ret, i, l, keys, key;
    if (Array.isArray(val)) {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = iteratee(val[i], i);
      }
      return ret
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = Object.create(null);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[key] = iteratee(val[key], key, i);
      }
      return ret
    }
    return []
  };

}

/*  */

var LIFECYCLE_HOOKS$1 = [
    //App
    'onLaunch',
    'onShow',
    'onHide',
    'onUniNViewMessage',
    'onError',
    //Page
    'onLoad',
    // 'onShow',
    'onReady',
    // 'onHide',
    'onUnload',
    'onPullDownRefresh',
    'onReachBottom',
    'onTabItemTap',
    'onShareAppMessage',
    'onResize',
    'onPageScroll',
    'onNavigationBarButtonTap',
    'onBackPress',
    'onNavigationBarSearchInputChanged',
    'onNavigationBarSearchInputConfirmed',
    'onNavigationBarSearchInputClicked',
    //Component
    // 'onReady', // 兼容旧版本，应该移除该事件
    'onPageShow',
    'onPageHide',
    'onPageResize'
];
function lifecycleMixin$1(Vue) {

    //fixed vue-class-component
    var oldExtend = Vue.extend;
    Vue.extend = function(extendOptions) {
        extendOptions = extendOptions || {};

        var methods = extendOptions.methods;
        if (methods) {
            Object.keys(methods).forEach(function (methodName) {
                if (LIFECYCLE_HOOKS$1.indexOf(methodName)!==-1) {
                    extendOptions[methodName] = methods[methodName];
                    delete methods[methodName];
                }
            });
        }

        return oldExtend.call(this, extendOptions)
    };

    var strategies = Vue.config.optionMergeStrategies;
    var mergeHook = strategies.created;
    LIFECYCLE_HOOKS$1.forEach(function (hook) {
        strategies[hook] = mergeHook;
    });

    Vue.prototype.__lifecycle_hooks__ = LIFECYCLE_HOOKS$1;
}

/*  */

// install platform patch function
Vue.prototype.__patch__ = patch;

// public mount method
Vue.prototype.$mount = function(
    el ,
    hydrating 
) {
    return mountComponent$1(this, el, hydrating)
};

lifecycleMixin$1(Vue);
internalMixin(Vue);

/*  */

/* harmony default export */ __webpack_exports__["default"] = (Vue);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ 3)))

/***/ }),

/***/ 24:
/*!**********************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2Fcomponent%2Faudio%2Faudio"} ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _audio = _interopRequireDefault(__webpack_require__(/*! ./pages/component/audio/audio.vue */ 25));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_audio.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ }),

/***/ 3:
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 30:
/*!**********************************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2Fcomponent%2Faudio%2FshopBag%2FshopBag"} ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _shopBag = _interopRequireDefault(__webpack_require__(/*! ./pages/component/audio/shopBag/shopBag.vue */ 31));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_shopBag.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ }),

/***/ 36:
/*!********************************************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2Fcomponent%2Faudio%2FshopBag%2FPayPage%2FPayPage"} ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _PayPage = _interopRequireDefault(__webpack_require__(/*! ./pages/component/audio/shopBag/PayPage/PayPage.vue */ 37));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_PayPage.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ }),

/***/ 4:
/*!****************************!*\
  !*** E:/tq/tq1/pages.json ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ 42:
/*!****************************************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2Fcomponent%2Faudio%2FgoodDetail%2FgoodDetail"} ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _goodDetail = _interopRequireDefault(__webpack_require__(/*! ./pages/component/audio/goodDetail/goodDetail.vue */ 43));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_goodDetail.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ }),

/***/ 50:
/*!***************************************************************************************!*\
  !*** E:/tq/tq1/main.js?{"page":"pages%2FtabBar%2Fcomponent%2FmodelPage%2FmodelPage"} ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(createPage) {__webpack_require__(/*! uni-pages */ 4);

var _vue = _interopRequireDefault(__webpack_require__(/*! vue */ 2));
var _modelPage = _interopRequireDefault(__webpack_require__(/*! ./pages/tabBar/component/modelPage/modelPage.vue */ 51));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}
createPage(_modelPage.default);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/@dcloudio/uni-mp-weixin/dist/index.js */ 1)["createPage"]))

/***/ })

}]);
//# sourceMappingURL=../../.sourcemap/mp-weixin/common/vendor.js.map